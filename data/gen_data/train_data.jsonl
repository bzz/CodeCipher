{"prompt": "def balanced_string(s: str) -> int:\n    \"\"\"\n    You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'.\n    A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string.\n    Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.\n\u00a0\n    Example 1:\n\n    Input: s = \"QWER\"\n    Output: 0\n    Explanation: s is already balanced.\n\n    Example 2:\n\n    Input: s = \"QQWE\"\n    Output: 1\n    Explanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.\n\n    Example 3:\n\n    Input: s = \"QQQW\"\n    Output: 2\n    Explanation: We can replace the first \"QQ\" to \"ER\". \n\n\u00a0\n    Constraints:\n\n    n == s.length\n    4 <= n <= 105\n    n is a multiple of 4.\n    s contains only 'Q', 'W', 'E', and 'R'.\n\n    \"\"\"\n", "canonical_solution": "    n = len(s)\n    freq_map = {}\n    for c in s:\n        freq_map[c] = freq_map.get(c, 0) + 1\n\n    i = 0\n    result = n\n    for j in range(n):\n        freq_map[s[j]] -= 1\n        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in \"QWER\"):\n            result = min(result, j - i + 1)\n            freq_map[s[i]] += 1\n            i += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef circular_permutation(n: int, start: int) -> List[int]:\n    \"\"\"\n    Given 2 integers n and start. Your task is return any permutation p\u00a0of (0,1,2.....,2^n -1) such that :\n\n    p[0] = start\n    p[i] and p[i+1]\u00a0differ by only one bit in their binary representation.\n    p[0] and p[2^n -1]\u00a0must also differ by only one bit in their binary representation.\n\n\u00a0\n    Example 1:\n\n    Input: n = 2, start = 3\n    Output: [3,2,0,1]\n    Explanation: The binary representation of the permutation is (11,10,00,01). \n    All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]\n\n    Example 2:\n\n    Input: n = 3, start = 2\n    Output: [2,6,7,5,4,0,1,3]\n    Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 16\n    0 <= start\u00a0<\u00a02 ^ n\n    \"\"\"\n", "canonical_solution": "    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef numberOfSubarrays(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\n    Return the number of nice sub-arrays.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,2,1,1], k = 3\n    Output: 2\n    Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\n\n    Example 2:\n\n    Input: nums = [2,4,6], k = 1\n    Output: 0\n    Explanation: There is no odd numbers in the array.\n\n    Example 3:\n\n    Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n    Output: 16\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 50000\n    1 <= nums[i] <= 10^5\n    1 <= k <= nums.length\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    result = count = 0\n    odd_count = [0] * (n + 1)\n\n    odd_count[0] = 1\n    for num in nums:\n        count += num % 2\n        if count >= k:\n            result += odd_count[count - k]\n        odd_count[count] += 1\n\n    return result\n\n"}
{"prompt": "def min_remove_to_make_valid(s: str) -> str:\n    \"\"\"\n    Given a string s of '(' , ')' and lowercase English characters.\n    Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n    Formally, a parentheses string is valid if and only if:\n\n    It is the empty string, contains only lowercase characters, or\n    It can be written as AB (A concatenated with B), where A and B are valid strings, or\n    It can be written as (A), where A is a valid string.\n\n\u00a0\n    Example 1:\n\n    Input: s = \"lee(t(c)o)de)\"\n    Output: \"lee(t(c)o)de\"\n    Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n\n    Example 2:\n\n    Input: s = \"a)b(c)d\"\n    Output: \"ab(c)d\"\n\n    Example 3:\n\n    Input: s = \"))((\"\n    Output: \"\"\n    Explanation: An empty string is also valid.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s[i] is either'(' , ')', or lowercase English letter.\n\n    \"\"\"\n", "canonical_solution": "    stk = []\n    result = list(s)\n\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stk.append(i)\n        elif ch == ')':\n            if stk:\n                stk.pop()\n            else:\n                result[i] = ''\n\n    for i in stk:\n        result[i] = ''\n\n    return ''.join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef numOfMinutes(n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n    \"\"\"\n    A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.\n    Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.\n    The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n    The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n    Return the number of minutes needed to inform all the employees about the urgent news.\n\u00a0\n    Example 1:\n\n    Input: n = 1, headID = 0, manager = [-1], informTime = [0]\n    Output: 0\n    Explanation: The head of the company is the only employee in the company.\n\n    Example 2:\n\n\n    Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n    Output: 1\n    Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\n    The tree structure of the employees in the company is shown.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n    0 <= headID < n\n    manager.length == n\n    0 <= manager[i] < n\n    manager[headID] == -1\n    informTime.length == n\n    0 <= informTime[i] <= 1000\n    informTime[i] == 0 if employee i has no subordinates.\n    It is guaranteed that all the employees can be informed.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(employee, subordinates, informTime):\n        if informTime[employee] == 0:\n            return 0\n        max_time = 0\n        for i in subordinates[employee]:\n            max_time = max(max_time, dfs(i, subordinates, informTime))\n        return max_time + informTime[employee]\n    subordinates = [[] for _ in range(n)]\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n    return dfs(headID, subordinates, informTime)\n\n"}
{"prompt": "from typing import List\n\n\ndef reconstructMatrix(upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given the following details of a matrix with n columns and 2 rows :\n\n    The matrix is a binary matrix, which means each element in the matrix can be 0 or 1.\n    The sum of elements of the 0-th(upper) row is given as upper.\n    The sum of elements of the 1-st(lower) row is given as lower.\n    The sum of elements in the i-th column(0-indexed) is colsum[i], where colsum is given as an integer array with length n.\n\n    Your task is to reconstruct the matrix with upper, lower and colsum.\n    Return it as a 2-D integer array.\n    If there are more than one valid solution, any of them will be accepted.\n    If no valid solution exists, return an empty 2-D array.\n\u00a0\n    Example 1:\n\n    Input: upper = 2, lower = 1, colsum = [1,1,1]\n    Output: [[1,1,0],[0,0,1]]\n    Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.\n\n    Example 2:\n\n    Input: upper = 2, lower = 3, colsum = [2,2,1,1]\n    Output: []\n\n    Example 3:\n\n    Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]\n    Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]\n\n\u00a0\n    Constraints:\n\n    1 <= colsum.length <= 10^5\n    0 <= upper, lower <= colsum.length\n    0 <= colsum[i] <= 2\n\n    \"\"\"\n", "canonical_solution": "    result = [[0] * len(colsum) for _ in range(2)]\n\n    for i in range(len(colsum)):\n        if colsum[i] == 2:\n            result[0][i] = 1\n            result[1][i] = 1\n            upper -= 1\n            lower -= 1\n        elif colsum[i] == 1:\n            if upper > lower:\n                result[0][i] = 1\n                upper -= 1\n            else:\n                result[1][i] = 1\n                lower -= 1\n\n        if upper < 0 or lower < 0:\n            return []\n\n    if upper > 0 or lower > 0:\n        return []\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef longest_consecutive(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n    You must write an algorithm that runs in\u00a0O(n)\u00a0time.\n\u00a0\n    Example 1:\n\n    Input: nums = [100,4,200,1,3,2]\n    Output: 4\n    Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\n    Example 2:\n\n    Input: nums = [0,3,7,2,5,8,4,6,0,1]\n    Output: 9\n\n\u00a0\n    Constraints:\n\n    0 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n\n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n\n    return longest_seq\n\n"}
{"prompt": "from typing import Union, List\n\n\ndef suggestedProducts(products: List[str], searchWord: str) -> List[Union]:\n    \"\"\"\n    You are given an array of strings products and a string searchWord.\n    Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n    Return a list of lists of the suggested products after each character of searchWord is typed.\n\u00a0\n    Example 1:\n\n    Input: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n    Output: [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n    Explanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\n    After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\n    After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n\n    Example 2:\n\n    Input: products = [\"havana\"], searchWord = \"havana\"\n    Output: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n    Explanation: The only word \"havana\" will be always suggested while typing the search word.\n\n\u00a0\n    Constraints:\n\n    1 <= products.length <= 1000\n    1 <= products[i].length <= 3000\n    1 <= sum(products[i].length) <= 2 * 104\n    All the strings of products are unique.\n    products[i] consists of lowercase English letters.\n    1 <= searchWord.length <= 1000\n    searchWord consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    from bisect import bisect_left\n    products.sort()\n    result = []\n    current_prefix = \"\"\n\n    for letter in searchWord:\n        current_prefix += letter\n        index = bisect_left(products, current_prefix)\n        suggestions = []\n\n        for i in range(3):\n            if index < len(products) and products[index].startswith(current_prefix):\n                suggestions.append(products[index])\n                index += 1\n            else:\n                break\n\n        result.append(suggestions)\n\n    return result\n\n"}
{"prompt": "def checkOverlap(radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle.\n    Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time.\n\u00a0\n    Example 1:\n\n\n    Input: radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n    Output: true\n    Explanation: Circle and rectangle share the point (1,0).\n\n    Example 2:\n\n    Input: radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n    Output: false\n\n    Example 3:\n\n\n    Input: radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n    Output: true\n\n\u00a0\n    Constraints:\n\n    1 <= radius <= 2000\n    -104 <= xCenter, yCenter <= 104\n    -104 <= x1 < x2 <= 104\n    -104 <= y1 < y2 <= 104\n\n    \"\"\"\n", "canonical_solution": "    xClosest = max(x1, min(xCenter, x2))\n    yClosest = max(y1, min(yCenter, y2))\n    return (xCenter - xClosest) ** 2 + (yCenter - yClosest) ** 2 <= radius ** 2\n\n"}
{"prompt": "def num_steps(s: str) -> int:\n    \"\"\"\n    Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:\n\n\n    If the current number is even, you have to divide it by 2.\n\n\n    If the current number is odd, you have to add 1 to it.\n\n\n    It is guaranteed that you can always reach one for all test cases.\n\u00a0\n    Example 1:\n\n    Input: s = \"1101\"\n    Output: 6\n    Explanation: \"1101\" corressponds to number 13 in their decimal representation.\n    Step 1) 13 is odd, add 1 and obtain 14.\u00a0\n    Step 2) 14 is even, divide by 2 and obtain 7.\n    Step 3) 7 is odd, add 1 and obtain 8.\n    Step 4) 8 is even, divide by 2 and obtain 4.\u00a0 \n    Step 5) 4 is even, divide by 2 and obtain 2.\u00a0\n    Step 6) 2 is even, divide by 2 and obtain 1.\u00a0 \n\n    Example 2:\n\n    Input: s = \"10\"\n    Output: 1\n    Explanation: \"10\" corressponds to number 2 in their decimal representation.\n    Step 1) 2 is even, divide by 2 and obtain 1.\u00a0 \n\n    Example 3:\n\n    Input: s = \"1\"\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= s.length\u00a0<= 500\n    s consists of characters '0' or '1'\n    s[0] == '1'\n\n    \"\"\"\n", "canonical_solution": "    steps = 0\n    carry = 0\n\n    for c in reversed(s[1:]):\n        bit = int(c)\n        if bit and carry:\n            carry = 1\n            steps += 2\n        elif bit or carry:\n            carry ^= 1\n            steps += 2\n        else:\n            steps += 1\n\n    return steps + carry\n\n"}
{"prompt": "from typing import List\n\n\ndef smallest_divisor(nums: List[int], threshold: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\n    Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\n    The test cases are generated so\u00a0that there will be an answer.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,5,9], threshold = 6\n    Output: 5\n    Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \n    If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \n\n    Example 2:\n\n    Input: nums = [44,22,33,11,1], threshold = 5\n    Output: 44\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 5 * 104\n    1 <= nums[i] <= 106\n    nums.length <= threshold <= 106\n\n    \"\"\"\n", "canonical_solution": "    import math\n    left, right = 1, 10**6\n    while left < right:\n        mid = (left + right) // 2\n        total = sum(math.ceil(n / mid) for n in nums)\n        if total > threshold:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n"}
{"prompt": "def entity_parser(text: str) -> str:\n    \"\"\"\n    HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.\n    The special characters and their entities for HTML are:\n\n    Quotation Mark: the entity is &quot; and symbol character is \".\n    Single Quote Mark: the entity is &apos; and symbol character is '.\n    Ampersand: the entity is &amp; and symbol character is &.\n    Greater Than Sign: the entity is &gt; and symbol character is >.\n    Less Than Sign: the entity is &lt; and symbol character is <.\n    Slash: the entity is &frasl; and symbol character is /.\n\n    Given the input text string to the HTML parser, you have to implement the entity parser.\n    Return the text after replacing the entities by the special characters.\n\u00a0\n    Example 1:\n\n    Input: text = \"&amp; is an HTML entity but &ambassador; is not.\"\n    Output: \"& is an HTML entity but &ambassador; is not.\"\n    Explanation: The parser will replace the &amp; entity by &\n\n    Example 2:\n\n    Input: text = \"and I quote: &quot;...&quot;\"\n    Output: \"and I quote: \\\"...\\\"\"\n\n\u00a0\n    Constraints:\n\n    1 <= text.length <= 105\n    The string may contain any possible characters out of all the 256 ASCII characters.\n\n    \"\"\"\n", "canonical_solution": "    entities = {\n        \"&quot;\": \"\\\"\",\n        \"&apos;\": \"'\",\n        \"&amp;\": \"&\",\n        \"&gt;\": \">\",\n        \"&lt;\": \"<\",\n        \"&frasl;\": \"/\",\n    }\n\n    result = []\n    current_entity = []\n    in_entity = False\n\n    for c in text:\n        if in_entity:\n            current_entity.append(c)\n            if c == ';':\n                entity = ''.join(current_entity)\n                if entity in entities:\n                    result.append(entities[entity])\n                else:\n                    result.extend(current_entity)\n                in_entity = False\n                current_entity.clear()\n        else:\n            if c == '&':\n                in_entity = True\n                current_entity.append(c)\n            else:\n                result.append(c)\n\n    return ''.join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSideLength(mat: List[List[int]], threshold: int) -> int:\n    \"\"\"\n    Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n\u00a0\n    Example 1:\n\n\n    Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n    Output: 2\n    Explanation: The maximum side length of square with sum less than 4 is 2 as shown.\n\n    Example 2:\n\n    Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    m == mat.length\n    n == mat[i].length\n    1 <= m, n <= 300\n    0 <= mat[i][j] <= 104\n    0 <= threshold <= 105\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(mat), len(mat[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    ans = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]\n            k = ans + 1\n            if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold:\n                ans += 1\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef partition(s: str) -> List[List[str]]:\n    \"\"\"\n    Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\u00a0\n    Example 1:\n    Input: s = \"aab\"\n    Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n    Example 2:\n    Input: s = \"a\"\n    Output: [[\"a\"]]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 16\n    s contains only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(s, start, results, current):\n        if start == len(s):\n            results.append(current[:])\n            return\n\n        for end in range(start, len(s)):\n            if isPalindrome(s, start, end):\n                current.append(s[start:end+1])\n                dfs(s, end + 1, results, current)\n                current.pop()\n\n    def isPalindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    results = []\n    dfs(s, 0, results, [])\n    return results\n\n"}
{"prompt": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    \"\"\"\n    You are given the string croakOfFrogs, which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \"croak\" are mixed.\n    Return the minimum number of different frogs to finish all the croaks in the given string.\n    A valid \"croak\" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid \"croak\" return -1.\n\u00a0\n    Example 1:\n\n    Input: croakOfFrogs = \"croakcroak\"\n    Output: 1 \n    Explanation: One frog yelling \"croak\" twice.\n\n    Example 2:\n\n    Input: croakOfFrogs = \"crcoakroak\"\n    Output: 2 \n    Explanation: The minimum number of frogs is two. \n    The first frog could yell \"crcoakroak\".\n    The second frog could yell later \"crcoakroak\".\n\n    Example 3:\n\n    Input: croakOfFrogs = \"croakcrook\"\n    Output: -1\n    Explanation: The given string is an invalid combination of \"croak\" from different frogs.\n\n\u00a0\n    Constraints:\n\n    1 <= croakOfFrogs.length <= 105\n    croakOfFrogs is either 'c', 'r', 'o', 'a', or 'k'.\n\n    \"\"\"\n", "canonical_solution": "    counter = [0] * 5\n    frogs = max_frogs = 0\n    for ch in croakOfFrogs:\n        idx = 'croak'.index(ch)\n        counter[idx] += 1\n        if idx == 0:\n            max_frogs = max(max_frogs, frogs + 1)\n            frogs += 1\n        else:\n            counter[idx - 1] -= 1\n            if counter[idx - 1] < 0:\n                return -1\n            if idx == 4:\n                frogs -= 1\n    return max_frogs if all(count == counter[0] for count in counter) else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef watched_videos_by_friends(watched_videos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n    \"\"\"\n    There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.\n    Level 1 of videos are all watched videos by your\u00a0friends, level 2 of videos are all watched videos by the friends of your\u00a0friends and so on. In general, the level k of videos are all\u00a0watched videos by people\u00a0with the shortest path exactly equal\u00a0to\u00a0k with you. Given your\u00a0id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.\u00a0\n\u00a0\n    Example 1:\n\n\n    Input: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n    Output: [\"B\",\"C\"] \n    Explanation: \n    You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\n    Person with id = 1 -> watchedVideos = [\"C\"]\u00a0\n    Person with id = 2 -> watchedVideos = [\"B\",\"C\"]\u00a0\n    The frequencies of watchedVideos by your friends are:\u00a0\n    B -> 1\u00a0\n    C -> 2\n\n    Example 2:\n\n\n    Input: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n    Output: [\"D\"]\n    Explanation: \n    You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n\n\u00a0\n    Constraints:\n\n    n == watchedVideos.length ==\u00a0friends.length\n    2 <= n\u00a0<= 100\n    1 <=\u00a0watchedVideos[i].length <= 100\n    1 <=\u00a0watchedVideos[i][j].length <= 8\n    0 <= friends[i].length < n\n    0 <= friends[i][j]\u00a0< n\n    0 <= id < n\n    1 <= level < n\n    if\u00a0friends[i] contains j, then friends[j] contains i\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    from collections import defaultdict\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef longestSubarray(nums: List[int], limit: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\n\u00a0\n    Example 1:\n\n    Input: nums = [8,2,4,7], limit = 4\n    Output: 2 \n    Explanation: All subarrays are: \n    [8] with maximum absolute diff |8-8| = 0 <= 4.\n    [8,2] with maximum absolute diff |8-2| = 6 > 4. \n    [8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n    [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n    [2] with maximum absolute diff |2-2| = 0 <= 4.\n    [2,4] with maximum absolute diff |2-4| = 2 <= 4.\n    [2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n    [4] with maximum absolute diff |4-4| = 0 <= 4.\n    [4,7] with maximum absolute diff |4-7| = 3 <= 4.\n    [7] with maximum absolute diff |7-7| = 0 <= 4. \n    Therefore, the size of the longest subarray is 2.\n\n    Example 2:\n\n    Input: nums = [10,1,2,4,7,2], limit = 5\n    Output: 4 \n    Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n\n    Example 3:\n\n    Input: nums = [4,2,2,2,4,4,2,2], limit = 0\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n    0 <= limit <= 109\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    max_deque = deque()\n    min_deque = deque()\n    left, right, longest = 0, 0, 0\n\n    while right < len(nums):\n        while max_deque and nums[right] > max_deque[-1]:\n            max_deque.pop()\n        while min_deque and nums[right] < min_deque[-1]:\n            min_deque.pop()\n\n        max_deque.append(nums[right])\n        min_deque.append(nums[right])\n\n        while max_deque[0] - min_deque[0] > limit:\n            if max_deque[0] == nums[left]:\n                max_deque.popleft()\n            if min_deque[0] == nums[left]:\n                min_deque.popleft()\n            left += 1\n\n        longest = max(longest, right - left + 1)\n        right += 1\n\n    return longest\n\n"}
{"prompt": "from typing import List\n\n\ndef build_array(target: List[int], n: int) -> List[str]:\n    \"\"\"\n    You are given an integer array target and an integer n.\n    You have an empty stack with the two following operations:\n\n    \"Push\": pushes an integer to the top of the stack.\n    \"Pop\": removes the integer on the top of the stack.\n\n    You also have a stream of the integers in the range [1, n].\n    Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:\n\n    If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n    If the stack is not empty, pop the integer at the top of the stack.\n    If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.\n\n    Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.\n\u00a0\n    Example 1:\n\n    Input: target = [1,3], n = 3\n    Output: [\"Push\",\"Push\",\"Pop\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Pop the integer on the top of the stack. s = [1].\n    Read 3 from the stream and push it to the stack. s = [1,3].\n\n    Example 2:\n\n    Input: target = [1,2,3], n = 3\n    Output: [\"Push\",\"Push\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Read 3 from the stream and push it to the stack. s = [1,2,3].\n\n    Example 3:\n\n    Input: target = [1,2], n = 4\n    Output: [\"Push\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.\n    The answers that read integer 3 from the stream are not accepted.\n\n\u00a0\n    Constraints:\n\n    1 <= target.length <= 100\n    1 <= n <= 100\n    1 <= target[i] <= n\n    target is strictly increasing.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push \")\n            result.append(\"Pop \")\n            current += 1\n        result.append(\"Push \")\n        current += 1\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef can_complete_circuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\n    You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\n    Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\n\u00a0\n    Example 1:\n\n    Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n    Output: 3\n    Explanation:\n    Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n    Travel to station 4. Your tank = 4 - 1 + 5 = 8\n    Travel to station 0. Your tank = 8 - 2 + 1 = 7\n    Travel to station 1. Your tank = 7 - 3 + 2 = 6\n    Travel to station 2. Your tank = 6 - 4 + 3 = 5\n    Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n    Therefore, return 3 as the starting index.\n\n    Example 2:\n\n    Input: gas = [2,3,4], cost = [3,4,3]\n    Output: -1\n    Explanation:\n    You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n    Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n    Travel to station 0. Your tank = 4 - 3 + 2 = 3\n    Travel to station 1. Your tank = 3 - 3 + 3 = 3\n    You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n    Therefore, you can't travel around the circuit once no matter where you start.\n\n\u00a0\n    Constraints:\n\n    n == gas.length == cost.length\n    1 <= n <= 105\n    0 <= gas[i], cost[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n\n"}
{"prompt": "def angleClock(hour: int, minutes: int) -> float:\n    \"\"\"\n    Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand.\n    Answers within 10-5 of the actual value will be accepted as correct.\n\u00a0\n    Example 1:\n\n\n    Input: hour = 12, minutes = 30\n    Output: 165\n\n    Example 2:\n\n\n    Input: hour = 3, minutes = 30\n    Output: 75\n\n    Example 3:\n\n\n    Input: hour = 3, minutes = 15\n    Output: 7.5\n\n\u00a0\n    Constraints:\n\n    1 <= hour <= 12\n    0 <= minutes <= 59\n\n    \"\"\"\n", "canonical_solution": "    minute_angle = 6 * minutes\n    hour_angle = 30 * hour + 0.5 * minutes\n    angle = abs(hour_angle - minute_angle)\n    return min(angle, 360 - angle)\n\n"}
{"prompt": "from typing import List\n\n\ndef findTheCity(n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    \"\"\"\n    There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\n    Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\n    Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n    Output: 3\n    Explanation: The figure above describes the graph.\u00a0\n    The neighboring cities at a distanceThreshold = 4 for each city are:\n    City 0 -> [City 1, City 2]\u00a0\n    City 1 -> [City 0, City 2, City 3]\u00a0\n    City 2 -> [City 0, City 1, City 3]\u00a0\n    City 3 -> [City 1, City 2]\u00a0\n    Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n    Example 2:\n\n\n    Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n    Output: 0\n    Explanation: The figure above describes the graph.\u00a0\n    The neighboring cities at a distanceThreshold = 2 for each city are:\n    City 0 -> [City 1]\u00a0\n    City 1 -> [City 0, City 4]\u00a0\n    City 2 -> [City 3, City 4]\u00a0\n    City 3 -> [City 2, City 4]\n    City 4 -> [City 1, City 2, City 3]\u00a0\n    The city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 100\n    1 <= edges.length <= n * (n - 1) / 2\n    edges[i].length == 3\n    0 <= fromi < toi < n\n    1 <= weighti,\u00a0distanceThreshold <= 10^4\n    All pairs (fromi, toi) are distinct.\n\n    \"\"\"\n", "canonical_solution": "    INF = float(\"inf\")\n    dist = [[INF] * n for _ in range(n)]\n\n    for i in range(n):\n        dist[i][i] = 0\n\n    for fr, to, w in edges:\n        dist[fr][to] = dist[to][fr] = w\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    res, minReachable = -1, n + 1\n    for i in range(n):\n        cnt = sum(1 for d in dist[i] if d <= distanceThreshold)\n        if cnt <= minReachable:\n            minReachable = cnt\n            res = i\n\n    return res\n\n"}
{"prompt": "def numberOfSubstrings(s: str) -> int:\n    \"\"\"\n    Given a string s\u00a0consisting only of characters a, b and c.\n    Return the number of substrings containing at least\u00a0one occurrence of all these characters a, b and c.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcabc\"\n    Output: 10\n    Explanation: The substrings containing\u00a0at least\u00a0one occurrence of the characters\u00a0a,\u00a0b\u00a0and\u00a0c are \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" and \"abc\" (again). \n\n    Example 2:\n\n    Input: s = \"aaacb\"\n    Output: 3\n    Explanation: The substrings containing\u00a0at least\u00a0one occurrence of the characters\u00a0a,\u00a0b\u00a0and\u00a0c are \"aaacb\", \"aacb\" and \"acb\". \n\n    Example 3:\n\n    Input: s = \"abc\"\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    3 <= s.length <= 5 x 10^4\n    s\u00a0only consists of\u00a0a, b or c\u00a0characters.\n\n    \"\"\"\n", "canonical_solution": "    res, i, count = 0, 0, [0, 0, 0]\n\n    for j, ch in enumerate(s):\n        count[ord(ch) - ord('a')] += 1\n\n        while count[0] > 0 and count[1] > 0 and count[2] > 0:\n            count[ord(s[i]) - ord('a')] -= 1\n            i += 1\n\n        res += i\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef max_events(events: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.\n    You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.\n    Return the maximum number of events you can attend.\n\u00a0\n    Example 1:\n\n\n    Input: events = [[1,2],[2,3],[3,4]]\n    Output: 3\n    Explanation: You can attend all the three events.\n    One way to attend them all is as shown.\n    Attend the first event on day 1.\n    Attend the second event on day 2.\n    Attend the third event on day 3.\n\n    Example 2:\n\n    Input: events= [[1,2],[2,3],[3,4],[1,2]]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= events.length <= 105\n    events[i].length == 2\n    1 <= startDayi <= endDayi <= 105\n\n    \"\"\"\n", "canonical_solution": "    events.sort(key=lambda x: x[1])\n\n    count = 0\n    last_day = -1\n\n    for event in events:\n        if event[0] > last_day:\n            count += 1\n            last_day = event[1]\n\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef findLeastNumOfUniqueInts(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers\u00a0arr\u00a0and an integer k.\u00a0Find the least number of unique integers\u00a0after removing exactly k elements.\n\n\n\u00a0\n    Example 1:\n\n    Input: arr = [5,5,4], k = 1\n    Output: 1\n    Explanation: Remove the single 4, only 5 is left.\n\n    Example 2:\n\n    Input: arr = [4,3,1,1,3,3,2], k = 3\n    Output: 2\n    Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n\u00a0\n    Constraints:\n\n    1 <= arr.length\u00a0<= 10^5\n    1 <= arr[i] <= 10^9\n    0 <= k\u00a0<= arr.length\n    \"\"\"\n", "canonical_solution": "    import heapq\n    from collections import Counter\n    count = Counter(arr)\n    pq = list(count.values())\n    heapq.heapify(pq)\n    while k > 0:\n        k -= heapq.heappop(pq)\n    return len(pq) if k == 0 else len(pq) + 1\n\n"}
{"prompt": "def int_to_roman(num: int) -> str:\n    \"\"\"\n    Roman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\n    Symbol       Value\n    I             1\n    V             5\n    X             10\n    L             50\n    C             100\n    D             500\n    M             1000\n    For example,\u00a02 is written as II\u00a0in Roman numeral, just two one's added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n    Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n    I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n    X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n    C can be placed before D (500) and M (1000) to make 400 and 900.\n\n    Given an integer, convert it to a roman numeral.\n\u00a0\n    Example 1:\n\n    Input: num = 3\n    Output: \"III\"\n    Explanation: 3 is represented as 3 ones.\n\n    Example 2:\n\n    Input: num = 58\n    Output: \"LVIII\"\n    Explanation: L = 50, V = 5, III = 3.\n\n    Example 3:\n\n    Input: num = 1994\n    Output: \"MCMXCIV\"\n    Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\u00a0\n    Constraints:\n\n    1 <= num <= 3999\n\n    \"\"\"\n", "canonical_solution": "    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"),\n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n\n"}
{"prompt": "from typing import List\n\n\ndef rank_teams(votes: List[str]) -> str:\n    \"\"\"\n    In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.\n    The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.\n    You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.\n    Return a string of all teams sorted by the ranking system.\n\u00a0\n    Example 1:\n\n    Input: votes = [\"ABC\",\"ACB\",\"ABC\",\"ACB\",\"ACB\"]\n    Output: \"ACB\"\n    Explanation: \n    Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.\n    Team B was ranked second by 2 voters and ranked third by 3 voters.\n    Team C was ranked second by 3 voters and ranked third by 2 voters.\n    As most of the voters ranked C second, team C is the second team, and team B is the third.\n\n    Example 2:\n\n    Input: votes = [\"WXYZ\",\"XYZW\"]\n    Output: \"XWYZ\"\n    Explanation:\n    X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. \n\n    Example 3:\n\n    Input: votes = [\"ZMNAGUEDSJYLBOPHRQICWFXTVK\"]\n    Output: \"ZMNAGUEDSJYLBOPHRQICWFXTVK\"\n    Explanation: Only one voter, so their votes are used for the ranking.\n\n\u00a0\n    Constraints:\n\n    1 <= votes.length <= 1000\n    1 <= votes[i].length <= 26\n    votes[i].length == votes[j].length for 0 <= i, j < votes.length.\n    votes[i][j] is an English uppercase letter.\n    All characters of votes[i] are unique.\n    All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.\n\n    \"\"\"\n", "canonical_solution": "    teams = len(votes[0])\n    ranks = [[0] * teams for _ in range(26)]\n\n    for vote in votes:\n        for i in range(teams):\n            ranks[ord(vote[i]) - ord('A')][i] += 1\n\n    result = list(votes[0])\n    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))\n    return ''.join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxNumberOfFamilies(n: int, reservedSeats: List[List[int]]) -> int:\n    \"\"\"\n\n    A cinema\u00a0has n\u00a0rows of seats, numbered from 1 to n\u00a0and there are ten\u00a0seats in each row, labelled from 1\u00a0to 10\u00a0as shown in the figure above.\n    Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8]\u00a0means the seat located in row 3 and labelled with 8\u00a0is already reserved.\n    Return the maximum number of four-person groups\u00a0you can assign on the cinema\u00a0seats. A four-person group\u00a0occupies four\u00a0adjacent seats in one single row. Seats across an aisle (such as [3,3]\u00a0and [3,4]) are not considered to be adjacent, but there is an exceptional case\u00a0on which an aisle split\u00a0a four-person group, in that case, the aisle split\u00a0a four-person group in the middle,\u00a0which means to have two people on each side.\n\u00a0\n    Example 1:\n\n\n    Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n    Output: 4\n    Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n\n    Example 2:\n\n    Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n    Output: 2\n\n    Example 3:\n\n    Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 10^9\n    1 <=\u00a0reservedSeats.length <= min(10*n, 10^4)\n    reservedSeats[i].length == 2\n    1\u00a0<=\u00a0reservedSeats[i][0] <= n\n    1 <=\u00a0reservedSeats[i][1] <= 10\n    All reservedSeats[i] are distinct.\n\n    \"\"\"\n", "canonical_solution": "    rows = {}\n    for seat in reservedSeats:\n        rows[seat[0]] = rows.get(seat[0], 0) | (1 << (seat[1] - 1))\n\n    max_groups = (n - len(rows)) * 2\n    for row_mask in rows.values():\n        seats = ~(row_mask | (row_mask >> 1) | (row_mask >> 2) | (row_mask >> 3)) & 0x3FF\n        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0\n\n    return max_groups\n\n"}
{"prompt": "from typing import List\n\n\ndef numOfMinutes(n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n    \"\"\"\n    A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.\n    Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.\n    The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n    The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n    Return the number of minutes needed to inform all the employees about the urgent news.\n\u00a0\n    Example 1:\n\n    Input: n = 1, headID = 0, manager = [-1], informTime = [0]\n    Output: 0\n    Explanation: The head of the company is the only employee in the company.\n\n    Example 2:\n\n\n    Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n    Output: 1\n    Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\n    The tree structure of the employees in the company is shown.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n    0 <= headID < n\n    manager.length == n\n    0 <= manager[i] < n\n    manager[headID] == -1\n    informTime.length == n\n    0 <= informTime[i] <= 1000\n    informTime[i] == 0 if employee i has no subordinates.\n    It is guaranteed that all the employees can be informed.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    subordinates = {i: [] for i in range(n)}\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n\n    queue = deque([(headID, 0)])\n    totalTime = 0\n\n    while queue:\n        current, time = queue.popleft()\n        totalTime = max(totalTime, time)\n        for sub in subordinates[current]:\n            queue.append((sub, time + informTime[current]))\n\n    return totalTime\n\n"}
{"prompt": "def can_construct(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: s = \"annabelle\", k = 2\n    Output: true\n    Explanation: You can construct two palindromes using all characters in s.\n    Some possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\n    Example 2:\n\n    Input: s = \"leetcode\", k = 3\n    Output: false\n    Explanation: It is impossible to construct 3 palindromes using all the characters of s.\n\n    Example 3:\n\n    Input: s = \"true\", k = 4\n    Output: true\n    Explanation: The only possible solution is to put each character in a separate string.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of lowercase English letters.\n    1 <= k <= 105\n\n    \"\"\"\n", "canonical_solution": "    char_counts = [0] * 26\n\n    for c in s:\n        char_counts[ord(c) - ord('a')] += 1\n\n    odd_count = sum(count % 2 for count in char_counts)\n\n    return odd_count <= k <= len(s)\n\n"}
{"prompt": "from typing import List\n\n\ndef minDifference(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums.\n    In one move, you can choose one element of nums and change it to any value.\n    Return the minimum difference between the largest and smallest value of nums after performing at most three moves.\n\u00a0\n    Example 1:\n\n    Input: nums = [5,3,2,4]\n    Output: 0\n    Explanation: We can make at most 3 moves.\n    In the first move, change 2 to 3. nums becomes [5,3,3,4].\n    In the second move, change 4 to 3. nums becomes [5,3,3,3].\n    In the third move, change 5 to 3. nums becomes [3,3,3,3].\n    After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n    Example 2:\n\n    Input: nums = [1,5,0,10,14]\n    Output: 1\n    Explanation: We can make at most 3 moves.\n    In the first move, change 5 to 0. nums becomes [1,0,0,10,14].\n    In the second move, change 10 to 0. nums becomes [1,0,0,0,14].\n    In the third move, change 14 to 1. nums becomes [1,0,0,0,1].\n    After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.\n    It can be shown that there is no way to make the difference 0 in 3 moves.\n    Example 3:\n\n    Input: nums = [3,100,20]\n    Output: 0\n    Explanation: We can make at most 3 moves.\n    In the first move, change 100 to 7. nums becomes [3,7,20].\n    In the second move, change 20 to 7. nums becomes [3,7,7].\n    In the third move, change 3 to 7. nums becomes [7,7,7].\n    After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    if n <= 4:\n        return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res\n\n"}
{"prompt": "def find_min_fibonacci_numbers(k: int) -> int:\n    \"\"\"\n    Given an integer\u00a0k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times.\n    The Fibonacci numbers are defined as:\n\n    F1 = 1\n    F2 = 1\n    Fn = Fn-1 + Fn-2 for n > 2.\n\n    It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k.\n\u00a0\n    Example 1:\n\n    Input: k = 7\n    Output: 2 \n    Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... \n    For k = 7 we can use 2 + 5 = 7.\n    Example 2:\n\n    Input: k = 10\n    Output: 2 \n    Explanation: For k = 10 we can use 2 + 8 = 10.\n\n    Example 3:\n\n    Input: k = 19\n    Output: 3 \n    Explanation: For k = 19 we can use 1 + 5 + 13 = 19.\n\n\u00a0\n    Constraints:\n\n    1 <= k <= 109\n\n    \"\"\"\n", "canonical_solution": "    if k == 0:\n        return 0\n    a, b = 0, 1\n    while b <= k:\n        a, b = b, a + b\n    return 1 + find_min_fibonacci_numbers(k - a)\n\n"}
{"prompt": "def get_happy_string(n: int, k: int) -> str:\n    \"\"\"\n    A happy string is a string that:\n\n    consists only of letters of the set ['a', 'b', 'c'].\n    s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).\n\n    For example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\n    Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\n    Return the kth string of this list or return an empty string if there are less than k happy strings of length n.\n\u00a0\n    Example 1:\n\n    Input: n = 1, k = 3\n    Output: \"c\"\n    Explanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".\n\n    Example 2:\n\n    Input: n = 1, k = 4\n    Output: \"\"\n    Explanation: There are only 3 happy strings of length 1.\n\n    Example 3:\n\n    Input: n = 3, k = 9\n    Output: \"cab\"\n    Explanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 10\n    1 <= k <= 100\n\n    \"\"\"\n", "canonical_solution": "    def dfs(s, prev):\n        if len(s) == n:\n            happy_strings.append(s)\n            return\n        for c in 'abc':\n            if c != prev:\n                dfs(s + c, c)\n\n    happy_strings = []\n    dfs(\"\", ' ')\n    return happy_strings[k - 1] if k <= len(happy_strings) else \"\"\n\n"}
{"prompt": "from typing import List\n\n\ndef process_queries(queries: List[int], m: int) -> List[int]:\n    \"\"\"\n    Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:\n\n    In the beginning, you have the permutation P=[1,2,3,...,m].\n    For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P.\u00a0Notice that the position of queries[i] in P is the result for queries[i].\n\n    Return an array containing the result for the given queries.\n\u00a0\n    Example 1:\n\n    Input: queries = [3,1,2,1], m = 5\n    Output: [2,1,2,1] \n    Explanation: The queries are processed as follow: \n    For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \n    For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \n    For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \n    For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \n    Therefore, the array containing the result is [2,1,2,1].  \n\n    Example 2:\n\n    Input: queries = [4,1,2,2], m = 4\n    Output: [3,1,2,0]\n\n    Example 3:\n\n    Input: queries = [7,5,5,8,3], m = 8\n    Output: [6,5,0,7,5]\n\n\u00a0\n    Constraints:\n\n    1 <= m <= 10^3\n    1 <= queries.length <= m\n    1 <= queries[i] <= m\n    \"\"\"\n", "canonical_solution": "    nums = list(range(1, m+1))\n    result = []\n    for q in queries:\n        pos = nums.index(q)\n        result.append(pos)\n        del nums[pos]\n        nums.insert(0, q)\n    return result\n\n"}
{"prompt": "def entityParser(text: str) -> str:\n    \"\"\"\n    HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.\n    The special characters and their entities for HTML are:\n\n    Quotation Mark: the entity is &quot; and symbol character is \".\n    Single Quote Mark: the entity is &apos; and symbol character is '.\n    Ampersand: the entity is &amp; and symbol character is &.\n    Greater Than Sign: the entity is &gt; and symbol character is >.\n    Less Than Sign: the entity is &lt; and symbol character is <.\n    Slash: the entity is &frasl; and symbol character is /.\n\n    Given the input text string to the HTML parser, you have to implement the entity parser.\n    Return the text after replacing the entities by the special characters.\n\u00a0\n    Example 1:\n\n    Input: text = \"&amp; is an HTML entity but &ambassador; is not.\"\n    Output: \"& is an HTML entity but &ambassador; is not.\"\n    Explanation: The parser will replace the &amp; entity by &\n\n    Example 2:\n\n    Input: text = \"and I quote: &quot;...&quot;\"\n    Output: \"and I quote: \\\"...\\\"\"\n\n\u00a0\n    Constraints:\n\n    1 <= text.length <= 105\n    The string may contain any possible characters out of all the 256 ASCII characters.\n\n    \"\"\"\n", "canonical_solution": "    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n\n"}
{"prompt": "def check_if_can_break(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings: s1 and s2 with the same\u00a0size, check if some\u00a0permutation of string s1 can break\u00a0some\u00a0permutation of string s2 or vice-versa. In other words s2 can break s1\u00a0or vice-versa.\n    A string x\u00a0can break\u00a0string y\u00a0(both of size n) if x[i] >= y[i]\u00a0(in alphabetical order)\u00a0for all i\u00a0between 0 and n-1.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"abc\", s2 = \"xya\"\n    Output: true\n    Explanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\".\n\n    Example 2:\n\n    Input: s1 = \"abe\", s2 = \"acd\"\n    Output: false \n    Explanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n\n    Example 3:\n\n    Input: s1 = \"leetcodee\", s2 = \"interview\"\n    Output: true\n\n\u00a0\n    Constraints:\n\n    s1.length == n\n    s2.length == n\n    1 <= n <= 10^5\n    All strings consist of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    s1 = sorted(s1)\n    s2 = sorted(s2)\n\n    can_break_1 = can_break_2 = True\n    for c1, c2 in zip(s1, s2):\n        if c1 < c2:\n            can_break_1 = False\n        if c2 < c1:\n            can_break_2 = False\n\n    return can_break_1 or can_break_2\n\n"}
{"prompt": "from typing import List\n\n\ndef minSwaps(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.\n    A grid is said to be valid if all the cells above the main diagonal are zeros.\n    Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.\n    The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,1],[1,1,0],[1,0,0]]\n    Output: 3\n\n    Example 2:\n\n\n    Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n    Output: -1\n    Explanation: All rows are similar, swaps have no effect on the grid.\n\n    Example 3:\n\n\n    Input: grid = [[1,0,0],[1,1,0],[1,1,1]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == grid.length == grid[i].length\n    1 <= n <= 200\n    grid[i][j] is either 0 or 1\n\n    \"\"\"\n", "canonical_solution": "    n = len(grid)\n    steps = 0\n\n    for i in range(n):\n        row = -1\n        for j in range(i, n):\n            if grid[j][i] == 0:\n                row = j\n                break\n        if row == -1:\n            return -1\n\n        while row > i:\n            grid[row], grid[row - 1] = grid[row - 1], grid[row]\n            steps += 1\n            row -= 1\n\n    return steps\n\n"}
{"prompt": "from typing import List\n\n\ndef maxScore(cardPoints: List[int], k: int) -> int:\n    \"\"\"\n    There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.\n    In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\n    Your score is the sum of the points of the cards you have taken.\n    Given the integer array cardPoints and the integer k, return the maximum score you can obtain.\n\u00a0\n    Example 1:\n\n    Input: cardPoints = [1,2,3,4,5,6,1], k = 3\n    Output: 12\n    Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.\n\n    Example 2:\n\n    Input: cardPoints = [2,2,2], k = 2\n    Output: 4\n    Explanation: Regardless of which two cards you take, your score will always be 4.\n\n    Example 3:\n\n    Input: cardPoints = [9,7,7,9,7,7,9], k = 7\n    Output: 55\n    Explanation: You have to take all the cards. Your score is the sum of points of all cards.\n\n\u00a0\n    Constraints:\n\n    1 <= cardPoints.length <= 105\n    1 <= cardPoints[i] <= 104\n    1 <= k <= cardPoints.length\n\n    \"\"\"\n", "canonical_solution": "    n = len(cardPoints)\n    total = sum(cardPoints[:k])\n\n    max_score = total\n    for i in range(k - 1, -1, -1):\n        j = n - k + i\n        total += cardPoints[j] - cardPoints[i]\n        max_score = max(max_score, total)\n\n    return max_score\n\n"}
{"prompt": "from typing import List\n\n\ndef find_diagonal_order(nums: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.\n\u00a0\n    Example 1:\n\n\n    Input: nums = [[1,2,3],[4,5,6],[7,8,9]]\n    Output: [1,4,2,7,5,3,8,6,9]\n\n    Example 2:\n\n\n    Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n    Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i].length <= 105\n    1 <= sum(nums[i].length) <= 105\n    1 <= nums[i][j] <= 105\n\n    \"\"\"\n", "canonical_solution": "    diagonals = {}\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if i + j not in diagonals:\n                diagonals[i + j] = []\n            diagonals[i + j].append(nums[i][j])\n\n    res = []\n    for key in diagonals:\n        res.extend(reversed(diagonals[key]))\n\n    return res\n\n"}
{"prompt": "def canConvertString(s: str, t: str, k: int) -> bool:\n    \"\"\"\n    Given two strings\u00a0s\u00a0and\u00a0t, your goal is to convert\u00a0s\u00a0into\u00a0t\u00a0in\u00a0k\u00a0moves or less.\n    During the\u00a0ith\u00a0(1 <= i <= k)\u00a0move you can:\n\n    Choose any index\u00a0j\u00a0(1-indexed) from\u00a0s, such that\u00a01 <= j <= s.length\u00a0and j\u00a0has not been chosen in any previous move,\u00a0and shift the character at that index\u00a0i\u00a0times.\n    Do nothing.\n\n    Shifting a character means replacing it by the next letter in the alphabet\u00a0(wrapping around so that\u00a0'z'\u00a0becomes\u00a0'a'). Shifting a character by\u00a0i\u00a0means applying the shift operations\u00a0i\u00a0times.\n    Remember that any index\u00a0j\u00a0can be picked at most once.\n    Return\u00a0true\u00a0if it's possible to convert\u00a0s\u00a0into\u00a0t\u00a0in no more than\u00a0k\u00a0moves, otherwise return\u00a0false.\n\u00a0\n    Example 1:\n\n    Input: s = \"input\", t = \"ouput\", k = 9\n    Output: true\n    Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\n    Example 2:\n\n    Input: s = \"abc\", t = \"bcd\", k = 10\n    Output: false\n    Explanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\n    Example 3:\n\n    Input: s = \"aab\", t = \"bbb\", k = 27\n    Output: true\n    Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length, t.length <= 10^5\n    0 <= k <= 10^9\n    s, t contain\u00a0only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    if len(s) != len(t):\n        return False\n    count = [0] * 26\n    for i in range(len(s)):\n        diff = (ord(t[i]) - ord(s[i]) + 26) % 26\n        if diff > 0:\n            count[diff] += 1\n    for i in range(1, 26):\n        if count[i] > 0:\n            if count[i] * 26 - 26 + i > k:\n                return False\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef evalRPN(tokens: List[str]) -> int:\n    \"\"\"\n    You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\n    Evaluate the expression. Return an integer that represents the value of the expression.\n    Note that:\n\n    The valid operators are '+', '-', '*', and '/'.\n    Each operand may be an integer or another expression.\n    The division between two integers always truncates toward zero.\n    There will not be any division by zero.\n    The input represents a valid arithmetic expression in a reverse polish notation.\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\n\n\u00a0\n    Example 1:\n\n    Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n    Output: 9\n    Explanation: ((2 + 1) * 3) = 9\n\n    Example 2:\n\n    Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n    Output: 6\n    Explanation: (4 + (13 / 5)) = 6\n\n    Example 3:\n\n    Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n    Output: 22\n    Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n    = ((10 * (6 / (12 * -11))) + 17) + 5\n    = ((10 * (6 / -132)) + 17) + 5\n    = ((10 * 0) + 17) + 5\n    = (0 + 17) + 5\n    = 17 + 5\n    = 22\n\n\u00a0\n    Constraints:\n\n    1 <= tokens.length <= 104\n    tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]\n\n"}
{"prompt": "from typing import List\n\n\ndef maxNonOverlapping(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1,1,1], target = 2\n    Output: 2\n    Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\n    Example 2:\n\n    Input: nums = [-1,3,5,1,4,2,-9], target = 6\n    Output: 2\n    Explanation: There are 3 subarrays with sum equal to 6.\n    ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n    0 <= target <= 106\n\n    \"\"\"\n", "canonical_solution": "    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef build_array(target: List[int], n: int) -> List[str]:\n    \"\"\"\n    You are given an integer array target and an integer n.\n    You have an empty stack with the two following operations:\n\n    \"Push\": pushes an integer to the top of the stack.\n    \"Pop\": removes the integer on the top of the stack.\n\n    You also have a stream of the integers in the range [1, n].\n    Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:\n\n    If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n    If the stack is not empty, pop the integer at the top of the stack.\n    If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.\n\n    Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.\n\u00a0\n    Example 1:\n\n    Input: target = [1,3], n = 3\n    Output: [\"Push\",\"Push\",\"Pop\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Pop the integer on the top of the stack. s = [1].\n    Read 3 from the stream and push it to the stack. s = [1,3].\n\n    Example 2:\n\n    Input: target = [1,2,3], n = 3\n    Output: [\"Push\",\"Push\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Read 3 from the stream and push it to the stack. s = [1,2,3].\n\n    Example 3:\n\n    Input: target = [1,2], n = 4\n    Output: [\"Push\",\"Push\"]\n    Explanation: Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [1,2].\n    Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.\n    The answers that read integer 3 from the stream are not accepted.\n\n\u00a0\n    Constraints:\n\n    1 <= target.length <= 100\n    1 <= n <= 100\n    1 <= target[i] <= n\n    target is strictly increasing.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push\")\n            result.append(\"Pop\")\n            current += 1\n        result.append(\"Push\")\n        current += 1\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef countTriplets(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr.\n    We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).\n    Let's define a and b as follows:\n\n    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\n    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n\n    Note that ^ denotes the bitwise-xor operation.\n    Return the number of triplets (i, j and k) Where a == b.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,3,1,6,7]\n    Output: 4\n    Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\n\n    Example 2:\n\n    Input: arr = [1,1,1,1,1]\n    Output: 10\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 300\n    1 <= arr[i] <= 108\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    XOR = [0] * (n + 1)\n\n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n\n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    return count\n\n"}
{"prompt": "def has_all_codes(s: str, k: int) -> bool:\n    \"\"\"\n    Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.\n\u00a0\n    Example 1:\n\n    Input: s = \"00110110\", k = 2\n    Output: true\n    Explanation: The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.\n\n    Example 2:\n\n    Input: s = \"0110\", k = 1\n    Output: true\n    Explanation: The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring. \n\n    Example 3:\n\n    Input: s = \"0110\", k = 2\n    Output: false\n    Explanation: The binary code \"00\" is of length 2 and does not exist in the array.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 5 * 105\n    s[i] is either '0' or '1'.\n    1 <= k <= 20\n\n    \"\"\"\n", "canonical_solution": "    need = 1 << k\n    got = set()\n\n    for i in range(len(s) - k + 1):\n        got.add(s[i:i + k])\n\n    return len(got) == need\n\n"}
{"prompt": "from typing import List\n\n\ndef checkIfPrerequisite(numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    \"\"\"\n    There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.\n\n    For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.\n\n    Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.\n    You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.\n    Return a boolean array answer, where answer[j] is the answer to the jth query.\n\u00a0\n    Example 1:\n\n\n    Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n    Output: [false,true]\n    Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.\n    Course 0 is not a prerequisite of course 1, but the opposite is true.\n\n    Example 2:\n\n    Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n    Output: [false,false]\n    Explanation: There are no prerequisites, and each course is independent.\n\n    Example 3:\n\n\n    Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n    Output: [true,true]\n\n\u00a0\n    Constraints:\n\n    2 <= numCourses <= 100\n    0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)\n    prerequisites[i].length == 2\n    0 <= ai, bi <= n - 1\n    ai != bi\n    All the pairs [ai, bi] are unique.\n    The prerequisites graph has no cycles.\n    1 <= queries.length <= 104\n    0 <= ui, vi <= n - 1\n    ui != vi\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n\n    def DFS(src, graph, visited, transitive_closure, dest):\n        if src == dest:\n            transitive_closure[dest] = True\n            return\n        if visited[src]:\n            return\n        visited[src] = True\n        for neighbor in graph[src]:\n            DFS(neighbor, graph, visited, transitive_closure, dest)\n            if transitive_closure[dest]:\n                return\n    graph = defaultdict(list)\n\n    for pre in prerequisites:\n        graph[pre[0]].append(pre[1])\n\n    result = []\n\n    for i in range(len(queries)):\n        visited = [False] * numCourses\n        transitive_closure = [False] * numCourses\n        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])\n        result.append(transitive_closure[queries[i][1]])\n\n    return result\n\n"}
{"prompt": "def arrangeWords(text: str) -> str:\n    \"\"\"\n    Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\n    First letter is in upper case.\n    Each word in text are separated by a single space.\n\n    Your task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\n    Return the new text\u00a0following the format shown above.\n\u00a0\n    Example 1:\n\n    Input: text = \"Leetcode is cool\"\n    Output: \"Is cool leetcode\"\n    Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\n    Output is ordered by length and the new first word starts with capital letter.\n\n    Example 2:\n\n    Input: text = \"Keep calm and code on\"\n    Output: \"On and keep calm code\"\n    Explanation: Output is ordered as follows:\n    \"On\" 2 letters.\n    \"and\" 3 letters.\n    \"keep\" 4 letters in case of tie order by position in original text.\n    \"calm\" 4 letters.\n    \"code\" 4 letters.\n\n    Example 3:\n\n    Input: text = \"To be or not to be\"\n    Output: \"To be or to be not\"\n\n\u00a0\n    Constraints:\n\n    text begins with a capital letter and then contains lowercase letters and single space between words.\n    1 <= text.length <= 10^5\n\n    \"\"\"\n", "canonical_solution": "    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)\n\n"}
{"prompt": "def max_vowels(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\n    Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\n\u00a0\n    Example 1:\n\n    Input: s = \"abciiidef\", k = 3\n    Output: 3\n    Explanation: The substring \"iii\" contains 3 vowel letters.\n\n    Example 2:\n\n    Input: s = \"aeiou\", k = 2\n    Output: 2\n    Explanation: Any substring of length 2 contains 2 vowels.\n\n    Example 3:\n\n    Input: s = \"leetcode\", k = 3\n    Output: 2\n    Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of lowercase English letters.\n    1 <= k <= s.length\n\n    \"\"\"\n", "canonical_solution": "    max_count = count = 0\n    for i, c in enumerate(s):\n        count += int(c in 'aeiou')\n        if i >= k:\n            count -= int(s[i - k] in 'aeiou')\n        max_count = max(max_count, count)\n    return max_count\n\n"}
{"prompt": "from typing import List\n\n\ndef min_sum_of_lengths(arr: List[int], target: int) -> int:\n    \"\"\"\n    You are given an array of integers arr and an integer target.\n    You have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.\n    Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.\n\u00a0\n    Example 1:\n\n    Input: arr = [3,2,2,4,3], target = 3\n    Output: 2\n    Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n\n    Example 2:\n\n    Input: arr = [7,3,4,7], target = 7\n    Output: 2\n    Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n\n    Example 3:\n\n    Input: arr = [4,3,2,6,2,3,4], target = 6\n    Output: -1\n    Explanation: We have only one sub-array of sum = 6.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    1 <= arr[i] <= 1000\n    1 <= target <= 108\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    sum_, min_len, result = 0, float('inf'), float('inf')\n    mp = {0: -1}\n\n    for i in range(n):\n        sum_ += arr[i]\n        if sum_ >= target and (sum_ - target) in mp:\n            if mp[sum_ - target] > -1 and min_len != float('inf'):\n                result = min(result, i - mp[sum_ - target] + min_len)\n            min_len = min(min_len, i - mp[sum_ - target])\n        mp[sum_] = i\n\n    return result if result != float('inf') else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef findLengthOfShortestSubarray(arr: List[int]) -> int:\n    \"\"\"\n    Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\n    Return the length of the shortest subarray to remove.\n    A subarray is a contiguous subsequence of the array.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2,3,10,4,2,3,5]\n    Output: 3\n    Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\n    Another correct solution is to remove the subarray [3,10,4].\n\n    Example 2:\n\n    Input: arr = [5,4,3,2,1]\n    Output: 4\n    Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].\n\n    Example 3:\n\n    Input: arr = [1,2,3]\n    Output: 0\n    Explanation: The array is already non-decreasing. We do not need to remove any elements.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    0 <= arr[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    left, right = 0, n - 1\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n    if left == n - 1:\n        return 0\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n    result = min(n - left - 1, right)\n    i, j = 0, right\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maxArea(h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\n    \"\"\"\n    You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:\n\n    horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and\n    verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.\n\n    Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.\n\u00a0\n    Example 1:\n\n\n    Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n    Output: 4 \n    Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\n    Example 2:\n\n\n    Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n    Output: 6\n    Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\n    Example 3:\n\n    Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n    Output: 9\n\n\u00a0\n    Constraints:\n\n    2 <= h, w <= 109\n    1 <= horizontalCuts.length <= min(h - 1, 105)\n    1 <= verticalCuts.length <= min(w - 1, 105)\n    1 <= horizontalCuts[i] < h\n    1 <= verticalCuts[i] < w\n    All the elements in horizontalCuts are distinct.\n    All the elements in verticalCuts are distinct.\n\n    \"\"\"\n", "canonical_solution": "    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)\n\n"}
{"prompt": "def kth_factor(n: int, k: int) -> int:\n    \"\"\"\n    You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\n    Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n\u00a0\n    Example 1:\n\n    Input: n = 12, k = 3\n    Output: 3\n    Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n\n    Example 2:\n\n    Input: n = 7, k = 2\n    Output: 7\n    Explanation: Factors list is [1, 7], the 2nd factor is 7.\n\n    Example 3:\n\n    Input: n = 4, k = 4\n    Output: -1\n    Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n\n\u00a0\n    Constraints:\n\n    1 <= k <= n <= 1000\n\n\u00a0\n    Follow up:\n    Could you solve this problem in less than O(n) complexity?\n    \"\"\"\n", "canonical_solution": "    for i in range(1, n+1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1\n\n"}
{"prompt": "from typing import List\n\n\ndef findMaxLength(nums: List[int]) -> int:\n    \"\"\"\n    Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1]\n    Output: 2\n    Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\n    Example 2:\n\n    Input: nums = [0,1,0]\n    Output: 2\n    Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    max_length, zeroes, ones = 0, 0, 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num == 0:\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes - ones not in count_map:\n            count_map[zeroes - ones] = i\n        else:\n            max_length = max(max_length, i - count_map[zeroes - ones])\n\n    return max_length\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -> int:\n    \"\"\"\n    We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.\n    Return the maximum total sum of all requests among all permutations of nums.\n    Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n    Output: 19\n    Explanation: One permutation of nums is [2,1,3,4,5] with the following result: \n    requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\n    requests[1] -> nums[0] + nums[1] = 2 + 1 = 3\n    Total sum: 8 + 3 = 11.\n    A permutation with a higher total sum is [3,5,4,2,1] with the following result:\n    requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\n    requests[1] -> nums[0] + nums[1] = 3 + 5  = 8\n    Total sum: 11 + 8 = 19, which is the best that you can do.\n\n    Example 2:\n\n    Input: nums = [1,2,3,4,5,6], requests = [[0,1]]\n    Output: 11\n    Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\n    Example 3:\n\n    Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n    Output: 47\n    Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 105\n    0 <= nums[i]\u00a0<= 105\n    1 <= requests.length <=\u00a0105\n    requests[i].length == 2\n    0 <= starti\u00a0<= endi\u00a0<\u00a0n\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    count = [0] * n\n    for request in requests:\n        count[request[0]] += 1\n        if request[1] + 1 < n:\n            count[request[1] + 1] -= 1\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + nums[i] * count[i]) % 1000000007\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef minSubarray(nums: List[int], p: int) -> int:\n    \"\"\"\n    Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.\n    Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.\n    A subarray is defined as a contiguous block of elements in the array.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,1,4,2], p = 6\n    Output: 1\n    Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.\n\n    Example 2:\n\n    Input: nums = [6,3,5,2], p = 9\n    Output: 2\n    Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.\n\n    Example 3:\n\n    Input: nums = [1,2,3], p = 3\n    Output: 0\n    Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n    1 <= p <= 109\n\n    \"\"\"\n", "canonical_solution": "    n, res, need, cur = len(nums), len(nums), 0, 0\n    for num in nums:\n        need = (need + num) % p\n    if need == 0:\n        return 0\n    last_seen = {0: -1}\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        res = min(res, i - last_seen.get((cur - need + p) % p, -n))\n    return res if res < n else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef minOperationsMaxProfit(customers: List[int], boardingCost: int, runningCost: int) -> int:\n    \"\"\"\n    You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\n    You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\n    You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\n    Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\n\u00a0\n    Example 1:\n\n\n    Input: customers = [8,3], boardingCost = 5, runningCost = 6\n    Output: 3\n    Explanation: The numbers written on the gondolas are the number of people currently there.\n    1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n    2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n    3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\n    The highest profit was $37 after rotating the wheel 3 times.\n\n    Example 2:\n\n    Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\n    Output: 7\n    Explanation:\n    1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n    2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n    3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n    4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n    5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n    6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n    7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\n    The highest profit was $122 after rotating the wheel 7 times.\n\n    Example 3:\n\n    Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n    Output: -1\n    Explanation:\n    1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n    2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n    3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n    4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n    5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\n    The profit was never positive, so return -1.\n\n\u00a0\n    Constraints:\n\n    n == customers.length\n    1 <= n <= 105\n    0 <= customers[i] <= 50\n    1 <= boardingCost, runningCost <= 100\n\n    \"\"\"\n", "canonical_solution": "    waiting = 0\n    profit = 0\n    max_profit = 0\n    rotations = 0\n    result = -1\n\n    for i in range(len(customers) + sum(customers)):\n        if i < len(customers):\n            waiting += customers[i]\n        boarding = min(waiting, 4)\n        waiting -= boarding\n        profit += boarding * boardingCost - runningCost\n\n        if profit > max_profit:\n            max_profit = profit\n            result = rotations + 1\n        rotations += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef find_least_num_of_unique_ints(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers\u00a0arr\u00a0and an integer k.\u00a0Find the least number of unique integers\u00a0after removing exactly k elements.\n\n\n\u00a0\n    Example 1:\n\n    Input: arr = [5,5,4], k = 1\n    Output: 1\n    Explanation: Remove the single 4, only 5 is left.\n\n    Example 2:\n\n    Input: arr = [4,3,1,1,3,3,2], k = 3\n    Output: 2\n    Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n\u00a0\n    Constraints:\n\n    1 <= arr.length\u00a0<= 10^5\n    1 <= arr[i] <= 10^9\n    0 <= k\u00a0<= arr.length\n    \"\"\"\n", "canonical_solution": "    import heapq\n    from collections import Counter\n    freq_map = Counter(arr)\n    min_heap = list(freq_map.values())\n    heapq.heapify(min_heap)\n\n    while k > 0:\n        k -= heapq.heappop(min_heap)\n\n    return len(min_heap) if k == 0 else len(min_heap) + 1\n\n"}
{"prompt": "from typing import List\n\n\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\n    \"\"\"\n    You are given an integer array bloomDay, an integer m and an integer k.\n    You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\n    The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\n    Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\n\u00a0\n    Example 1:\n\n    Input: bloomDay = [1,10,3,10,2], m = 3, k = 1\n    Output: 3\n    Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\n    We need 3 bouquets each should contain 1 flower.\n    After day 1: [x, _, _, _, _]   // we can only make one bouquet.\n    After day 2: [x, _, _, _, x]   // we can only make two bouquets.\n    After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\n\n    Example 2:\n\n    Input: bloomDay = [1,10,3,10,2], m = 3, k = 2\n    Output: -1\n    Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n\n    Example 3:\n\n    Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n    Output: 12\n    Explanation: We need 2 bouquets each should have 3 flowers.\n    Here is the garden after the 7 and 12 days:\n    After day 7: [x, x, x, x, _, x, x]\n    We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\n    After day 12: [x, x, x, x, x, x, x]\n    It is obvious that we can make two bouquets in different ways.\n\n\u00a0\n    Constraints:\n\n    bloomDay.length == n\n    1 <= n <= 105\n    1 <= bloomDay[i] <= 109\n    1 <= m <= 106\n    1 <= k <= n\n\n    \"\"\"\n", "canonical_solution": "    left, right = min(bloomDay), max(bloomDay)\n\n    while left < right:\n        mid = left + (right - left) // 2\n        bouquets = flowers = 0\n        for day in bloomDay:\n            if day > mid:\n                flowers = 0\n            else:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n\n        if bouquets >= m:\n            right = mid\n        else:\n            left = mid + 1\n\n    return -1 if m == 0 else left\n\n"}
{"prompt": "from typing import List\n\n\ndef get_folder_names(names: List[str]) -> List[str]:\n    \"\"\"\n    Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\n    Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\n    Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\n\u00a0\n    Example 1:\n\n    Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n    Output: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n    Explanation: Let's see how the file system creates folder names:\n    \"pes\" --> not assigned before, remains \"pes\"\n    \"fifa\" --> not assigned before, remains \"fifa\"\n    \"gta\" --> not assigned before, remains \"gta\"\n    \"pes(2019)\" --> not assigned before, remains \"pes(2019)\"\n\n    Example 2:\n\n    Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\n    Output: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\n    Explanation: Let's see how the file system creates folder names:\n    \"gta\" --> not assigned before, remains \"gta\"\n    \"gta(1)\" --> not assigned before, remains \"gta(1)\"\n    \"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n    \"avalon\" --> not assigned before, remains \"avalon\"\n\n    Example 3:\n\n    Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\n    Output: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\n    Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\".\n\n\u00a0\n    Constraints:\n\n    1 <= names.length <= 5 * 104\n    1 <= names[i].length <= 20\n    names[i] consists of lowercase English letters, digits, and/or round brackets.\n\n    \"\"\"\n", "canonical_solution": "    name_count = {}\n    ans = []\n\n    for name in names:\n        if name not in name_count:\n            ans.append(name)\n            name_count[name] = 1\n        else:\n            k = name_count[name]\n            new_name = f\"{name}({k})\"\n            while new_name in name_count:\n                k += 1\n                new_name = f\"{name}({k})\"\n            ans.append(new_name)\n            name_count[new_name] = 1\n            name_count[name] = k + 1\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef range_sum(nums: List[int], n: int, left: int, right: int) -> int:\n    \"\"\"\n    You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\n    Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3,4], n = 4, left = 1, right = 5\n    Output: 13 \n    Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n\n    Example 2:\n\n    Input: nums = [1,2,3,4], n = 4, left = 3, right = 4\n    Output: 6\n    Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n\n    Example 3:\n\n    Input: nums = [1,2,3,4], n = 4, left = 1, right = 10\n    Output: 50\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= nums.length <= 1000\n    1 <= nums[i] <= 100\n    1 <= left <= right <= n * (n + 1) / 2\n\n    \"\"\"\n", "canonical_solution": "    MOD = 10**9 + 7\n    sums = []\n    for i in range(n):\n        sum = 0\n        for j in range(i, n):\n            sum += nums[j]\n            sums.append(sum)\n    sums.sort()\n    result = 0\n    for i in range(left-1, right):\n        result = (result + sums[i]) % MOD\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef min_difference(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums.\n    In one move, you can choose one element of nums and change it to any value.\n    Return the minimum difference between the largest and smallest value of nums after performing at most three moves.\n\u00a0\n    Example 1:\n\n    Input: nums = [5,3,2,4]\n    Output: 0\n    Explanation: We can make at most 3 moves.\n    In the first move, change 2 to 3. nums becomes [5,3,3,4].\n    In the second move, change 4 to 3. nums becomes [5,3,3,3].\n    In the third move, change 5 to 3. nums becomes [3,3,3,3].\n    After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n    Example 2:\n\n    Input: nums = [1,5,0,10,14]\n    Output: 1\n    Explanation: We can make at most 3 moves.\n    In the first move, change 5 to 0. nums becomes [1,0,0,10,14].\n    In the second move, change 10 to 0. nums becomes [1,0,0,0,14].\n    In the third move, change 14 to 1. nums becomes [1,0,0,0,1].\n    After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.\n    It can be shown that there is no way to make the difference 0 in 3 moves.\n    Example 3:\n\n    Input: nums = [3,100,20]\n    Output: 0\n    Explanation: We can make at most 3 moves.\n    In the first move, change 100 to 7. nums becomes [3,7,20].\n    In the second move, change 20 to 7. nums becomes [3,7,7].\n    In the third move, change 3 to 7. nums becomes [7,7,7].\n    After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    size = len(nums)\n    if size < 5:\n        return 0\n\n    nums.sort()\n\n    return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])\n\n"}
{"prompt": "def findLexSmallestString(s: str, a: int, b: int) -> str:\n    \"\"\"\n    You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.\n    You can apply either of the following two operations any number of times and in any order on s:\n\n    Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = \"3456\" and a = 5, s becomes \"3951\".\n    Rotate s to the right by b positions. For example, if s = \"3456\" and b = 1, s becomes \"6345\".\n\n    Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.\n    A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"0158\" is lexicographically smaller than \"0190\" because the first position they differ is at the third letter, and '5' comes before '9'.\n\u00a0\n    Example 1:\n\n    Input: s = \"5525\", a = 9, b = 2\n    Output: \"2050\"\n    Explanation: We can apply the following operations:\n    Start:  \"5525\"\n    Rotate: \"2555\"\n    Add:    \"2454\"\n    Add:    \"2353\"\n    Rotate: \"5323\"\n    Add:    \"5222\"\n    Add:    \"5121\"\n    Rotate: \"2151\"\n    Add:    \"2050\"\u200b\u200b\u200b\u200b\u200b\n    There is no way to obtain a string that is lexicographically smaller than \"2050\".\n\n    Example 2:\n\n    Input: s = \"74\", a = 5, b = 1\n    Output: \"24\"\n    Explanation: We can apply the following operations:\n    Start:  \"74\"\n    Rotate: \"47\"\n    \u200b\u200b\u200b\u200b\u200b\u200b\u200bAdd:    \"42\"\n    \u200b\u200b\u200b\u200b\u200b\u200b\u200bRotate: \"24\"\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\n    There is no way to obtain a string that is lexicographically smaller than \"24\".\n\n    Example 3:\n\n    Input: s = \"0011\", a = 4, b = 2\n    Output: \"0011\"\n    Explanation: There are no sequence of operations that will give us a lexicographically smaller string than \"0011\".\n\n\u00a0\n    Constraints:\n\n    2 <= s.length <= 100\n    s.length is even.\n    s consists of digits from 0 to 9 only.\n    1 <= a <= 9\n    1 <= b <= s.length - 1\n\n    \"\"\"\n", "canonical_solution": "    def add_odd(s: str, a: int) -> str:\n        return ''.join([str((int(ch) + a) % 10) if idx % 2 else ch for idx, ch in enumerate(s)])\n\n    def rotate(s: str, k: int) -> str:\n        k %= len(s)\n        return s[-k:] + s[:-k]\n\n    smallest = s\n    for _ in range(len(s)):\n        for _ in range(10):\n            rotated = rotate(s, b)\n            temp = add_odd(rotated, a)\n            smallest = min(smallest, temp)\n            s = rotated\n        s = add_odd(s, a)\n    return smallest\n\n"}
{"prompt": "from typing import List\n\n\ndef numSubmat(mat: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n binary matrix mat, return the number of submatrices that have all ones.\n\u00a0\n    Example 1:\n\n\n    Input: mat = [[1,0,1],[1,1,0],[1,1,0]]\n    Output: 13\n    Explanation: \n    There are 6 rectangles of side 1x1.\n    There are 2 rectangles of side 1x2.\n    There are 3 rectangles of side 2x1.\n    There is 1 rectangle of side 2x2. \n    There is 1 rectangle of side 3x1.\n    Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n\n    Example 2:\n\n\n    Input: mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n    Output: 24\n    Explanation: \n    There are 8 rectangles of side 1x1.\n    There are 5 rectangles of side 1x2.\n    There are 2 rectangles of side 1x3. \n    There are 4 rectangles of side 2x1.\n    There are 2 rectangles of side 2x2. \n    There are 2 rectangles of side 3x1. \n    There is 1 rectangle of side 3x2. \n    Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n\n\u00a0\n    Constraints:\n\n    1 <= m, n <= 150\n    mat[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                dp[i][j] = (1 if j == 0 else dp[i][j - 1] + 1)\n                minWidth = dp[i][j]\n                for k in range(i, -1, -1):\n                    minWidth = min(minWidth, dp[k][j])\n                    count += minWidth\n\n    return count\n\n"}
{"prompt": "def numSplits(s: str) -> int:\n    \"\"\"\n    You are given a string s.\n    A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same.\n    Return the number of good splits you can make in s.\n\u00a0\n    Example 1:\n\n    Input: s = \"aacaba\"\n    Output: 2\n    Explanation: There are 5 ways to split \"aacaba\" and 2 of them are good. \n    (\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.\n    (\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.\n    (\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n    (\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n    (\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.\n\n    Example 2:\n\n    Input: s = \"abcd\"\n    Output: 1\n    Explanation: Split the string as follows (\"ab\", \"cd\").\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    left_set, right_set = set(), set()\n    left, right = [0] * len(s), [0] * len(s)\n    count = 0\n\n    for i, char in enumerate(s):\n        left_set.add(char)\n        left[i] = len(left_set)\n\n    for i in range(len(s) - 1, 0, -1):\n        right_set.add(s[i])\n        right[i] = len(right_set)\n\n    for i in range(len(s) - 1):\n        if left[i] == right[i + 1]:\n            count += 1\n\n    return count\n\n"}
{"prompt": "def num_sub(s: str) -> int:\n    \"\"\"\n    Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: s = \"0110111\"\n    Output: 9\n    Explanation: There are 9 substring in total with only 1's characters.\n    \"1\" -> 5 times.\n    \"11\" -> 3 times.\n    \"111\" -> 1 time.\n    Example 2:\n\n    Input: s = \"101\"\n    Output: 2\n    Explanation: Substring \"1\" is shown 2 times in s.\n\n    Example 3:\n\n    Input: s = \"111111\"\n    Output: 21\n    Explanation: Each substring contains only 1's characters.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s[i] is either '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    mod = 1000000007\n    result = 0\n    count = 0\n    for c in s:\n        count = count + 1 if c == '1' else 0\n        result = (result + count) % mod\n    return result\n\n"}
{"prompt": "def countVowelStrings(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n    A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: 5\n    Explanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\n\n    Example 2:\n\n    Input: n = 2\n    Output: 15\n    Explanation: The 15 sorted strings that consist of vowels only are\n    [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\n    Note that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet.\n\n    Example 3:\n\n    Input: n = 33\n    Output: 66045\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 50\u00a0\n\n    \"\"\"\n", "canonical_solution": "    dp = [1, 1, 1, 1, 1]\n    for i in range(2, n + 1):\n        for j in range(3, -1, -1):\n            dp[j] = dp[j] + dp[j + 1]\n    return sum(dp)\n\n"}
{"prompt": "from typing import List\n\n\ndef findPeakElement(nums: List[int]) -> int:\n    \"\"\"\n    A peak element is an element that is strictly greater than its neighbors.\n    Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n    You may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n    You must write an algorithm that runs in O(log n) time.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3,1]\n    Output: 2\n    Explanation: 3 is a peak element and your function should return the index number 2.\n    Example 2:\n\n    Input: nums = [1,2,1,3,5,6,4]\n    Output: 5\n    Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    -231 <= nums[i] <= 231 - 1\n    nums[i] != nums[i + 1] for all valid i.\n\n    \"\"\"\n", "canonical_solution": "    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n"}
{"prompt": "from typing import List\n\n\ndef maxNonOverlapping(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1,1,1], target = 2\n    Output: 2\n    Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\n    Example 2:\n\n    Input: nums = [-1,3,5,1,4,2,-9], target = 6\n    Output: 2\n    Explanation: There are 3 subarrays with sum equal to 6.\n    ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n    0 <= target <= 106\n\n    \"\"\"\n", "canonical_solution": "    prefix_sum = {0: 1}\n    sum_so_far = count = 0\n    for num in nums:\n        sum_so_far += num\n        if sum_so_far - target in prefix_sum:\n            count += 1\n            prefix_sum.clear()\n            prefix_sum[0] = 1\n            sum_so_far = 0\n        else:\n            prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef minimumJumps(forbidden: List[int], a: int, b: int, x: int) -> int:\n    \"\"\"\n    A certain bug's home is on the x-axis at position x. Help them get there from position 0.\n    The bug jumps according to the following rules:\n\n    It can jump exactly a positions forward (to the right).\n    It can jump exactly b positions backward (to the left).\n    It cannot jump backward twice in a row.\n    It cannot jump to any forbidden positions.\n\n    The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.\n    Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.\n\u00a0\n    Example 1:\n\n    Input: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n    Output: 3\n    Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\n    Example 2:\n\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n    Output: -1\n\n    Example 3:\n\n    Input: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n    Output: 2\n    Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n\u00a0\n    Constraints:\n\n    1 <= forbidden.length <= 1000\n    1 <= a, b, forbidden[i] <= 2000\n    0 <= x <= 2000\n    All the elements in forbidden are distinct.\n    Position x is not forbidden.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    forbidden_positions = set(forbidden)\n    q = deque([(0, 0, 0)])\n    visited = {(0, 0)}\n    while q:\n        pos, steps, backward = q.popleft()\n        if pos == x:\n            return steps\n        forward_pos = pos + a\n        backward_pos = pos - b\n        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:\n            visited.add((forward_pos, 0))\n            q.append((forward_pos, steps + 1, 0))\n        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:\n            visited.add((backward_pos, 1))\n            q.append((backward_pos, steps + 1, 1))\n    return -1\n\n"}
{"prompt": "from typing import List\n\n\ndef get_winner(arr: List[str], k: int) -> str:\n    \"\"\"\n    Given an integer array arr of distinct integers and an integer k.\n    A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\n    Return the integer which will win the game.\n    It is guaranteed that there will be a winner of the game.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,1,3,5,4,6,7], k = 2\n    Output: 5\n    Explanation: Let's see the rounds of the game:\n    Round |       arr       | winner | win_count\n      1   | [2,1,3,5,4,6,7] | 2      | 1\n      2   | [2,3,5,4,6,7,1] | 3      | 1\n      3   | [3,5,4,6,7,1,2] | 5      | 1\n      4   | [5,4,6,7,1,2,3] | 5      | 2\n    So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n\n    Example 2:\n\n    Input: arr = [3,2,1], k = 10\n    Output: 3\n    Explanation: 3 will win the first 10 rounds consecutively.\n\n\u00a0\n    Constraints:\n\n    2 <= arr.length <= 105\n    1 <= arr[i] <= 106\n    arr contains distinct integers.\n    1 <= k <= 109\n\n    \"\"\"\n", "canonical_solution": "    winner = arr[0]\n    consecutive_wins = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] > winner:\n            winner = arr[i]\n            consecutive_wins = 0\n\n        consecutive_wins += 1\n        if consecutive_wins == k:\n            break\n\n    return winner\n\n"}
{"prompt": "from typing import List\n\n\ndef min_swaps(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.\n    A grid is said to be valid if all the cells above the main diagonal are zeros.\n    Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.\n    The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,1],[1,1,0],[1,0,0]]\n    Output: 3\n\n    Example 2:\n\n\n    Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n    Output: -1\n    Explanation: All rows are similar, swaps have no effect on the grid.\n\n    Example 3:\n\n\n    Input: grid = [[1,0,0],[1,1,0],[1,1,1]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == grid.length == grid[i].length\n    1 <= n <= 200\n    grid[i][j] is either 0 or 1\n\n    \"\"\"\n", "canonical_solution": "    n = len(grid)\n    row_zeros = [0] * n\n\n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n\n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n\n    return steps\n\n"}
{"prompt": "from typing import List\n\n\ndef mostCompetitive(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.\n    An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.\n    We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,5,2,6], k = 2\n    Output: [2,6]\n    Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.\n\n    Example 2:\n\n    Input: nums = [2,4,3,3,5,4,9,6], k = 4\n    Output: [2,3,3,4]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    0 <= nums[i] <= 109\n    1 <= k <= nums.length\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    stack = deque()\n    n = len(nums)\n    for i in range(n):\n        while stack and stack[-1] > nums[i] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n    return list(stack)\n\n"}
{"prompt": "def num_ways(s: str) -> int:\n    \"\"\"\n    Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\n    Return the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: s = \"10101\"\n    Output: 4\n    Explanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n    \"1|010|1\"\n    \"1|01|01\"\n    \"10|10|1\"\n    \"10|1|01\"\n\n    Example 2:\n\n    Input: s = \"1001\"\n    Output: 0\n\n    Example 3:\n\n    Input: s = \"0000\"\n    Output: 3\n    Explanation: There are three ways to split s in 3 parts.\n    \"0|0|00\"\n    \"0|00|0\"\n    \"00|0|0\"\n\n\u00a0\n    Constraints:\n\n    3 <= s.length <= 105\n    s[i] is either '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    number_of_ones = s.count('1')\n    if number_of_ones % 3 != 0:\n        return 0\n\n    target = number_of_ones // 3\n    if target == 0:\n        n = len(s)\n        return ((n - 1) * (n - 2) // 2) % 1000000007\n\n    ones_so_far1, ones_so_far2 = 0, 0\n    way1, way2 = 0, 0\n    for c in s:\n        if c == '1':\n            ones_so_far1 += 1\n            if ones_so_far1 == target:\n                way1 += 1\n                ones_so_far1 = 0\n\n            ones_so_far2 += 1\n            if ones_so_far2 == target * 2:\n                way2 += 1\n                ones_so_far2 = 0\n\n    return (way1 * way2) % 1000000007\n\n"}
{"prompt": "from typing import List\n\n\ndef findLengthOfShortestSubarray(arr: List[int]) -> int:\n    \"\"\"\n    Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\n    Return the length of the shortest subarray to remove.\n    A subarray is a contiguous subsequence of the array.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2,3,10,4,2,3,5]\n    Output: 3\n    Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\n    Another correct solution is to remove the subarray [3,10,4].\n\n    Example 2:\n\n    Input: arr = [5,4,3,2,1]\n    Output: 4\n    Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].\n\n    Example 3:\n\n    Input: arr = [1,2,3]\n    Output: 0\n    Explanation: The array is already non-decreasing. We do not need to remove any elements.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    0 <= arr[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    left, right = 0, n - 1\n\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n\n    if left == n - 1:\n        return 0\n\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n\n    result = min(right, n - left - 1)\n\n    i, j = 0, right\n\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef find_latest_step(arr: List[int], m: int) -> int:\n    \"\"\"\n    Given an array arr that represents a permutation of numbers from 1 to n.\n    You have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.\n    You are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.\n    Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.\n\u00a0\n    Example 1:\n\n    Input: arr = [3,5,1,2,4], m = 1\n    Output: 4\n    Explanation: \n    Step 1: \"00100\", groups: [\"1\"]\n    Step 2: \"00101\", groups: [\"1\", \"1\"]\n    Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\n    Step 4: \"11101\", groups: [\"111\", \"1\"]\n    Step 5: \"11111\", groups: [\"11111\"]\n    The latest step at which there exists a group of size 1 is step 4.\n\n    Example 2:\n\n    Input: arr = [3,1,5,4,2], m = 2\n    Output: -1\n    Explanation: \n    Step 1: \"00100\", groups: [\"1\"]\n    Step 2: \"10100\", groups: [\"1\", \"1\"]\n    Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\n    Step 4: \"10111\", groups: [\"1\", \"111\"]\n    Step 5: \"11111\", groups: [\"11111\"]\n    No group of size 2 exists during any step.\n\n\u00a0\n    Constraints:\n\n    n == arr.length\n    1 <= m <= n <= 105\n    1 <= arr[i] <= n\n    All integers in arr are distinct.\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    length_left, length_right = [0] * (n + 2), [0] * (n + 2)\n    count, result = 0, -1\n\n    for i, pos in enumerate(arr):\n        left_length = length_right[pos - 1]\n        right_length = length_left[pos + 1]\n        new_length = left_length + right_length + 1\n\n        if left_length == m or right_length == m:\n            count -= 1\n\n        if new_length == m:\n            count += 1\n\n        if new_length > 0:\n            length_left[pos - left_length] = new_length\n            length_right[pos + right_length] = new_length\n            result = i + 1\n\n    return result if count > 0 else -1\n\n"}
{"prompt": "def compare_version(version1: str, version2: str) -> int:\n    \"\"\"\n    Given two version numbers,\u00a0version1 and version2, compare them.\n\n\n    Version numbers consist of one or more revisions joined by a dot\u00a0'.'. Each revision\u00a0consists of digits\u00a0and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example\u00a02.5.33\u00a0and\u00a00.1\u00a0are valid version numbers.\n    To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their\u00a0integer value ignoring any leading zeros. This means that revisions\u00a01\u00a0and\u00a0001\u00a0are considered\u00a0equal. If a version number does not specify a revision at an index, then\u00a0treat the revision as\u00a00. For example, version\u00a01.0 is less than version\u00a01.1\u00a0because their revision 0s are the same, but their revision 1s are\u00a00\u00a0and\u00a01\u00a0respectively, and\u00a00 < 1.\n    Return the following:\n\n    If version1 < version2, return -1.\n    If version1 > version2, return 1.\n    Otherwise, return 0.\n\n\u00a0\n    Example 1:\n\n    Input: version1 = \"1.01\", version2 = \"1.001\"\n    Output: 0\n    Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\n\n    Example 2:\n\n    Input: version1 = \"1.0\", version2 = \"1.0.0\"\n    Output: 0\n    Explanation: version1 does not specify revision 2, which means it is treated as \"0\".\n\n    Example 3:\n\n    Input: version1 = \"0.1\", version2 = \"1.1\"\n    Output: -1\n    Explanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2.\n\n\u00a0\n    Constraints:\n\n    1 <= version1.length, version2.length <= 500\n    version1 and version2\u00a0only contain digits and '.'.\n    version1 and version2\u00a0are valid version numbers.\n    All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit integer.\n\n    \"\"\"\n", "canonical_solution": "    v1 = version1.split('.')\n    v2 = version2.split('.')\n\n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n\n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n\n"}
{"prompt": "from typing import List\n\n\ndef stoneGameVI(aliceValues: List[int], bobValues: List[int]) -> int:\n    \"\"\"\n    Alice and Bob take turns playing a game, with Alice starting first.\n    There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\n    You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\n    The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\n    Determine the result of the game, and:\n\n    If Alice wins, return 1.\n    If Bob wins, return -1.\n    If the game results in a draw, return 0.\n\n\u00a0\n    Example 1:\n\n    Input: aliceValues = [1,3], bobValues = [2,1]\n    Output: 1\n    Explanation:\n    If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\n    Bob can only choose stone 0, and will only receive 2 points.\n    Alice wins.\n\n    Example 2:\n\n    Input: aliceValues = [1,2], bobValues = [3,1]\n    Output: 0\n    Explanation:\n    If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\n    Draw.\n\n    Example 3:\n\n    Input: aliceValues = [2,4,3], bobValues = [1,6,7]\n    Output: -1\n    Explanation:\n    Regardless of how Alice plays, Bob will be able to have more points than Alice.\n    For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\n    Bob wins.\n\n\u00a0\n    Constraints:\n\n    n == aliceValues.length == bobValues.length\n    1 <= n <= 105\n    1 <= aliceValues[i], bobValues[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n\n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)\n\n"}
{"prompt": "from typing import List\n\n\ndef getMaxLen(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.\n    A subarray of an array is a consecutive sequence of zero or more values taken out of that array.\n    Return the maximum length of a subarray with positive product.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-2,-3,4]\n    Output: 4\n    Explanation: The array nums already has a positive product of 24.\n\n    Example 2:\n\n    Input: nums = [0,1,-2,-3,-4]\n    Output: 3\n    Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\n    Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n    Example 3:\n\n    Input: nums = [-1,-2,-3,0,1]\n    Output: 2\n    Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    maxLength = currentLen = currentNegLen = 0\n\n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n\n    return maxLength\n\n"}
{"prompt": "from typing import List\n\n\ndef min_subarray(nums: List[int], p: int) -> int:\n    \"\"\"\n    Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.\n    Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.\n    A subarray is defined as a contiguous block of elements in the array.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,1,4,2], p = 6\n    Output: 1\n    Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.\n\n    Example 2:\n\n    Input: nums = [6,3,5,2], p = 9\n    Output: 2\n    Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.\n\n    Example 3:\n\n    Input: nums = [1,2,3], p = 3\n    Output: 0\n    Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n    1 <= p <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    need, cur, res = 0, 0, n\n    last_seen = {}\n\n    for num in nums:\n        need = (need + num) % p\n\n    if need == 0:\n        return 0\n\n    last_seen[cur] = -1\n    for i, num in enumerate(nums):\n        cur = (cur + num) % p\n        last_seen[cur] = i\n        want = (cur - need + p) % p\n        if want in last_seen:\n            res = min(res, i - last_seen[want])\n\n    return res if res != n else -1\n\n"}
{"prompt": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    \"\"\"\n    Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n    If the fractional part is repeating, enclose the repeating part in parentheses.\n    If multiple answers are possible, return any of them.\n    It is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\u00a0\n    Example 1:\n\n    Input: numerator = 1, denominator = 2\n    Output: \"0.5\"\n\n    Example 2:\n\n    Input: numerator = 2, denominator = 1\n    Output: \"2\"\n\n    Example 3:\n\n    Input: numerator = 4, denominator = 333\n    Output: \"0.(012)\"\n\n\u00a0\n    Constraints:\n\n    -231 <=\u00a0numerator, denominator <= 231 - 1\n    denominator != 0\n\n    \"\"\"\n", "canonical_solution": "    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)\n\n"}
{"prompt": "def maximum_binary_string(binary: str) -> str:\n    \"\"\"\n    You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times:\n\n    Operation 1: If the number contains the substring \"00\", you can replace it with \"10\".\n\n\n    For example, \"00010\" -> \"10010\"\n\n\n    Operation 2: If the number contains the substring \"10\", you can replace it with \"01\".\n\n    For example, \"00010\" -> \"00001\"\n\n\n\n    Return the maximum binary string you can obtain after any number of operations. Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.\n\u00a0\n    Example 1:\n\n    Input: binary = \"000110\"\n    Output: \"111011\"\n    Explanation: A valid transformation sequence can be:\n    \"000110\" -> \"000101\" \n    \"000101\" -> \"100101\" \n    \"100101\" -> \"110101\" \n    \"110101\" -> \"110011\" \n    \"110011\" -> \"111011\"\n\n    Example 2:\n\n    Input: binary = \"01\"\n    Output: \"01\"\n    Explanation:\u00a0\"01\" cannot be transformed any further.\n\n\u00a0\n    Constraints:\n\n    1 <= binary.length <= 105\n    binary consist of '0' and '1'.\n\n    \"\"\"\n", "canonical_solution": "    zero_count = binary.count('0')\n\n    if zero_count <= 1:\n        return binary\n\n    one_count = len(binary) - zero_count\n\n    result = \"1\" * one_count + \"0\" * (zero_count - 1) + \"1####1\"\n    return result[:len(binary)]\n\n"}
{"prompt": "from typing import List\n\n\ndef minCostConnectPoints(points: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\n    The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\n    Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n\u00a0\n    Example 1:\n\n\n    Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n    Output: 20\n    Explanation: \n\n    We can connect the points as shown above to get the minimum cost of 20.\n    Notice that there is a unique path between every pair of points.\n\n    Example 2:\n\n    Input: points = [[3,12],[-2,5],[-4,1]]\n    Output: 18\n\n\u00a0\n    Constraints:\n\n    1 <= points.length <= 1000\n    -106 <= xi, yi <= 106\n    All pairs (xi, yi) are distinct.\n\n    \"\"\"\n", "canonical_solution": "    n = len(points)\n    cost = [float('inf')] * n\n    visited = [False] * n\n    cost[0] = 0\n\n    ans = 0\n\n    for _ in range(n):\n        min_cost = float('inf')\n        cur_point = -1\n        for j in range(n):\n            if not visited[j] and cost[j] < min_cost:\n                min_cost = cost[j]\n                cur_point = j\n\n        visited[cur_point] = True\n        ans += min_cost\n\n        for j in range(n):\n            if not visited[j]:\n                new_cost = abs(points[cur_point][0] - points[j][0]) + abs(points[cur_point][1] - points[j][1])\n                cost[j] = min(cost[j], new_cost)\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef restoreMatrix(rowSum: List[int], colSum: List[int]) -> List[List[int]]:\n    \"\"\"\n    You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\n    Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\n    Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.\n\u00a0\n    Example 1:\n\n    Input: rowSum = [3,8], colSum = [4,7]\n    Output: [[3,0],\n             [1,7]]\n    Explanation: \n    0th row: 3 + 0 = 3 == rowSum[0]\n    1st row: 1 + 7 = 8 == rowSum[1]\n    0th column: 3 + 1 = 4 == colSum[0]\n    1st column: 0 + 7 = 7 == colSum[1]\n    The row and column sums match, and all matrix elements are non-negative.\n    Another possible matrix is: [[1,2],\n                                 [3,5]]\n\n    Example 2:\n\n    Input: rowSum = [5,7,10], colSum = [8,6,8]\n    Output: [[0,5,0],\n             [6,1,0],\n             [2,0,8]]\n\n\u00a0\n    Constraints:\n\n    1 <= rowSum.length, colSum.length <= 500\n    0 <= rowSum[i], colSum[i] <= 108\n    sum(rowSum) == sum(colSum)\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(rowSum), len(colSum)\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            value = min(rowSum[i], colSum[j])\n            result[i][j] = value\n            rowSum[i] -= value\n            colSum[j] -= value\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef waysToSplit(nums: List[int]) -> int:\n    \"\"\"\n    A split of an integer array is good if:\n\n    The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.\n    The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.\n\n    Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1]\n    Output: 1\n    Explanation: The only good way to split nums is [1] [1] [1].\n    Example 2:\n\n    Input: nums = [1,2,2,2,5,0]\n    Output: 3\n    Explanation: There are three good ways of splitting nums:\n    [1] [2] [2,2,5,0]\n    [1] [2,2] [2,5,0]\n    [1,2] [2,2] [5,0]\n\n    Example 3:\n\n    Input: nums = [3,2,1]\n    Output: 0\n    Explanation: There is no good way to split nums.\n\u00a0\n    Constraints:\n\n    3 <= nums.length <= 105\n    0 <= nums[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    MOD = 10**9 + 7\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + nums[i]\n\n    ans = 0\n    left, right = 0, 0\n    for mid in range(1, n - 1):\n        while left + 1 < mid and prefixSum[left + 1] * 2 <= prefixSum[mid]:\n            left += 1\n        while right < mid or (right + 1 < n and prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1]):\n            right += 1\n        if right >= mid and prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]:\n            ans = (ans + right - mid + 1) % MOD\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef maxProductPath(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given a m x n matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.\n    Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (m - 1, n - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.\n    Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative, return -1.\n    Notice that the modulo is performed after getting the maximum product.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n    Output: -1\n    Explanation: It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.\n\n    Example 2:\n\n\n    Input: grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n    Output: 8\n    Explanation: Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).\n\n    Example 3:\n\n\n    Input: grid = [[1,3],[0,-4]]\n    Output: 0\n    Explanation: Maximum non-negative product is shown (1 * 0 * -4 = 0).\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 15\n    -4 <= grid[i][j] <= 4\n\n    \"\"\"\n", "canonical_solution": "    m, n, mod = len(grid), len(grid[0]), int(1e9 + 7)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n\n    dp[0][0] = [grid[0][0], grid[0][0]]\n\n    for i in range(1, m):\n        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]]\n    for j in range(1, n):\n        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] < 0:\n                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n            else:\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]\n                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]\n\n    return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef min_operations_max_profit(customers: List[int], boarding_cost: int, running_cost: int) -> int:\n    \"\"\"\n    You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\n    You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\n    You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\n    Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\n\u00a0\n    Example 1:\n\n\n    Input: customers = [8,3], boardingCost = 5, runningCost = 6\n    Output: 3\n    Explanation: The numbers written on the gondolas are the number of people currently there.\n    1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n    2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n    3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\n    The highest profit was $37 after rotating the wheel 3 times.\n\n    Example 2:\n\n    Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\n    Output: 7\n    Explanation:\n    1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n    2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n    3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n    4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n    5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n    6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n    7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\n    The highest profit was $122 after rotating the wheel 7 times.\n\n    Example 3:\n\n    Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n    Output: -1\n    Explanation:\n    1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n    2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n    3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n    4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n    5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\n    The profit was never positive, so return -1.\n\n\u00a0\n    Constraints:\n\n    n == customers.length\n    1 <= n <= 105\n    0 <= customers[i] <= 50\n    1 <= boardingCost, runningCost <= 100\n\n    \"\"\"\n", "canonical_solution": "    rotations = waiting = on_board = profit = max_profit = max_rotations = 0\n    while customers or waiting > 0:\n        if customers:\n            waiting += customers.pop(0)\n\n        on_board = min(waiting, 4)\n        waiting -= on_board\n        profit += on_board * boarding_cost - running_cost\n        rotations += 1\n\n        if profit > max_profit:\n            max_profit = profit\n            max_rotations = rotations\n\n    return max_rotations if max_profit > 0 else -1\n\n"}
{"prompt": "def numberOfSets(n: int, k: int) -> int:\n    \"\"\"\n    Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, find the number of ways we can draw exactly k non-overlapping line segments such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. The k line segments do not have to cover all n points, and they are allowed to share endpoints.\n    Return the number of ways we can draw k non-overlapping line segments. Since this number can be huge, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, k = 2\n    Output: 5\n    Explanation: The two line segments are shown in red and blue.\n    The image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n\n    Example 2:\n\n    Input: n = 3, k = 1\n    Output: 3\n    Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n\n    Example 3:\n\n    Input: n = 30, k = 7\n    Output: 796297179\n    Explanation: The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 1000\n    1 <= k <= n-1\n\n    \"\"\"\n", "canonical_solution": "    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    presum = [1] * n\n\n    for j in range(1, k + 1):\n        for i in range(n):\n            dp[i][j] = presum[i]\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= mod\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod\n\n    return dp[n - 1][k]\n\n"}
{"prompt": "from typing import List\n\n\ndef best_coordinate(towers: List[List[int]], radius: int) -> List[int]:\n    \"\"\"\n    You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance.\n    You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable.\n    The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula \u230aqi / (1 + d)\u230b, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.\n    Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate.\n    Note:\n\n    A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either:\n\n\n    x1 < x2, or\n    x1 == x2 and y1 < y2.\n\n\n    \u230aval\u230b is the greatest integer less than or equal to val (the floor function).\n\n\u00a0\n    Example 1:\n\n\n    Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n    Output: [2,1]\n    Explanation: At coordinate (2, 1) the total quality is 13.\n    - Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n    - Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n    - Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\n    No other coordinate has a higher network quality.\n    Example 2:\n\n    Input: towers = [[23,11,21]], radius = 9\n    Output: [23,11]\n    Explanation: Since there is only one tower, the network quality is highest right at the tower's location.\n\n    Example 3:\n\n    Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n    Output: [1,2]\n    Explanation: Coordinate (1, 2) has the highest network quality.\n\n\u00a0\n    Constraints:\n\n    1 <= towers.length <= 50\n    towers[i].length == 3\n    0 <= xi, yi, qi <= 50\n    1 <= radius <= 50\n\n    \"\"\"\n", "canonical_solution": "    from math import sqrt\n    max_quality = 0\n    best_x, best_y = 0, 0\n\n    for x in range(51):\n        for y in range(51):\n            sum_quality = 0\n            for tower in towers:\n                dist = sqrt((x - tower[0])**2 + (y - tower[1])**2)\n                if dist <= radius:\n                    sum_quality += tower[2] // (1 + dist)\n            if sum_quality > max_quality:\n                max_quality = sum_quality\n                best_x, best_y = x, y\n\n    return [best_x, best_y]\n\n"}
{"prompt": "from typing import List\n\n\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -> int:\n    \"\"\"\n    There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.\n    The network rank of two different cities is defined as the total number of\u00a0directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.\n    The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.\n    Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n    Output: 4\n    Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.\n\n    Example 2:\n\n\n    Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n    Output: 5\n    Explanation: There are 5 roads that are connected to cities 1 or 2.\n\n    Example 3:\n\n    Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n    Output: 5\n    Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 100\n    0 <= roads.length <= n * (n - 1) / 2\n    roads[i].length == 2\n    0 <= ai, bi\u00a0<= n-1\n    ai\u00a0!=\u00a0bi\n    Each\u00a0pair of cities has at most one road connecting them.\n\n    \"\"\"\n", "canonical_solution": "    degree = [0] * n\n    s = set()\n\n    for road in roads:\n        degree[road[0]] += 1\n        degree[road[1]] += 1\n        s.add(tuple(sorted(road)))\n\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0))\n    return ans\n\n"}
{"prompt": "def check_palindrome_formation(a: str, b: str) -> bool:\n    \"\"\"\n    You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome.\n    When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s = \"abc\", then \"\" + \"abc\", \"a\" + \"bc\", \"ab\" + \"c\" , and \"abc\" + \"\" are valid splits.\n    Return true if it is possible to form a palindrome string, otherwise return false.\n    Notice that\u00a0x + y denotes the concatenation of strings x and y.\n\u00a0\n    Example 1:\n\n    Input: a = \"x\", b = \"y\"\n    Output: true\n    Explaination: If either a or b are palindromes the answer is true since you can split in the following way:\n    aprefix = \"\", asuffix = \"x\"\n    bprefix = \"\", bsuffix = \"y\"\n    Then, aprefix + bsuffix = \"\" + \"y\" = \"y\", which is a palindrome.\n\n    Example 2:\n\n    Input: a = \"xbdef\", b = \"xecab\"\n    Output: false\n\n    Example 3:\n\n    Input: a = \"ulacfd\", b = \"jizalu\"\n    Output: true\n    Explaination: Split them at index 3:\n    aprefix = \"ula\", asuffix = \"cfd\"\n    bprefix = \"jiz\", bsuffix = \"alu\"\n    Then, aprefix + bsuffix = \"ula\" + \"alu\" = \"ulaalu\", which is a palindrome.\n\n\u00a0\n    Constraints:\n\n    1 <= a.length, b.length <= 105\n    a.length == b.length\n    a and b consist of lowercase English letters\n\n    \"\"\"\n", "canonical_solution": "    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    i, j = 0, len(a) - 1\n    while i < j:\n        if a[i] != b[j]:\n            return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n        i += 1\n        j -= 1\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef maxWidthOfVerticalArea(points: List[List[int]]) -> int:\n    \"\"\"\n    Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\n    A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\n    Note that points on the edge of a vertical area are not considered included in the area.\n\u00a0\n    Example 1:\n    \u200b\n\n    Input: points = [[8,7],[9,9],[7,4],[9,7]]\n    Output: 1\n    Explanation: Both the red and the blue area are optimal.\n\n    Example 2:\n\n    Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    n == points.length\n    2 <= n <= 105\n    points[i].length == 2\n    0 <= xi, yi\u00a0<= 109\n\n    \"\"\"\n", "canonical_solution": "    xs = sorted([point[0] for point in points])\n    max_width = 0\n    for i in range(1, len(xs)):\n        max_width = max(max_width, xs[i] - xs[i - 1])\n    return max_width\n\n"}
{"prompt": "from typing import List\n\n\ndef bestTeamScore(scores: List[int], ages: List[int]) -> int:\n    \"\"\"\n    You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.\n    However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.\n    Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.\n\u00a0\n    Example 1:\n\n    Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n    Output: 34\n    Explanation:\u00a0You can choose all the players.\n\n    Example 2:\n\n    Input: scores = [4,5,6,5], ages = [2,1,2,1]\n    Output: 16\n    Explanation:\u00a0It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n    Example 3:\n\n    Input: scores = [1,2,3,5], ages = [8,9,10,1]\n    Output: 6\n    Explanation:\u00a0It is best to choose the first 3 players. \n\n\u00a0\n    Constraints:\n\n    1 <= scores.length, ages.length <= 1000\n    scores.length == ages.length\n    1 <= scores[i] <= 106\n    1 <= ages[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    players = sorted(zip(ages, scores))\n    n = len(players)\n    dp = [0] * n\n    best_score = 0\n\n    for i in range(n):\n        dp[i] = players[i][1]\n        for j in range(i):\n            if players[i][1] >= players[j][1]:\n                dp[i] = max(dp[i], dp[j] + players[i][1])\n        best_score = max(best_score, dp[i])\n\n    return best_score\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAbsoluteSum(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).\n    Return the maximum absolute sum of any (possibly empty) subarray of nums.\n    Note that abs(x) is defined as follows:\n\n    If x is a negative integer, then abs(x) = -x.\n    If x is a non-negative integer, then abs(x) = x.\n\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-3,2,3,-4]\n    Output: 5\n    Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.\n\n    Example 2:\n\n    Input: nums = [2,-5,1,-4,3,-2]\n    Output: 8\n    Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    return max(max_sum, -min_sum)\n\n"}
{"prompt": "from typing import List\n\n\ndef check_arithmetic_subarrays(nums: List[int], l: List[int], r: List[int]) -> List[bool]:\n    \"\"\"\n    A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.\n    For example, these are arithmetic sequences:\n\n    1, 3, 5, 7, 9\n    7, 7, 7, 7\n    3, -1, -5, -9\n    The following sequence is not arithmetic:\n\n    1, 1, 2, 5, 7\n    You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.\n    Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]\n    Output: [true,false,true]\n    Explanation:\n    In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\n    In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\n    In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.\n    Example 2:\n\n    Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n    Output: [false,true,false,false,true,true]\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    m == l.length\n    m == r.length\n    2 <= n <= 500\n    1 <= m <= 500\n    0 <= l[i] < r[i] < n\n    -105 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    results = []\n    for i in range(len(l)):\n        subarray = sorted(nums[l[i]:r[i] + 1])\n        is_arithmetic = True\n        diff = subarray[1] - subarray[0]\n        for j in range(1, len(subarray) - 1):\n            if subarray[j + 1] - subarray[j] != diff:\n                is_arithmetic = False\n                break\n        results.append(is_arithmetic)\n    return results\n\n"}
{"prompt": "def min_deletions(s: str) -> int:\n    \"\"\"\n    A string s is called good if there are no two different characters in s that have the same frequency.\n    Given a string s, return the minimum number of characters you need to delete to make s good.\n    The frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1.\n\u00a0\n    Example 1:\n\n    Input: s = \"aab\"\n    Output: 0\n    Explanation: s is already good.\n\n    Example 2:\n\n    Input: s = \"aaabbbcc\"\n    Output: 2\n    Explanation: You can delete two 'b's resulting in the good string \"aaabcc\".\n    Another way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\n    Example 3:\n\n    Input: s = \"ceabaacb\"\n    Output: 2\n    Explanation: You can delete both 'c's resulting in the good string \"eabaab\".\n    Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s\u00a0contains only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    a_count, deletions = 0, 0\n    for c in s:\n        if c == 'a':\n            a_count += 1\n        else:\n            if a_count > 0:\n                a_count -= 1\n            else:\n                deletions += 1\n    return deletions\n\n"}
{"prompt": "def count_homogenous(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.\n    A string is homogenous if all the characters of the string are the same.\n    A substring is a contiguous sequence of characters within a string.\n\u00a0\n    Example 1:\n\n    Input: s = \"abbcccaa\"\n    Output: 13\n    Explanation: The homogenous substrings are listed as below:\n    \"a\"   appears 3 times.\n    \"aa\"  appears 1 time.\n    \"b\"   appears 2 times.\n    \"bb\"  appears 1 time.\n    \"c\"   appears 3 times.\n    \"cc\"  appears 2 times.\n    \"ccc\" appears 1 time.\n    3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.\n    Example 2:\n\n    Input: s = \"xy\"\n    Output: 2\n    Explanation: The homogenous substrings are \"x\" and \"y\".\n    Example 3:\n\n    Input: s = \"zzzzz\"\n    Output: 15\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of lowercase letters.\n    \"\"\"\n", "canonical_solution": "    MOD = 1000000007\n    count, total = 1, 0\n    for i in range(1, len(s)):\n        count = count + 1 if s[i] == s[i - 1] else 1\n        total = (total + count) % MOD\n    return (total + count) % MOD\n\n"}
{"prompt": "def trailing_zeroes(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n    Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\u00a0\n    Example 1:\n\n    Input: n = 3\n    Output: 0\n    Explanation: 3! = 6, no trailing zero.\n\n    Example 2:\n\n    Input: n = 5\n    Output: 1\n    Explanation: 5! = 120, one trailing zero.\n\n    Example 3:\n\n    Input: n = 0\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 104\n\n\u00a0\n    Follow up: Could you write a solution that works in logarithmic time complexity?\n    \"\"\"\n", "canonical_solution": "    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\n"}
{"prompt": "def count_vowel_strings(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n    A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: 5\n    Explanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\n\n    Example 2:\n\n    Input: n = 2\n    Output: 15\n    Explanation: The 15 sorted strings that consist of vowels only are\n    [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\n    Note that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet.\n\n    Example 3:\n\n    Input: n = 33\n    Output: 66045\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 50\u00a0\n\n    \"\"\"\n", "canonical_solution": "    dp = [1, 1, 1, 1, 1]\n\n    for i in range(1, n):\n        for j in range(3, -1, -1):\n            dp[j] += dp[j + 1]\n\n    return sum(dp)\n\n"}
{"prompt": "from typing import List\n\n\ndef furthest_building(heights: List[int], bricks: int, ladders: int) -> int:\n    \"\"\"\n    You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.\n    You start your journey from building 0 and move to the next building by possibly using bricks or ladders.\n    While moving from building i to building i+1 (0-indexed),\n\n    If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.\n    If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.\n\n    Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.\n\u00a0\n    Example 1:\n\n\n    Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n    Output: 4\n    Explanation: Starting at building 0, you can follow these steps:\n    - Go to building 1 without using ladders nor bricks since 4 >= 2.\n    - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n    - Go to building 3 without using ladders nor bricks since 7 >= 6.\n    - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\n    It is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n    Example 2:\n\n    Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n    Output: 7\n\n    Example 3:\n\n    Input: heights = [14,3,19,3], bricks = 17, ladders = 0\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= heights.length <= 105\n    1 <= heights[i] <= 106\n    0 <= bricks <= 109\n    0 <= ladders <= heights.length\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    min_heap = []\n    for i in range(len(heights) - 1):\n        diff = heights[i + 1] - heights[i]\n        if diff > 0:\n            heapq.heappush(min_heap, diff)\n            if len(min_heap) > ladders:\n                bricks -= heapq.heappop(min_heap)\n                if bricks < 0:\n                    return i\n    return len(heights) - 1\n\n"}
{"prompt": "from typing import List\n\n\ndef maxProfit(inventory: List[int], orders: int) -> int:\n    \"\"\"\n    You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.\n    The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color\u00a0you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).\n    You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.\n    Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n\n    Input: inventory = [2,5], orders = 4\n    Output: 14\n    Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\n    The maximum total value is 2 + 5 + 4 + 3 = 14.\n\n    Example 2:\n\n    Input: inventory = [3,5], orders = 6\n    Output: 19\n    Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\n    The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n\u00a0\n    Constraints:\n\n    1 <= inventory.length <= 105\n    1 <= inventory[i] <= 109\n    1 <= orders <= min(sum(inventory[i]), 109)\n\n    \"\"\"\n", "canonical_solution": "    mod = 10**9 + 7\n    inventory.sort(reverse=True)\n    inventory.append(0)\n    n, ans, count = len(inventory), 0, 1\n    for i in range(n - 1):\n        diff = inventory[i] - inventory[i + 1]\n        if count * diff < orders:\n            orders -= count * diff\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod\n        else:\n            q, r = divmod(orders, count)\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod\n            ans = (ans + r * (inventory[i] - q)) % mod\n            break\n        count += 1\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef closest_cost(base_costs: List[int], topping_costs: List[int], target: int) -> int:\n    \"\"\"\n    You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\n    There must be exactly one ice cream base.\n    You can add one or more types of topping or have no toppings at all.\n    There are at most two of each type of topping.\n\n    You are given three inputs:\n\n    baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\n    toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\n    target, an integer representing your target price for dessert.\n\n    You want to make a dessert with a total cost as close to target as possible.\n    Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\u00a0\n    Example 1:\n\n    Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\n    Output: 10\n    Explanation: Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 7\n    - Take 1 of topping 0: cost 1 x 3 = 3\n    - Take 0 of topping 1: cost 0 x 4 = 0\n    Total: 7 + 3 + 0 = 10.\n\n    Example 2:\n\n    Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n    Output: 17\n    Explanation: Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 3\n    - Take 1 of topping 0: cost 1 x 4 = 4\n    - Take 2 of topping 1: cost 2 x 5 = 10\n    - Take 0 of topping 2: cost 0 x 100 = 0\n    Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n\n    Example 3:\n\n    Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\n    Output: 8\n    Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n\n\u00a0\n    Constraints:\n\n    n == baseCosts.length\n    m == toppingCosts.length\n    1 <= n, m <= 10\n    1 <= baseCosts[i], toppingCosts[i] <= 104\n    1 <= target <= 104\n\n    \"\"\"\n", "canonical_solution": "    from itertools import product\n    closest = float('inf')\n    topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs)))\n\n    for base in base_costs:\n        for combination in topping_combinations:\n            combination_cost = sum(x * y for x, y in zip(topping_costs, combination))\n            diff = abs(target - (base + combination_cost))\n            if diff < closest:\n                closest = diff\n            if diff == 0:\n                return target\n\n    return target - closest\n\n"}
{"prompt": "from typing import List\n\n\ndef minOperations(nums: List[int], x: int) -> int:\n    \"\"\"\n    You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\n    Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,4,2,3], x = 5\n    Output: 2\n    Explanation: The optimal solution is to remove the last two elements to reduce x to zero.\n\n    Example 2:\n\n    Input: nums = [5,6,7,8,9], x = 4\n    Output: -1\n\n    Example 3:\n\n    Input: nums = [3,2,20,1,1,3], x = 10\n    Output: 5\n    Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 104\n    1 <= x <= 109\n\n    \"\"\"\n", "canonical_solution": "    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength\n\n"}
{"prompt": "def get_smallest_string(n: int, k: int) -> str:\n    \"\"\"\n    The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\n    The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \"abe\" is equal to 1 + 2 + 5 = 8.\n    You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.\n    Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n\u00a0\n    Example 1:\n\n    Input: n = 3, k = 27\n    Output: \"aay\"\n    Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.\n\n    Example 2:\n\n    Input: n = 5, k = 73\n    Output: \"aaszz\"\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n    n <= k <= 26 * n\n\n    \"\"\"\n", "canonical_solution": "    result = ['a'] * n\n    k -= n\n    idx = n - 1\n    while k > 0:\n        value = min(k, 25)\n        result[idx] = chr(ord(result[idx]) + value)\n        k -= value\n        idx -= 1\n    return ''.join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef largestNumber(nums: List[int]) -> str:\n    \"\"\"\n    Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n    Since the result may be very large, so you need to return a string instead of an integer.\n\u00a0\n    Example 1:\n\n    Input: nums = [10,2]\n    Output: \"210\"\n\n    Example 2:\n\n    Input: nums = [3,30,34,5,9]\n    Output: \"9534330\"\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 100\n    0 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    from functools import cmp_to_key\n\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)\n\n"}
{"prompt": "from typing import List\n\n\ndef minElements(nums: List[int], limit: int, goal: int) -> int:\n    \"\"\"\n    You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit.\n    Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit.\n    Note that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-1,1], limit = 3, goal = -4\n    Output: 2\n    Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n\n    Example 2:\n\n    Input: nums = [1,-10,9,1], limit = 100, goal = 0\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= limit <= 106\n    -limit <= nums[i] <= limit\n    -109 <= goal <= 109\n\n    \"\"\"\n", "canonical_solution": "    sum_nums = sum(nums)\n    diff = abs(goal - sum_nums)\n\n    return (diff + limit - 1) // limit\n\n"}
{"prompt": "from typing import List\n\n\ndef stoneGameVI(aliceValues: List[int], bobValues: List[int]) -> int:\n    \"\"\"\n    Alice and Bob take turns playing a game, with Alice starting first.\n    There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\n    You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\n    The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\n    Determine the result of the game, and:\n\n    If Alice wins, return 1.\n    If Bob wins, return -1.\n    If the game results in a draw, return 0.\n\n\u00a0\n    Example 1:\n\n    Input: aliceValues = [1,3], bobValues = [2,1]\n    Output: 1\n    Explanation:\n    If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\n    Bob can only choose stone 0, and will only receive 2 points.\n    Alice wins.\n\n    Example 2:\n\n    Input: aliceValues = [1,2], bobValues = [3,1]\n    Output: 0\n    Explanation:\n    If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\n    Draw.\n\n    Example 3:\n\n    Input: aliceValues = [2,4,3], bobValues = [1,6,7]\n    Output: -1\n    Explanation:\n    Regardless of how Alice plays, Bob will be able to have more points than Alice.\n    For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\n    Bob wins.\n\n\u00a0\n    Constraints:\n\n    n == aliceValues.length == bobValues.length\n    1 <= n <= 105\n    1 <= aliceValues[i], bobValues[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(aliceValues)\n    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceScore = sum(aliceValues[i] for _, i in sums[::2])\n    bobScore = sum(bobValues[i] for _, i in sums[1::2])\n\n    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef maxOperations(nums: List[int], k: int) -> int:\n    \"\"\"\n    You are given an integer array nums and an integer k.\n    In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.\n    Return the maximum number of operations you can perform on the array.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3,4], k = 5\n    Output: 2\n    Explanation: Starting with nums = [1,2,3,4]:\n    - Remove numbers 1 and 4, then nums = [2,3]\n    - Remove numbers 2 and 3, then nums = []\n    There are no more pairs that sum up to 5, hence a total of 2 operations.\n    Example 2:\n\n    Input: nums = [3,1,3,4,3], k = 6\n    Output: 1\n    Explanation: Starting with nums = [3,1,3,4,3]:\n    - Remove the first two 3's, then nums = [1,4,3]\n    There are no more pairs that sum up to 6, hence a total of 1 operation.\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n    1 <= k <= 109\n\n    \"\"\"\n", "canonical_solution": "    count = {}\n    operations = 0\n\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n\n    return operations\n\n"}
{"prompt": "def concatenated_binary(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: 1\n    Explanation: \"1\" in binary corresponds to the decimal value 1. \n\n    Example 2:\n\n    Input: n = 3\n    Output: 27\n    Explanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\n    After concatenating them, we have \"11011\", which corresponds to the decimal value 27.\n\n    Example 3:\n\n    Input: n = 12\n    Output: 505379714\n    Explanation: The concatenation results in \"1101110010111011110001001101010111100\".\n    The decimal value of that is 118505380540.\n    After modulo 109 + 7, the result is 505379714.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n\n    \"\"\"\n", "canonical_solution": "    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result\n\n"}
{"prompt": "from typing import List, Tuple\n\n\ndef average_waiting_time(customers: List[Tuple[int, int]]) -> float:\n    \"\"\"\n    There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:\n\n    arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.\n    timei is the time needed to prepare the order of the ith customer.\n\n    When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.\n    Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.\n\u00a0\n    Example 1:\n\n    Input: customers = [[1,2],[2,5],[4,3]]\n    Output: 5.00000\n    Explanation:\n    1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n    2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n    3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\n    So the average waiting time = (2 + 6 + 7) / 3 = 5.\n\n    Example 2:\n\n    Input: customers = [[5,2],[5,4],[10,3],[20,1]]\n    Output: 3.25000\n    Explanation:\n    1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n    2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n    3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n    4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\n    So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n\n\u00a0\n    Constraints:\n\n    1 <= customers.length <= 105\n    1 <= arrivali, timei <= 104\n    arrivali\u00a0<= arrivali+1\n\n    \"\"\"\n", "canonical_solution": "    wait_time = 0\n    curr_time = 0\n\n    for arrival, time in customers:\n        curr_time = max(curr_time, arrival) + time\n        wait_time += curr_time - arrival\n\n    return wait_time / len(customers)\n\n"}
{"prompt": "def minPartitions(n: str) -> int:\n    \"\"\"\n    A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\n    Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n\u00a0\n    Example 1:\n\n    Input: n = \"32\"\n    Output: 3\n    Explanation: 10 + 11 + 11 = 32\n\n    Example 2:\n\n    Input: n = \"82734\"\n    Output: 8\n\n    Example 3:\n\n    Input: n = \"27346209830709182346\"\n    Output: 9\n\n\u00a0\n    Constraints:\n\n    1 <= n.length <= 105\n    n consists of only digits.\n    n does not contain any leading zeros and represents a positive integer.\n\n    \"\"\"\n", "canonical_solution": "    max_digit = 0\n    for c in n:\n        max_digit = max(max_digit, int(c))\n        if max_digit == 9:\n            break\n    return max_digit\n\n"}
{"prompt": "from typing import List\n\n\ndef findRepeatedDnaSequences(s: str) -> List[str]:\n    \"\"\"\n    The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\n    For example, \"ACGAATTCCG\" is a DNA sequence.\n\n    When studying DNA, it is useful to identify repeated sequences within the DNA.\n    Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\u00a0\n    Example 1:\n    Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n    Output: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n    Example 2:\n    Input: s = \"AAAAAAAAAAAAA\"\n    Output: [\"AAAAAAAAAA\"]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s[i] is either 'A', 'C', 'G', or 'T'.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    dna_counter = defaultdict(int)\n    result = []\n\n    for i in range(len(s) - 9):\n        sequence = s[i:i + 10]\n        dna_counter[sequence] += 1\n        if dna_counter[sequence] == 2:\n            result.append(sequence)\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maximum_unique_subarray(nums: List[int]) -> int:\n    \"\"\"\n    You are given an array of positive integers nums and want to erase a subarray containing\u00a0unique elements. The score you get by erasing the subarray is equal to the sum of its elements.\n    Return the maximum score you can get by erasing exactly one subarray.\n    An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).\n\u00a0\n    Example 1:\n\n    Input: nums = [4,2,4,5,6]\n    Output: 17\n    Explanation: The optimal subarray here is [2,4,5,6].\n\n    Example 2:\n\n    Input: nums = [5,2,1,2,5,2,1,2,5]\n    Output: 8\n    Explanation: The optimal subarray here is [5,2,1] or [1,2,5].\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    max_sum, current_sum, left = 0, 0, 0\n    elements = set()\n\n    for right in range(len(nums)):\n        while nums[right] in elements:\n            elements.remove(nums[left])\n            current_sum -= nums[left]\n            left += 1\n\n        elements.add(nums[right])\n        current_sum += nums[right]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n"}
{"prompt": "from typing import List\n\n\ndef eatenApples(apples: List[int], days: List[int]) -> int:\n    \"\"\"\n    There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.\n    You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days.\n    Given two integer arrays days and apples of length n, return the maximum number of apples you can eat.\n\u00a0\n    Example 1:\n\n    Input: apples = [1,2,3,5,2], days = [3,2,1,4,2]\n    Output: 7\n    Explanation: You can eat 7 apples:\n    - On the first day, you eat an apple that grew on the first day.\n    - On the second day, you eat an apple that grew on the second day.\n    - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n    - On the fourth to the seventh days, you eat apples that grew on the fourth day.\n\n    Example 2:\n\n    Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n    Output: 5\n    Explanation: You can eat 5 apples:\n    - On the first to the third day you eat apples that grew on the first day.\n    - Do nothing on the fouth and fifth days.\n    - On the sixth and seventh days you eat apples that grew on the sixth day.\n\n\u00a0\n    Constraints:\n\n    n == apples.length == days.length\n    1 <= n <= 2 * 104\n    0 <= apples[i], days[i] <= 2 * 104\n    days[i] = 0 if and only if apples[i] = 0.\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans\n\n"}
{"prompt": "from typing import Union, List\n\n\ndef countPoints(points: List[List[int]], queries: List[List[Union[int, float]]]) -> List[int]:\n    \"\"\"\n    You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\n    You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\n    For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\n    Return an array answer, where answer[j] is the answer to the jth query.\n\u00a0\n    Example 1:\n\n\n    Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n    Output: [3,2,2]\n    Explanation: The points and circles are shown above.\n    queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.\n\n    Example 2:\n\n\n    Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n    Output: [2,3,2,4]\n    Explanation: The points and circles are shown above.\n    queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.\n\n\u00a0\n    Constraints:\n\n    1 <= points.length <= 500\n    points[i].length == 2\n    0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n    1 <= queries.length <= 500\n    queries[j].length == 3\n    0 <= xj, yj <= 500\n    1 <= rj <= 500\n    All coordinates are integers.\n\n\u00a0\n    Follow up: Could you find the answer for each query in better complexity than O(n)?\n    \"\"\"\n", "canonical_solution": "    answer = []\n    for query in queries:\n        inside = 0\n        for point in points:\n            dx = point[0] - query[0]\n            dy = point[1] - query[1]\n            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1\n        answer.append(inside)\n    return answer\n\n"}
{"prompt": "from typing import List\n\n\ndef minimum_teachings(n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:\n    \"\"\"\n    On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.\n    You are given an integer n, an array languages, and an array friendships where:\n\n    There are n languages numbered 1 through n,\n    languages[i] is the set of languages the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b user knows, and\n    friendships[i] = [u\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b, v\u200b\u200b\u200b\u200b\u200b\u200bi] denotes a friendship between the users u\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b\u200b\u200b and vi.\n\n    You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.\n    Note that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.\n\u00a0\n    Example 1:\n\n    Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]\n    Output: 1\n    Explanation: You can either teach user 1 the second language or user 2 the first language.\n\n    Example 2:\n\n    Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]\n    Output: 2\n    Explanation: Teach the third language to users 1 and 3, yielding two users to teach.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 500\n    languages.length == m\n    1 <= m <= 500\n    1 <= languages[i].length <= n\n    1 <= languages[i][j] <= n\n    1 <= u\u200b\u200b\u200b\u200b\u200b\u200bi < v\u200b\u200b\u200b\u200b\u200b\u200bi <= languages.length\n    1 <= friendships.length <= 500\n    All tuples (u\u200b\u200b\u200b\u200b\u200bi, v\u200b\u200b\u200b\u200b\u200b\u200bi) are unique\n    languages[i] contains only unique values\n\n    \"\"\"\n", "canonical_solution": "    language_users = {}\n    unconnected_users = set()\n\n    for u, v in friendships:\n        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])\n        if not can_communicate:\n            unconnected_users.add(u)\n            unconnected_users.add(v)\n\n    res = len(unconnected_users)\n    for i in range(1, n+1):\n        cnt = sum(i not in languages[user-1] for user in unconnected_users)\n        res = min(res, cnt)\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef minimumHammingDistance(source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    \"\"\"\n    You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order.\n    The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).\n    Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.\n\u00a0\n    Example 1:\n\n    Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n    Output: 1\n    Explanation: source can be transformed the following way:\n    - Swap indices 0 and 1: source = [2,1,3,4]\n    - Swap indices 2 and 3: source = [2,1,4,3]\n    The Hamming distance of source and target is 1 as they differ in 1 position: index 3.\n\n    Example 2:\n\n    Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n    Output: 2\n    Explanation: There are no allowed swaps.\n    The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.\n\n    Example 3:\n\n    Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == source.length == target.length\n    1 <= n <= 105\n    1 <= source[i], target[i] <= 105\n    0 <= allowedSwaps.length <= 105\n    allowedSwaps[i].length == 2\n    0 <= ai, bi <= n - 1\n    ai != bi\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n\n    def dfs(node, visited, graph, group):\n        if visited[node]:\n            return\n        visited[node] = 1\n        group.append(node)\n        for neighbor in graph[node]:\n            dfs(neighbor, visited, graph, group)\n    n = len(source)\n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    return n - res\n\n"}
{"prompt": "from typing import List\n\n\ndef largestSubmatrix(matrix: List[List[int]]) -> int:\n    \"\"\"\n    You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.\n    Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.\n\u00a0\n    Example 1:\n\n\n    Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]\n    Output: 4\n    Explanation: You can rearrange the columns as shown above.\n    The largest submatrix of 1s, in bold, has an area of 4.\n\n    Example 2:\n\n\n    Input: matrix = [[1,0,1,0,1]]\n    Output: 3\n    Explanation: You can rearrange the columns as shown above.\n    The largest submatrix of 1s, in bold, has an area of 3.\n\n    Example 3:\n\n    Input: matrix = [[1,1,0],[1,0,1]]\n    Output: 2\n    Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.\n\n\u00a0\n    Constraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m * n <= 105\n    matrix[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(matrix), len(matrix[0])\n    height = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                height[j] += 1\n            else:\n                height[j] = 0\n        sorted_height = sorted(height)\n        for j in range(n):\n            max_area = max(max_area, sorted_height[j] * (n - j))\n\n    return max_area\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAbsoluteSum(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).\n    Return the maximum absolute sum of any (possibly empty) subarray of nums.\n    Note that abs(x) is defined as follows:\n\n    If x is a negative integer, then abs(x) = -x.\n    If x is a non-negative integer, then abs(x) = x.\n\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-3,2,3,-4]\n    Output: 5\n    Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.\n\n    Example 2:\n\n    Input: nums = [2,-5,1,-4,3,-2]\n    Output: 8\n    Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    max_sum, min_sum, max_so_far, min_so_far = 0, 0, 0, 0\n    for num in nums:\n        max_so_far = max(num, max_so_far + num)\n        max_sum = max(max_sum, max_so_far)\n\n        min_so_far = min(num, min_so_far + num)\n        min_sum = min(min_sum, min_so_far)\n    return max(max_sum, abs(min_sum))\n\n"}
{"prompt": "from typing import List\n\n\ndef maxDistance(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    You are given two non-increasing 0-indexed integer arrays nums1\u200b\u200b\u200b\u200b\u200b\u200b and nums2\u200b\u200b\u200b\u200b\u200b\u200b.\n    A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i\u200b\u200b\u200b\u200b.\n    Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.\n    An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.\n\u00a0\n    Example 1:\n\n    Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n    Output: 2\n    Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\n    The maximum distance is 2 with pair (2,4).\n\n    Example 2:\n\n    Input: nums1 = [2,2,2], nums2 = [10,10,1]\n    Output: 1\n    Explanation: The valid pairs are (0,0), (0,1), and (1,1).\n    The maximum distance is 1 with pair (0,1).\n\n    Example 3:\n\n    Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n    Output: 2\n    Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\n    The maximum distance is 2 with pair (2,4).\n\n\u00a0\n    Constraints:\n\n    1 <= nums1.length, nums2.length <= 105\n    1 <= nums1[i], nums2[j] <= 105\n    Both nums1 and nums2 are non-increasing.\n\n    \"\"\"\n", "canonical_solution": "    i, j, maxDist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] > nums2[j]:\n            i += 1\n        else:\n            maxDist = max(maxDist, j - i)\n            j += 1\n    return maxDist\n\n"}
{"prompt": "from typing import List\n\n\ndef threeSum(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n    Notice that the solution set must not contain duplicate triplets.\n\u00a0\n    Example 1:\n\n    Input: nums = [-1,0,1,2,-1,-4]\n    Output: [[-1,-1,2],[-1,0,1]]\n    Explanation: \n    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n    The distinct triplets are [-1,0,1] and [-1,-1,2].\n    Notice that the order of the output and the order of the triplets does not matter.\n\n    Example 2:\n\n    Input: nums = [0,1,1]\n    Output: []\n    Explanation: The only possible triplet does not sum up to 0.\n\n    Example 3:\n\n    Input: nums = [0,0,0]\n    Output: [[0,0,0]]\n    Explanation: The only possible triplet sums up to 0.\n\n\u00a0\n    Constraints:\n\n    3 <= nums.length <= 3000\n    -105 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef kthLargestValue(matrix: List[List[int]], k: int) -> int:\n    \"\"\"\n    You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.\n    The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).\n    Find the kth largest value (1-indexed) of all the coordinates of matrix.\n\u00a0\n    Example 1:\n\n    Input: matrix = [[5,2],[1,6]], k = 1\n    Output: 7\n    Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.\n\n    Example 2:\n\n    Input: matrix = [[5,2],[1,6]], k = 2\n    Output: 5\n    Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.\n\n    Example 3:\n\n    Input: matrix = [[5,2],[1,6]], k = 3\n    Output: 4\n    Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.\n\u00a0\n    Constraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 1000\n    0 <= matrix[i][j] <= 106\n    1 <= k <= m * n\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    m, n = len(matrix), len(matrix[0])\n    prefix_xor = [[0] * (n + 1) for _ in range(m + 1)]\n    pq = []\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1] ^ prefix_xor[i - 1][j - 1]\n            heapq.heappush(pq, prefix_xor[i][j])\n            if len(pq) > k:\n                heapq.heappop(pq)\n    return pq[0]\n\n"}
{"prompt": "from typing import List\n\n\ndef restoreArray(adjacentPairs: List[List[int]]) -> List[int]:\n    \"\"\"\n    There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\n    You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\n    It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\n    Return the original array nums. If there are multiple solutions, return any of them.\n\u00a0\n    Example 1:\n\n    Input: adjacentPairs = [[2,1],[3,4],[3,2]]\n    Output: [1,2,3,4]\n    Explanation: This array has all its adjacent pairs in adjacentPairs.\n    Notice that adjacentPairs[i] may not be in left-to-right order.\n\n    Example 2:\n\n    Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\n    Output: [-2,4,1,-3]\n    Explanation: There can be negative numbers.\n    Another solution is [-3,1,4,-2], which would also be accepted.\n\n    Example 3:\n\n    Input: adjacentPairs = [[100000,-100000]]\n    Output: [100000,-100000]\n\n\u00a0\n    Constraints:\n\n    nums.length == n\n    adjacentPairs.length == n - 1\n    adjacentPairs[i].length == 2\n    2 <= n <= 105\n    -105 <= nums[i], ui, vi <= 105\n    There exists some nums that has adjacentPairs as its pairs.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    graph = defaultdict(list)\n    for pair in adjacentPairs:\n        graph[pair[0]].append(pair[1])\n        graph[pair[1]].append(pair[0])\n\n    n = len(graph)\n    nums = [0] * n\n    for key, nodes in graph.items():\n        if len(nodes) == 1:\n            nums[0] = key\n            break\n\n    nums[1] = graph[nums[0]][0]\n    for i in range(2, n):\n        nums[i] = (graph[nums[i - 1]][1]\n                   if (nums[i - 2] == graph[nums[i - 1]][0])\n                   else graph[nums[i - 1]][0])\n\n    return nums\n\n"}
{"prompt": "from typing import Union, List\n\n\ndef minSpeedOnTime(dist: List[int], hour: Union[int, float]) -> int:\n    \"\"\"\n    You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\n    Each train can only depart at an integer hour, so you may need to wait in between each train ride.\n\n    For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\n    Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\n    Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.\n\u00a0\n    Example 1:\n\n    Input: dist = [1,3,2], hour = 6\n    Output: 1\n    Explanation: At speed 1:\n    - The first train ride takes 1/1 = 1 hour.\n    - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n    - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n    - You will arrive at exactly the 6 hour mark.\n\n    Example 2:\n\n    Input: dist = [1,3,2], hour = 2.7\n    Output: 3\n    Explanation: At speed 3:\n    - The first train ride takes 1/3 = 0.33333 hours.\n    - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n    - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n    - You will arrive at the 2.66667 hour mark.\n\n    Example 3:\n\n    Input: dist = [1,3,2], hour = 1.9\n    Output: -1\n    Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\n\n\u00a0\n    Constraints:\n\n    n == dist.length\n    1 <= n <= 105\n    1 <= dist[i] <= 105\n    1 <= hour <= 109\n    There will be at most two digits after the decimal point in hour.\n\n    \"\"\"\n", "canonical_solution": "    from math import ceil\n    max_time = hour - len(dist) + 1\n    lower, upper = 1.0, 1e7\n    while upper - lower >= 1e-9:\n        mid = (lower + upper) / 2\n        time_taken = sum(ceil(d / mid) - (0 if i == len(dist) - 1 else 1) for i, d in enumerate(dist))\n        if time_taken <= max_time:\n            upper = mid\n        else:\n            lower = mid\n    return ceil(lower) if lower <= 1e7 else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef can_choose(groups: List[List[int]], nums: List[int]) -> bool:\n    \"\"\"\n    You are given a 2D integer array groups of length n. You are also given an integer array nums.\n    You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).\n    Return true if you can do this task, and false otherwise.\n    Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n\u00a0\n    Example 1:\n\n    Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\n    Output: true\n    Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].\n    These subarrays are disjoint as they share no common nums[k] element.\n\n    Example 2:\n\n    Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\n    Output: false\n    Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.\n    [10,-2] must come before [1,2,3,4].\n\n    Example 3:\n\n    Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\n    Output: false\n    Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.\n    They share a common elements nums[4] (0-indexed).\n\n\u00a0\n    Constraints:\n\n    groups.length == n\n    1 <= n <= 103\n    1 <= groups[i].length, sum(groups[i].length) <= 103\n    1 <= nums.length <= 103\n    -107 <= groups[i][j], nums[k] <= 107\n\n    \"\"\"\n", "canonical_solution": "    g_i, n_i = 0, 0\n    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):\n        if nums[n_i: n_i + len(groups[g_i])] == groups[g_i]:\n            n_i += len(groups[g_i])\n            g_i += 1\n        else:\n            n_i += 1\n    return g_i == len(groups)\n\n"}
{"prompt": "from typing import List\n\n\ndef minPairSum(nums: List[int]) -> int:\n    \"\"\"\n    The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\n    For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\n    Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\n    Each element of nums is in exactly one pair, and\n    The maximum pair sum is minimized.\n\n    Return the minimized maximum pair sum after optimally pairing up the elements.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,5,2,3]\n    Output: 7\n    Explanation: The elements can be paired up into pairs (3,3) and (5,2).\n    The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n    Example 2:\n\n    Input: nums = [3,5,4,2,4,6]\n    Output: 8\n    Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\n    The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    2 <= n <= 105\n    n is even.\n    1 <= nums[i] <= 105\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum\n\n"}
{"prompt": "def largest_merge(word1: str, word2: str) -> str:\n    \"\"\"\n    You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options:\n\n    If word1 is non-empty, append the first character in word1 to merge and delete it from word1.\n\n\n    For example, if word1 = \"abc\" and merge = \"dv\", then after choosing this operation, word1 = \"bc\" and merge = \"dva\".\n\n\n    If word2 is non-empty, append the first character in word2 to merge and delete it from word2.\n\n    For example, if word2 = \"abc\" and merge = \"\", then after choosing this operation, word2 = \"bc\" and merge = \"a\".\n\n\n\n    Return the lexicographically largest merge you can construct.\n    A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n\u00a0\n    Example 1:\n\n    Input: word1 = \"cabaa\", word2 = \"bcaaa\"\n    Output: \"cbcabaaaaa\"\n    Explanation: One way to get the lexicographically largest merge is:\n    - Take from word1: merge = \"c\", word1 = \"abaa\", word2 = \"bcaaa\"\n    - Take from word2: merge = \"cb\", word1 = \"abaa\", word2 = \"caaa\"\n    - Take from word2: merge = \"cbc\", word1 = \"abaa\", word2 = \"aaa\"\n    - Take from word1: merge = \"cbca\", word1 = \"baa\", word2 = \"aaa\"\n    - Take from word1: merge = \"cbcab\", word1 = \"aa\", word2 = \"aaa\"\n    - Append the remaining 5 a's from word1 and word2 at the end of merge.\n\n    Example 2:\n\n    Input: word1 = \"abcabc\", word2 = \"abdcaba\"\n    Output: \"abdcabcabcaba\"\n\n\u00a0\n    Constraints:\n\n    1 <= word1.length, word2.length <= 3000\n    word1 and word2 consist only of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)\n\n"}
{"prompt": "from typing import List\n\n\ndef minimumSize(nums: List[int], maxOperations: int) -> int:\n    \"\"\"\n    You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.\n    You can perform the following operation at most maxOperations times:\n\n    Take any bag of balls and divide it into two new bags with a positive number of balls.\n\n\n    For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.\n\n\n\n    Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.\n    Return the minimum possible penalty after performing the operations.\n\u00a0\n    Example 1:\n\n    Input: nums = [9], maxOperations = 2\n    Output: 3\n    Explanation: \n    - Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].\n    - Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].\n    The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n\n    Example 2:\n\n    Input: nums = [2,4,8,2], maxOperations = 4\n    Output: 2\n    Explanation:\n    - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].\n    The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= maxOperations, nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    pq = [-num for num in nums]  # Negative numbers to simulate max heap\n    heapq.heapify(pq)\n    while maxOperations > 0:\n        maxBalls = -heapq.heappop(pq)\n        heapq.heappush(pq, -maxBalls // 2)\n        heapq.heappush(pq, -(maxBalls - (maxBalls // 2)))\n        maxOperations -= 1\n    return -pq[0]\n\n"}
{"prompt": "def check_powers_of_three(n: int) -> bool:\n    \"\"\"\n    Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.\n    An integer y is a power of three if there exists an integer x such that y == 3x.\n\u00a0\n    Example 1:\n\n    Input: n = 12\n    Output: true\n    Explanation: 12 = 31 + 32\n\n    Example 2:\n\n    Input: n = 91\n    Output: true\n    Explanation: 91 = 30 + 32 + 34\n\n    Example 3:\n\n    Input: n = 21\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 107\n\n    \"\"\"\n", "canonical_solution": "    while n > 0:\n        if n % 3 == 2:\n            return False\n        n //= 3\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef numIslands(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\u00a0\n    Example 1:\n\n    Input: grid = [\n      [\"1\",\"1\",\"1\",\"1\",\"0\"],\n      [\"1\",\"1\",\"0\",\"1\",\"0\"],\n      [\"1\",\"1\",\"0\",\"0\",\"0\"],\n      [\"0\",\"0\",\"0\",\"0\",\"0\"]\n    ]\n    Output: 1\n\n    Example 2:\n\n    Input: grid = [\n      [\"1\",\"1\",\"0\",\"0\",\"0\"],\n      [\"1\",\"1\",\"0\",\"0\",\"0\"],\n      [\"0\",\"0\",\"1\",\"0\",\"0\"],\n      [\"0\",\"0\",\"0\",\"1\",\"1\"]\n    ]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 300\n    grid[i][j] is '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n\n        grid[i][j] = '0'\n        dfs(grid, i + 1, j)\n        dfs(grid, i - 1, j)\n        dfs(grid, i, j + 1)\n        dfs(grid, i, j - 1)\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef min_operations(boxes: str) -> List[int]:\n    \"\"\"\n    You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.\n    In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.\n    Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.\n    Each answer[i] is calculated considering the initial state of the boxes.\n\u00a0\n    Example 1:\n\n    Input: boxes = \"110\"\n    Output: [1,1,3]\n    Explanation: The answer for each box is as follows:\n    1) First box: you will have to move one ball from the second box to the first box in one operation.\n    2) Second box: you will have to move one ball from the first box to the second box in one operation.\n    3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\n    Example 2:\n\n    Input: boxes = \"001011\"\n    Output: [11,8,5,4,3,4]\n\u00a0\n    Constraints:\n\n    n == boxes.length\n    1 <= n <= 2000\n    boxes[i] is either '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    result = [0] * len(boxes)\n    count, total = 0, 0\n\n    for i in range(len(boxes)):\n        total += count\n        result[i] = total\n        if boxes[i] == '1':\n            count += 1\n\n    count, total = 0, 0\n    for i in range(len(boxes) - 1, -1, -1):\n        total += count\n        result[i] += total\n        if boxes[i] == '1':\n            count += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef closest_cost(base_costs: List[int], topping_costs: List[int], target: int) -> int:\n    \"\"\"\n    You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\n    There must be exactly one ice cream base.\n    You can add one or more types of topping or have no toppings at all.\n    There are at most two of each type of topping.\n\n    You are given three inputs:\n\n    baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\n    toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\n    target, an integer representing your target price for dessert.\n\n    You want to make a dessert with a total cost as close to target as possible.\n    Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n\u00a0\n    Example 1:\n\n    Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\n    Output: 10\n    Explanation: Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 7\n    - Take 1 of topping 0: cost 1 x 3 = 3\n    - Take 0 of topping 1: cost 0 x 4 = 0\n    Total: 7 + 3 + 0 = 10.\n\n    Example 2:\n\n    Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n    Output: 17\n    Explanation: Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 3\n    - Take 1 of topping 0: cost 1 x 4 = 4\n    - Take 2 of topping 1: cost 2 x 5 = 10\n    - Take 0 of topping 2: cost 0 x 100 = 0\n    Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n\n    Example 3:\n\n    Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\n    Output: 8\n    Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n\n\u00a0\n    Constraints:\n\n    n == baseCosts.length\n    m == toppingCosts.length\n    1 <= n, m <= 10\n    1 <= baseCosts[i], toppingCosts[i] <= 104\n    1 <= target <= 104\n\n    \"\"\"\n", "canonical_solution": "    closest = base_costs[0]\n\n    for base in base_costs:\n        cost = base\n\n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n\n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n\n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n\n            cost = base\n\n    return closest\n\n"}
{"prompt": "from typing import List\n\n\ndef min_elements(nums: List[int], limit: int, goal: int) -> int:\n    \"\"\"\n    You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit.\n    Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit.\n    Note that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-1,1], limit = 3, goal = -4\n    Output: 2\n    Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n\n    Example 2:\n\n    Input: nums = [1,-10,9,1], limit = 100, goal = 0\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= limit <= 106\n    -limit <= nums[i] <= limit\n    -109 <= goal <= 109\n\n    \"\"\"\n", "canonical_solution": "    total_sum = sum(nums)\n    diff = abs(goal - total_sum)\n    return (diff + limit - 1) // limit\n\n"}
{"prompt": "from typing import Optional, List\n\n\ndef rotateGrid(grid: Optional[List[List[int]]], k: int) -> Optional[List[List[int]]]:\n    \"\"\"\n    You are given an m x n integer matrix grid\u200b\u200b\u200b, where m and n are both even integers, and an integer k.\n    The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:\n\n    A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below:\n\n    Return the matrix after applying k cyclic rotations to it.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[40,10],[30,20]], k = 1\n    Output: [[10,20],[40,30]]\n    Explanation: The figures above represent the grid at every state.\n\n    Example 2:\n\n\n    Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n    Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n    Explanation: The figures above represent the grid at every state.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    2 <= m, n <= 50\n    Both m and n are even integers.\n    1 <= grid[i][j] <= 5000\n    1 <= k <= 109\n    \"\"\"\n", "canonical_solution": "    if not grid:\n        return grid\n\n    m, n = len(grid), len(grid[0])\n    numLayers = min(m, n) // 2\n\n    for layer in range(numLayers):\n        numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2\n        effective_k = k % numToRotate\n\n        while effective_k:\n            temp = grid[layer][layer]\n            for i in range(layer + 1, m - layer):\n                temp, grid[i][layer] = grid[i][layer], temp\n            for j in range(layer + 1, n - layer):\n                temp, grid[m - layer - 1][j] = grid[m - layer - 1][j], temp\n            for i in range(m - layer - 2, layer - 1, -1):\n                temp, grid[i][n - layer - 1] = grid[i][n - layer - 1], temp\n            for j in range(n - layer - 2, layer, -1):\n                temp, grid[layer][j] = grid[layer][j], temp\n            effective_k -= 1\n\n    return grid\n\n"}
{"prompt": "from typing import List\n\n\ndef eliminate_maximum(dist: List[int], speed: List[int]) -> int:\n    \"\"\"\n    You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.\n    The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.\n    You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.\n    You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.\n    Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.\n\u00a0\n    Example 1:\n\n    Input: dist = [1,3,4], speed = [1,1,1]\n    Output: 3\n    Explanation:\n    In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\n    After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\n    After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.\n    All 3 monsters can be eliminated.\n    Example 2:\n\n    Input: dist = [1,1,2,3], speed = [1,1,1,1]\n    Output: 1\n    Explanation:\n    In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\n    After a minute, the distances of the monsters are [X,0,1,2], so you lose.\n    You can only eliminate 1 monster.\n\n    Example 3:\n\n    Input: dist = [3,2,4], speed = [5,3,2]\n    Output: 1\n    Explanation:\n    In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\n    After a minute, the distances of the monsters are [X,0,2], so you lose.\n    You can only eliminate 1 monster.\n\n\u00a0\n    Constraints:\n\n    n == dist.length == speed.length\n    1 <= n <= 105\n    1 <= dist[i], speed[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated\n\n"}
{"prompt": "def are_sentences_similar(sentence1: str, sentence2: str) -> bool:\n    \"\"\"\n    A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences. Words consist of only uppercase and lowercase English letters.\n    Two sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. For example, sentence1 = \"Hello my name is Jane\" and sentence2 = \"Hello Jane\" can be made equal by inserting \"my name is\" between \"Hello\" and \"Jane\" in sentence2.\n    Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.\n\u00a0\n    Example 1:\n\n    Input: sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\n    Output: true\n    Explanation: sentence2 can be turned to sentence1 by inserting \"name is\" between \"My\" and \"Haley\".\n\n    Example 2:\n\n    Input: sentence1 = \"of\", sentence2 = \"A lot of words\"\n    Output: false\n    Explanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.\n\n    Example 3:\n\n    Input: sentence1 = \"Eating right now\", sentence2 = \"Eating\"\n    Output: true\n    Explanation: sentence2 can be turned to sentence1 by inserting \"right now\" at the end of the sentence.\n\n\u00a0\n    Constraints:\n\n    1 <= sentence1.length, sentence2.length <= 100\n    sentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.\n    The words in sentence1 and sentence2 are separated by a single space.\n\n    \"\"\"\n", "canonical_solution": "    words1 = sentence1.split()\n    words2 = sentence2.split()\n\n    while words1 and words2 and words1[0] == words2[0]:\n        words1.pop(0)\n        words2.pop(0)\n\n    while words1 and words2 and words1[-1] == words2[-1]:\n        words1.pop()\n        words2.pop()\n\n    return not words1 or not words2\n\n"}
{"prompt": "from typing import List\n\n\ndef count_nice_pairs(nums: List[int]) -> int:\n    \"\"\"\n    You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n\n    0 <= i < j < nums.length\n    nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\n\n    Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nums = [42,11,1,97]\n    Output: 2\n    Explanation: The two pairs are:\n     - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n     - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n\n    Example 2:\n\n    Input: nums = [13,10,35,24,76]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    0 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    def reverse(x):\n        rev = 0\n\n        while x != 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n\n        return rev\n    MOD = 1_000_000_007\n    count = {}\n    result = 0\n\n    for num in nums:\n        diff = num - reverse(num)\n        count[diff] = count.get(diff, 0) + 1\n\n    for val in count.values():\n        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef nearest_exit(maze: List[List[str]], entrance: List[int]) -> int:\n    \"\"\"\n    You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\n    In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\n    Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\n\u00a0\n    Example 1:\n\n\n    Input: maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n    Output: 1\n    Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].\n    Initially, you are at the entrance cell [1,2].\n    - You can reach [1,0] by moving 2 steps left.\n    - You can reach [0,2] by moving 1 step up.\n    It is impossible to reach [2,3] from the entrance.\n    Thus, the nearest exit is [0,2], which is 1 step away.\n\n    Example 2:\n\n\n    Input: maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n    Output: 2\n    Explanation: There is 1 exit in this maze at [1,2].\n    [1,0] does not count as an exit since it is the entrance cell.\n    Initially, you are at the entrance cell [1,0].\n    - You can reach [1,2] by moving 2 steps right.\n    Thus, the nearest exit is [1,2], which is 2 steps away.\n\n    Example 3:\n\n\n    Input: maze = [[\".\",\"+\"]], entrance = [0,0]\n    Output: -1\n    Explanation: There are no exits in this maze.\n\n\u00a0\n    Constraints:\n\n    maze.length == m\n    maze[i].length == n\n    1 <= m, n <= 100\n    maze[i][j] is either '.' or '+'.\n    entrance.length == 2\n    0 <= entrancerow < m\n    0 <= entrancecol < n\n    entrance will always be an empty cell.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    m, n = len(maze), len(maze[0])\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    q = deque([tuple(entrance)])\n\n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            if maze[r][c] == '+':\n                continue\n            if r == 0 or r == m-1 or c == 0 or c == n-1:\n                if r != entrance[0] or c != entrance[1]:\n                    return steps\n            maze[r][c] = '+'\n            for dr, dc in moves:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n:\n                    q.append((nr, nc))\n    return -1\n\n"}
{"prompt": "def countPrimes(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of prime numbers that are strictly less than n.\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 4\n    Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\n    Example 2:\n\n    Input: n = 0\n    Output: 0\n\n    Example 3:\n\n    Input: n = 1\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 5 * 106\n\n    \"\"\"\n", "canonical_solution": "    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n\n"}
{"prompt": "def maxValue(n: int, index: int, maxSum: int) -> int:\n    \"\"\"\n    You are given three positive integers:\u00a0n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n\n    nums.length == n\n    nums[i] is a positive integer where 0 <= i < n.\n    abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\n    The sum of all the elements of nums does not exceed maxSum.\n    nums[index] is maximized.\n\n    Return nums[index] of the constructed array.\n    Note that abs(x) equals x if x >= 0, and -x otherwise.\n\u00a0\n    Example 1:\n\n    Input: n = 4, index = 2,  maxSum = 6\n    Output: 2\n    Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\n    There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n\n    Example 2:\n\n    Input: n = 6, index = 1,  maxSum = 10\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= n <= maxSum <= 109\n    0 <= index < n\n\n    \"\"\"\n", "canonical_solution": "    maxSum -= n\n    left, right, ans = 0, maxSum, 0\n    while left <= right:\n        mid = left + (right - left) // 2\n        sum = min(mid, index) * (min(mid, index) + 1) // 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1) // 2\n        if mid > index:\n            sum += (mid - index - 1) * (mid - index) // 2\n        if mid > n - index:\n            sum += (mid - n + index) * (mid - n + index + 1) // 2\n        if sum <= maxSum:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans + 1\n\n"}
{"prompt": "from typing import List\n\n\ndef splitPainting(segments: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. You are given a 2D integer array segments, where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color.\n    The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a set of mixed colors.\n\n    For example, if colors 2, 4, and 6 are mixed, then the resulting mixed color is {2,4,6}.\n\n    For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set.\n    You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj.\n\n    For example, the painting created with segments = [[1,4,5],[1,7,7]] can be described by painting = [[1,4,12],[4,7,7]] because:\n\n\n    [1,4) is colored {5,7} (with a sum of 12) from both the first and second segments.\n    [4,7) is colored {7} from only the second segment.\n\n\n\n    Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order.\n    A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b.\n\u00a0\n    Example 1:\n\n\n    Input: segments = [[1,4,5],[4,7,7],[1,7,9]]\n    Output: [[1,4,14],[4,7,16]]\n    Explanation: The painting can be described as follows:\n    - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n    - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n\n    Example 2:\n\n\n    Input: segments = [[1,7,9],[6,8,15],[8,10,7]]\n    Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n    Explanation: The painting can be described as follows:\n    - [1,6) is colored 9 from the first segment.\n    - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n    - [7,8) is colored 15 from the second segment.\n    - [8,10) is colored 7 from the third segment.\n\n    Example 3:\n\n\n    Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n    Output: [[1,4,12],[4,7,12]]\n    Explanation: The painting can be described as follows:\n    - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n    - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\n    Note that returning a single segment [1,7) is incorrect because the mixed color sets are different.\n\n\u00a0\n    Constraints:\n\n    1 <= segments.length <= 2 * 104\n    segments[i].length == 3\n    1 <= starti < endi <= 105\n    1 <= colori <= 109\n    Each colori is distinct.\n\n    \"\"\"\n", "canonical_solution": "    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef finding_users_active_minutes(logs: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    You are given the logs for users' actions on LeetCode, and an integer k. The logs are represented by a 2D integer array logs where each logs[i] = [IDi, timei] indicates that the user with IDi performed an action at the minute timei.\n    Multiple users can perform actions simultaneously, and a single user can perform multiple actions in the same minute.\n    The user active minutes (UAM) for a given user is defined as the number of unique minutes in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it.\n    You are to calculate a 1-indexed array answer of size k such that, for each j (1 <= j <= k), answer[j] is the number of users whose UAM equals j.\n    Return the array answer as described above.\n\u00a0\n    Example 1:\n\n    Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5\n    Output: [0,2,0,0,0]\n    Explanation:\n    The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).\n    The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\n    Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.\n\n    Example 2:\n\n    Input: logs = [[1,1],[2,2],[2,3]], k = 4\n    Output: [1,1,0,0]\n    Explanation:\n    The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.\n    The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\n    There is one user with a UAM of 1 and one with a UAM of 2.\n    Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.\n\n\u00a0\n    Constraints:\n\n    1 <= logs.length <= 104\n    0 <= IDi <= 109\n    1 <= timei <= 105\n    k is in the range [The maximum UAM for a user, 105].\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    user_minutes = defaultdict(set)\n    for log in logs:\n        user_minutes[log[0]].add(log[1])\n    result = [0] * k\n    for minutes in user_minutes.values():\n        if len(minutes) <= k:\n            result[len(minutes) - 1] += 1\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef minSideJumps(obstacles: List[int]) -> int:\n    \"\"\"\n    There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\n    You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\n    For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\n    The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\n    For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\n    Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\n    Note: There will be no obstacles on points 0 and n.\n\u00a0\n    Example 1:\n\n\n    Input: obstacles = [0,1,2,3,0]\n    Output: 2 \n    Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\n    Note that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n    Example 2:\n\n\n    Input: obstacles = [0,1,1,3,3,0]\n    Output: 0\n    Explanation: There are no obstacles on lane 2. No side jumps are required.\n\n    Example 3:\n\n\n    Input: obstacles = [0,2,1,0,3,0]\n    Output: 2\n    Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n\u00a0\n    Constraints:\n\n    obstacles.length == n + 1\n    1 <= n <= 5 * 105\n    0 <= obstacles[i] <= 3\n    obstacles[0] == obstacles[n] == 0\n\n    \"\"\"\n", "canonical_solution": "    n = len(obstacles)\n    dp = [[n] * 3 for _ in range(n)]\n    dp[0][1] = 0\n    dp[0][0] = dp[0][2] = 1\n\n    for i in range(1, n):\n        if obstacles[i] != 1:\n            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 2:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 3:\n            dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1)\n\n    return min(dp[-1])\n\n"}
{"prompt": "from typing import List\n\n\ndef canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n    \"\"\"\n    There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\n    For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\n    Return true if you can finish all courses. Otherwise, return false.\n\u00a0\n    Example 1:\n\n    Input: numCourses = 2, prerequisites = [[1,0]]\n    Output: true\n    Explanation: There are a total of 2 courses to take. \n    To take course 1 you should have finished course 0. So it is possible.\n\n    Example 2:\n\n    Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\n    Output: false\n    Explanation: There are a total of 2 courses to take. \n    To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\u00a0\n    Constraints:\n\n    1 <= numCourses <= 2000\n    0 <= prerequisites.length <= 5000\n    prerequisites[i].length == 2\n    0 <= ai, bi < numCourses\n    All the pairs prerequisites[i] are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict, deque\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n\n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n\n    q = deque([i for i in range(numCourses) if inDegree[i] == 0])\n\n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n\n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n\n    return numCourses == 0\n\n"}
{"prompt": "from typing import List\n\n\ndef checkMove(board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n    \"\"\"\n    You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.\n    Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).\n    A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:\n\n    Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.\n\u00a0\n    Example 1:\n\n\n    Input: board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n    Output: true\n    Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\n    The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.\n\n    Example 2:\n\n\n    Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n    Output: false\n    Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.\n\n\u00a0\n    Constraints:\n\n    board.length == board[r].length == 8\n    0 <= rMove, cMove < 8\n    board[rMove][cMove] == '.'\n    color is either 'B' or 'W'.\n\n    \"\"\"\n", "canonical_solution": "    directions = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))\n    opposite_color = 'B' if color == 'W' else 'W'\n\n    for d in directions:\n        x, y = rMove + d[0], cMove + d[1]\n        count = 0\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opposite_color:\n            x += d[0]\n            y += d[1]\n            count += 1\n\n        if count > 0 and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == color:\n            return True\n\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef minSpaceWastedKResizing(nums: List[int], k: int) -> int:\n    \"\"\"\n    You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. In addition, you are given an integer k, the maximum number of times you can resize the array (to any size).\n    The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. The space wasted at\u00a0time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length.\n    Return the minimum total space wasted if you can resize the array at most k times.\n    Note: The array can have any size at the start and does not count towards the number of resizing operations.\n\u00a0\n    Example 1:\n\n    Input: nums = [10,20], k = 0\n    Output: 10\n    Explanation: size = [20,20].\n    We can set the initial size to be 20.\n    The total wasted space is (20 - 10) + (20 - 20) = 10.\n\n    Example 2:\n\n    Input: nums = [10,20,30], k = 1\n    Output: 10\n    Explanation: size = [20,20,30].\n    We can set the initial size to be 20 and resize to 30 at time 2. \n    The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10.\n\n    Example 3:\n\n    Input: nums = [10,20,15,30,20], k = 2\n    Output: 15\n    Explanation: size = [10,20,20,30,30].\n    We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.\n    The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 200\n    1 <= nums[i] <= 106\n    0 <= k <= nums.length - 1\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    sum_nums = [0] * (n + 1)\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        sum_nums[i] = sum_nums[i - 1] + nums[i - 1]\n        max_val = nums[i - 1]\n        for j in range(i - 1, -1, -1):\n            max_val = max(max_val, nums[j])\n            waste = max_val * (i - j) - (sum_nums[i] - sum_nums[j])\n            for c in range(k):\n                dp[i][c + 1] = min(dp[i][c + 1], dp[j][c] + waste)\n\n    return dp[n][k]\n\n"}
{"prompt": "from typing import List\n\n\ndef max_ice_cream(costs: List[int], coins: int) -> int:\n    \"\"\"\n    It is a sweltering summer day, and a boy wants to buy some ice cream bars.\n    At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\n    Note: The boy can buy the ice cream bars in any order.\n    Return the maximum number of ice cream bars the boy can buy with coins coins.\n    You must solve the problem by counting sort.\n\u00a0\n    Example 1:\n\n    Input: costs = [1,3,2,4,1], coins = 7\n    Output: 4\n    Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n\n    Example 2:\n\n    Input: costs = [10,6,8,7,7,8], coins = 5\n    Output: 0\n    Explanation: The boy cannot afford any of the ice cream bars.\n\n    Example 3:\n\n    Input: costs = [1,6,3,1,2,5], coins = 20\n    Output: 6\n    Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n\n\u00a0\n    Constraints:\n\n    costs.length == n\n    1 <= n <= 105\n    1 <= costs[i] <= 105\n    1 <= coins <= 108\n\n    \"\"\"\n", "canonical_solution": "    costs.sort()\n    count = 0\n    for cost in costs:\n        if coins >= cost:\n            coins -= cost\n            count += 1\n        else:\n            break\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef getOrder(tasks: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given n\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b task will be available to process at enqueueTimei and will take processingTimei to finish processing.\n    You have a single-threaded CPU that can process at most one task at a time and will act in the following way:\n\n    If the CPU is idle and there are no available tasks to process, the CPU remains idle.\n    If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n    Once a task is started, the CPU will process the entire task without stopping.\n    The CPU can finish a task then start a new one instantly.\n\n    Return the order in which the CPU will process the tasks.\n\u00a0\n    Example 1:\n\n    Input: tasks = [[1,2],[2,4],[3,2],[4,1]]\n    Output: [0,2,3,1]\n    Explanation: The events go as follows: \n    - At time = 1, task 0 is available to process. Available tasks = {0}.\n    - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n    - At time = 2, task 1 is available to process. Available tasks = {1}.\n    - At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n    - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n    - At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n    - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n    - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n    - At time = 10, the CPU finishes task 1 and becomes idle.\n\n    Example 2:\n\n    Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n    Output: [4,3,2,0,1]\n    Explanation: The events go as follows:\n    - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n    - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n    - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n    - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n    - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n    - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n    - At time = 40, the CPU finishes task 1 and becomes idle.\n\n\u00a0\n    Constraints:\n\n    tasks.length == n\n    1 <= n <= 105\n    1 <= enqueueTimei, processingTimei <= 109\n\n    \"\"\"\n", "canonical_solution": "    from queue import PriorityQueue\n    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])\n    min_heap = PriorityQueue()\n    time = 0\n    task_idx = 0\n    result = []\n\n    while task_indices:\n        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:\n            idx = task_indices[task_idx]\n            min_heap.put((tasks[idx][1], idx))\n            task_idx += 1\n\n        if not min_heap.empty():\n            processing_time, index = min_heap.get()\n            time += processing_time\n            result.append(index)\n            task_indices.remove(index)\n        elif task_idx < len(task_indices):\n            time = max(time, tasks[task_indices[task_idx]][0])\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maxFrequency(nums: List[int], k: int) -> int:\n    \"\"\"\n    The frequency of an element is the number of times it occurs in an array.\n    You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\n    Return the maximum possible frequency of an element after performing at most k operations.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,4], k = 5\n    Output: 3\n    Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\n    4 has a frequency of 3.\n    Example 2:\n\n    Input: nums = [1,4,8,13], k = 5\n    Output: 2\n    Explanation: There are multiple optimal solutions:\n    - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n    - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n    - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n    Example 3:\n\n    Input: nums = [3,9,6], k = 2\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 105\n    1 <= k <= 105\n\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    max_freq, n, total = 1, len(nums), 0\n    i = 0\n    for j in range(n):\n        total += nums[j]\n        while total < nums[j] * (j - i + 1) - k:\n            total -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n    return max_freq\n\n"}
{"prompt": "def longest_beautiful_substring(word: str) -> int:\n    \"\"\"\n    A string is considered beautiful if it satisfies the following conditions:\n\n    Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.\n    The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).\n\n    For example, strings \"aeiou\" and \"aaaaaaeiiiioou\" are considered beautiful, but \"uaeio\", \"aeoiu\", and \"aaaeeeooo\" are not beautiful.\n    Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.\n    A substring is a contiguous sequence of characters in a string.\n\u00a0\n    Example 1:\n\n    Input: word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\"\n    Output: 13\n    Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13.\n    Example 2:\n\n    Input: word = \"aeeeiiiioooauuuaeiou\"\n    Output: 5\n    Explanation: The longest beautiful substring in word is \"aeiou\" of length 5.\n\n    Example 3:\n\n    Input: word = \"a\"\n    Output: 0\n    Explanation: There is no beautiful substring, so return 0.\n\n\u00a0\n    Constraints:\n\n    1 <= word.length <= 5 * 105\n    word consists of characters 'a', 'e', 'i', 'o', and 'u'.\n\n    \"\"\"\n", "canonical_solution": "    if len(word) < 5:\n        return 0\n\n    max_length = current_length = 1\n    current_vowels = word[0]\n\n    for i in range(1, len(word)):\n        if word[i] >= current_vowels[-1] and word[i] not in current_vowels:\n            current_vowels += word[i]\n        elif word[i] == current_vowels[-1]:\n            pass\n        else:\n            current_vowels = word[i]\n            current_length = 0\n\n        current_length += 1\n\n        if current_vowels == \"aeiou\":\n            max_length = max(max_length, current_length)\n\n    return max_length\n\n"}
{"prompt": "from typing import List\n\n\ndef findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    \"\"\"\n    There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\n    For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\n    Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\u00a0\n    Example 1:\n\n    Input: numCourses = 2, prerequisites = [[1,0]]\n    Output: [0,1]\n    Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\n    Example 2:\n\n    Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n    Output: [0,2,1,3]\n    Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\n    So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\n    Example 3:\n\n    Input: numCourses = 1, prerequisites = []\n    Output: [0]\n\n\u00a0\n    Constraints:\n\n    1 <= numCourses <= 2000\n    0 <= prerequisites.length <= numCourses * (numCourses - 1)\n    prerequisites[i].length == 2\n    0 <= ai, bi < numCourses\n    ai != bi\n    All the pairs [ai, bi] are distinct.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n\n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n\n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n\n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n\n    return order if len(order) == numCourses else []\n\n"}
{"prompt": "from typing import List\n\n\ndef threeSumClosest(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n    Return the sum of the three integers.\n    You may assume that each input would have exactly one solution.\n\u00a0\n    Example 1:\n\n    Input: nums = [-1,2,1,-4], target = 1\n    Output: 2\n    Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n    Example 2:\n\n    Input: nums = [0,0,0], target = 1\n    Output: 0\n    Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n\u00a0\n    Constraints:\n\n    3 <= nums.length <= 500\n    -1000 <= nums[i] <= 1000\n    -104 <= target <= 104\n\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n\n"}
{"prompt": "from typing import List\n\n\ndef max_distance(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    You are given two non-increasing 0-indexed integer arrays nums1\u200b\u200b\u200b\u200b\u200b\u200b and nums2\u200b\u200b\u200b\u200b\u200b\u200b.\n    A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i\u200b\u200b\u200b\u200b.\n    Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.\n    An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.\n\u00a0\n    Example 1:\n\n    Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n    Output: 2\n    Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\n    The maximum distance is 2 with pair (2,4).\n\n    Example 2:\n\n    Input: nums1 = [2,2,2], nums2 = [10,10,1]\n    Output: 1\n    Explanation: The valid pairs are (0,0), (0,1), and (1,1).\n    The maximum distance is 1 with pair (0,1).\n\n    Example 3:\n\n    Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n    Output: 2\n    Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\n    The maximum distance is 2 with pair (2,4).\n\n\u00a0\n    Constraints:\n\n    1 <= nums1.length, nums2.length <= 105\n    1 <= nums1[i], nums2[j] <= 105\n    Both nums1 and nums2 are non-increasing.\n\n    \"\"\"\n", "canonical_solution": "    i, j, max_dist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if i <= j and nums1[i] <= nums2[j]:\n            max_dist = max(max_dist, j - i)\n            j += 1\n        else:\n            i += 1\n    return max_dist\n\n"}
{"prompt": "from typing import List\n\n\ndef findFarmland(land: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\n    To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\n    land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\n    Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\n\u00a0\n    Example 1:\n\n\n    Input: land = [[1,0,0],[0,1,1],[0,1,1]]\n    Output: [[0,0,0,0],[1,1,2,2]]\n    Explanation:\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\n    The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].\n\n    Example 2:\n\n\n    Input: land = [[1,1],[1,1]]\n    Output: [[0,0,1,1]]\n    Explanation:\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].\n\n    Example 3:\n\n\n    Input: land = [[0]]\n    Output: []\n    Explanation:\n    There are no groups of farmland.\n\n\u00a0\n    Constraints:\n\n    m == land.length\n    n == land[i].length\n    1 <= m, n <= 300\n    land consists of only 0's and 1's.\n    Groups of farmland are rectangular in shape.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(land), len(land[0])\n    groups = []\n\n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups\n\n"}
{"prompt": "from typing import List\n\n\ndef firstDayBeenInAllRooms(nextVisit: List[int]) -> int:\n    \"\"\"\n    There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.\n    Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:\n\n    Assuming that on a day, you visit room i,\n    if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] where 0 <= nextVisit[i] <= i;\n    if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.\n\n    Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nextVisit = [0,0]\n    Output: 2\n    Explanation:\n    - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n    \u00a0 \u00a0 On the next day you will visit room nextVisit[0] = 0\n    - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n    \u00a0 \u00a0 On the next day you will visit room (0 + 1) mod 2 = 1\n    - On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n    Example 2:\n\n    Input: nextVisit = [0,0,2]\n    Output: 6\n    Explanation:\n    Your room visiting order for each day is: [0,0,1,0,0,1,2,...].\n    Day 6 is the first day where you have been in all the rooms.\n\n    Example 3:\n\n    Input: nextVisit = [0,1,2,0]\n    Output: 6\n    Explanation:\n    Your room visiting order for each day is: [0,0,1,1,2,2,3,...].\n    Day 6 is the first day where you have been in all the rooms.\n\n\u00a0\n    Constraints:\n\n    n == nextVisit.length\n    2 <= n <= 105\n    0 <= nextVisit[i] <= i\n\n    \"\"\"\n", "canonical_solution": "    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]\n\n"}
{"prompt": "def canReach(s: str, minJump: int, maxJump: int) -> bool:\n    \"\"\"\n    You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:\n\n    i + minJump <= j <= min(i + maxJump, s.length - 1), and\n    s[j] == '0'.\n\n    Return true if you can reach index s.length - 1 in s, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: s = \"011010\", minJump = 2, maxJump = 3\n    Output: true\n    Explanation:\n    In the first step, move from index 0 to index 3. \n    In the second step, move from index 3 to index 5.\n\n    Example 2:\n\n    Input: s = \"01101110\", minJump = 2, maxJump = 3\n    Output: false\n\n\u00a0\n    Constraints:\n\n    2 <= s.length <= 105\n    s[i] is either '0' or '1'.\n    s[0] == '0'\n    1 <= minJump <= maxJump < s.length\n\n    \"\"\"\n", "canonical_solution": "    n = len(s)\n    dp = [False] * n\n    dp[0] = True\n    pre = 0\n    for i in range(1, n):\n        if i >= minJump:\n            pre += dp[i - minJump]\n        if i > maxJump:\n            pre -= dp[i - maxJump - 1]\n        dp[i] = pre > 0 and s[i] == '0'\n    return dp[n - 1]\n\n"}
{"prompt": "from typing import List\n\n\ndef stoneGameVII(stones: List[int]) -> int:\n    \"\"\"\n    Alice and Bob take turns playing a game, with Alice starting first.\n    There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n    Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score.\n    Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.\n\u00a0\n    Example 1:\n\n    Input: stones = [5,3,1,4,2]\n    Output: 6\n    Explanation: \n    - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].\n    - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].\n    - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].\n    - Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].\n    - Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].\n    The score difference is 18 - 12 = 6.\n\n    Example 2:\n\n    Input: stones = [7,90,5,1,100,10,10,2]\n    Output: 122\n\u00a0\n    Constraints:\n\n    n == stones.length\n    2 <= n <= 1000\n    1 <= stones[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    n = len(stones)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])\n\n    return dp[0][n - 1]\n\n"}
{"prompt": "def max_value(n: str, x: int) -> str:\n    \"\"\"\n    You are given a very large integer n, represented as a string,\u200b\u200b\u200b\u200b\u200b\u200b and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number.\n    You want to maximize n's numerical value by inserting x anywhere in the decimal representation of n\u200b\u200b\u200b\u200b\u200b\u200b. You cannot insert x to the left of the negative sign.\n\n    For example, if n = 73 and x = 6, it would be best to insert it between 7 and 3, making n = 763.\n    If n = -55 and x = 2, it would be best to insert it before the first 5, making n = -255.\n\n    Return a string representing the maximum value of n\u200b\u200b\u200b\u200b\u200b\u200b after the insertion.\n\u00a0\n    Example 1:\n\n    Input: n = \"99\", x = 9\n    Output: \"999\"\n    Explanation: The result is the same regardless of where you insert 9.\n\n    Example 2:\n\n    Input: n = \"-13\", x = 2\n    Output: \"-123\"\n    Explanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123.\n\n\u00a0\n    Constraints:\n\n    1 <= n.length <= 105\n    1 <= x <= 9\n    The digits in n\u200b\u200b\u200b are in the range [1, 9].\n    n is a valid representation of an integer.\n    In the case of a negative n,\u200b\u200b\u200b\u200b\u200b\u200b it will begin with '-'.\n\n    \"\"\"\n", "canonical_solution": "    is_negative = n[0] == '-'\n    pos = 1 if is_negative else 0\n\n    while pos < len(n):\n        if (is_negative and int(n[pos]) > x) or (not is_negative and int(n[pos]) < x):\n            break\n        pos += 1\n\n    return n[:pos] + str(x) + n[pos:]\n\n"}
{"prompt": "def remove_occurrences(s: str, part: str) -> str:\n    \"\"\"\n    Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:\n\n    Find the leftmost occurrence of the substring part and remove it from s.\n\n    Return s after removing all occurrences of part.\n    A substring is a contiguous sequence of characters in a string.\n\u00a0\n    Example 1:\n\n    Input: s = \"daabcbaabcbc\", part = \"abc\"\n    Output: \"dab\"\n    Explanation: The following operations are done:\n    - s = \"daabcbaabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\".\n    - s = \"dabaabcbc\", remove \"abc\" starting at index 4, so s = \"dababc\".\n    - s = \"dababc\", remove \"abc\" starting at index 3, so s = \"dab\".\n    Now s has no occurrences of \"abc\".\n\n    Example 2:\n\n    Input: s = \"axxxxyyyyb\", part = \"xy\"\n    Output: \"ab\"\n    Explanation: The following operations are done:\n    - s = \"axxxxyyyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\".\n    - s = \"axxxyyyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\".\n    - s = \"axxyyb\", remove \"xy\" starting at index 2 so s = \"axyb\".\n    - s = \"axyb\", remove \"xy\" starting at index 1 so s = \"ab\".\n    Now s has no occurrences of \"xy\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    1 <= part.length <= 1000\n    s\u200b\u200b\u200b\u200b\u200b\u200b and part consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    while part in s:\n        s = s.replace(part, '', 1)\n    return s\n\n"}
{"prompt": "def max_consecutive_answers(answer_key: str, k: int) -> int:\n    \"\"\"\n    A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).\n    You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:\n\n    Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').\n\n    Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.\n\u00a0\n    Example 1:\n\n    Input: answerKey = \"TTFF\", k = 2\n    Output: 4\n    Explanation: We can replace both the 'F's with 'T's to make answerKey = \"TTTT\".\n    There are four consecutive 'T's.\n\n    Example 2:\n\n    Input: answerKey = \"TFFT\", k = 1\n    Output: 3\n    Explanation: We can replace the first 'T' with an 'F' to make answerKey = \"FFFT\".\n    Alternatively, we can replace the second 'T' with an 'F' to make answerKey = \"TFFF\".\n    In both cases, there are three consecutive 'F's.\n\n    Example 3:\n\n    Input: answerKey = \"TTFTTFTT\", k = 1\n    Output: 5\n    Explanation: We can replace the first 'F' to make answerKey = \"TTTTTFTT\"\n    Alternatively, we can replace the second 'F' to make answerKey = \"TTFTTTTT\". \n    In both cases, there are five consecutive 'T's.\n\n\u00a0\n    Constraints:\n\n    n == answerKey.length\n    1 <= n <= 5 * 104\n    answerKey[i] is either 'T' or 'F'\n    1 <= k <= n\n\n    \"\"\"\n", "canonical_solution": "    max_len, left, T_cnt, F_cnt = 0, 0, 0, 0\n\n    for right, c in enumerate(answer_key):\n        if c == 'T':\n            T_cnt += 1\n        else:\n            F_cnt += 1\n\n        if min(T_cnt, F_cnt) > k:\n            if answer_key[left] == 'T':\n                T_cnt -= 1\n            else:\n                F_cnt -= 1\n            left += 1\n        else:\n            max_len = max(max_len, T_cnt + F_cnt)\n\n    return max_len\n\n"}
{"prompt": "from typing import List\n\n\ndef countSubIslands(grid1: List[List[int]], grid2: List[List[int]]) -> int:\n    \"\"\"\n    You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.\n    An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.\n    Return the number of islands in grid2 that are considered sub-islands.\n\u00a0\n    Example 1:\n\n\n    Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n    Output: 3\n    Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\n    The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n\n    Example 2:\n\n\n    Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n    Output: 2 \n    Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\n    The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n\n\u00a0\n    Constraints:\n\n    m == grid1.length == grid2.length\n    n == grid1[i].length == grid2[i].length\n    1 <= m, n <= 500\n    grid1[i][j] and grid2[i][j] are either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(i, j):\n        if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0:\n            return True\n\n        grid2[i][j] = 0\n\n        isSubIsland = grid1[i][j] == 1\n        isSubIsland &= dfs(i + 1, j)\n        isSubIsland &= dfs(i - 1, j)\n        isSubIsland &= dfs(i, j + 1)\n        isSubIsland &= dfs(i, j - 1)\n\n        return isSubIsland\n\n    count = 0\n\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid2[i][j] == 1 and dfs(i, j):\n                count += 1\n\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAlternatingSum(nums: List[int]) -> int:\n    \"\"\"\n    The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\n\n    For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.\n\n    Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).\n\n\n    A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,2,5,3]\n    Output: 7\n    Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.\n\n    Example 2:\n\n    Input: nums = [5,6,7,8]\n    Output: 8\n    Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.\n\n    Example 3:\n\n    Input: nums = [6,2,1,2,4,5]\n    Output: 10\n    Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 105\n    \"\"\"\n", "canonical_solution": "    odd, even = 0, 0\n    for num in nums:\n        newOdd = max(even + num, odd)\n        even = max(odd - num, even)\n        odd = newOdd\n    return odd\n\n"}
{"prompt": "def sumGame(num: str) -> bool:\n    \"\"\"\n    Alice and Bob take turns playing a game, with Alice\u00a0starting first.\n    You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num:\n\n    Choose an index i where num[i] == '?'.\n    Replace num[i] with any digit between '0' and '9'.\n\n    The game ends when there are no more '?' characters in num.\n    For Bob\u00a0to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice\u00a0to win, the sums must not be equal.\n\n    For example, if the game ended with num = \"243801\", then Bob\u00a0wins because 2+4+3 = 8+0+1. If the game ended with num = \"243803\", then Alice\u00a0wins because 2+4+3 != 8+0+3.\n\n    Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.\n\u00a0\n    Example 1:\n\n    Input: num = \"5023\"\n    Output: false\n    Explanation: There are no moves to be made.\n    The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.\n\n    Example 2:\n\n    Input: num = \"25??\"\n    Output: true\n    Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.\n\n    Example 3:\n\n    Input: num = \"?3295???\"\n    Output: false\n    Explanation: It can be proven that Bob will always win. One possible outcome is:\n    - Alice replaces the first '?' with '9'. num = \"93295???\".\n    - Bob replaces one of the '?' in the right half with '9'. num = \"932959??\".\n    - Alice replaces one of the '?' in the right half with '2'. num = \"9329592?\".\n    - Bob replaces the last '?' in the right half with '7'. num = \"93295927\".\n    Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.\n\n\u00a0\n    Constraints:\n\n    2 <= num.length <= 105\n    num.length is even.\n    num consists of only digits and '?'.\n\n    \"\"\"\n", "canonical_solution": "    n = len(num)\n    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0\n\n    for i in range(n // 2):\n        if num[i] == '?':\n            cnt1 += 1\n        else:\n            sum1 += int(num[i])\n\n    for i in range(n // 2, n):\n        if num[i] == '?':\n            cnt2 += 1\n        else:\n            sum2 += int(num[i])\n\n    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9\n\n"}
{"prompt": "from typing import List\n\n\ndef combinationSum3(k: int, n: int) -> List[List[int]]:\n    \"\"\"\n    Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\n    Only numbers 1 through 9 are used.\n    Each number is used at most once.\n\n    Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\n\u00a0\n    Example 1:\n\n    Input: k = 3, n = 7\n    Output: [[1,2,4]]\n    Explanation:\n    1 + 2 + 4 = 7\n    There are no other valid combinations.\n    Example 2:\n\n    Input: k = 3, n = 9\n    Output: [[1,2,6],[1,3,5],[2,3,4]]\n    Explanation:\n    1 + 2 + 6 = 9\n    1 + 3 + 5 = 9\n    2 + 3 + 4 = 9\n    There are no other valid combinations.\n\n    Example 3:\n\n    Input: k = 4, n = 1\n    Output: []\n    Explanation: There are no valid combinations.\n    Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\n\n\u00a0\n    Constraints:\n\n    2 <= k <= 9\n    1 <= n <= 60\n\n    \"\"\"\n", "canonical_solution": "    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef rotateGrid(grid: List[List[int]], k: int) -> List[List[int]]:\n    \"\"\"\n    You are given an m x n integer matrix grid\u200b\u200b\u200b, where m and n are both even integers, and an integer k.\n    The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:\n\n    A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below:\n\n    Return the matrix after applying k cyclic rotations to it.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[40,10],[30,20]], k = 1\n    Output: [[10,20],[40,30]]\n    Explanation: The figures above represent the grid at every state.\n\n    Example 2:\n\n\n    Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n    Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n    Explanation: The figures above represent the grid at every state.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    2 <= m, n <= 50\n    Both m and n are even integers.\n    1 <= grid[i][j] <= 5000\n    1 <= k <= 109\n    \"\"\"\n", "canonical_solution": "    def rotateLayer(layer, k):\n        m, n = len(grid), len(grid[0])\n        top, bottom = layer, m - 1 - layer\n        left, right = layer, n - 1 - layer\n        data_in_layer = (right - left + 1) * 2 + (bottom - top - 1) * 2\n        k %= data_in_layer\n        for _ in range(k):\n            temp = grid[top][left]\n            for j in range(left, right):\n                grid[top][j] = grid[top][j + 1]\n            for i in range(top, bottom):\n                grid[i][right] = grid[i + 1][right]\n            for j in range(right, left, -1):\n                grid[bottom][j] = grid[bottom][j - 1]\n            for i in range(bottom, top, -1):\n                grid[i][left] = grid[i - 1][left]\n            grid[top + 1][left] = temp\n\n    m, n = len(grid), len(grid[0])\n    layers = min(m, n) // 2\n    for layer in range(layers):\n        rotateLayer(layer, k)\n    return grid\n\n"}
{"prompt": "def wonderfulSubstrings(word: str) -> int:\n    \"\"\"\n    A wonderful string is a string where at most one letter appears an odd number of times.\n\n    For example, \"ccjjc\" and \"abab\" are wonderful, but \"ab\" is not.\n\n    Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.\n    A substring is a contiguous sequence of characters in a string.\n\u00a0\n    Example 1:\n\n    Input: word = \"aba\"\n    Output: 4\n    Explanation: The four wonderful substrings are underlined below:\n    - \"aba\" -> \"a\"\n    - \"aba\" -> \"b\"\n    - \"aba\" -> \"a\"\n    - \"aba\" -> \"aba\"\n\n    Example 2:\n\n    Input: word = \"aabb\"\n    Output: 9\n    Explanation: The nine wonderful substrings are underlined below:\n    - \"aabb\" -> \"a\"\n    - \"aabb\" -> \"aa\"\n    - \"aabb\" -> \"aab\"\n    - \"aabb\" -> \"aabb\"\n    - \"aabb\" -> \"a\"\n    - \"aabb\" -> \"abb\"\n    - \"aabb\" -> \"b\"\n    - \"aabb\" -> \"bb\"\n    - \"aabb\" -> \"b\"\n\n    Example 3:\n\n    Input: word = \"he\"\n    Output: 2\n    Explanation: The two wonderful substrings are underlined below:\n    - \"he\" -> \"h\"\n    - \"he\" -> \"e\"\n\n\u00a0\n    Constraints:\n\n    1 <= word.length <= 105\n    word consists of lowercase English letters from 'a'\u00a0to 'j'.\n    \"\"\"\n", "canonical_solution": "    res = 0\n    mask = 0\n    count = {0: 1}\n    for c in word:\n        mask ^= 1 << (ord(c) - ord('a'))\n        res += count.get(mask, 0)\n        for i in range(10):\n            res += count.get(mask ^ (1 << i), 0)\n        count[mask] = count.get(mask, 0) + 1\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef maxCompatibilitySum(students: List[List[int]], mentors: List[List[int]]) -> int:\n    \"\"\"\n    There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes).\n    The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed).\n    Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.\n\n    For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same.\n\n    You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.\n    Given students and mentors, return the maximum compatibility score sum that can be achieved.\n\u00a0\n    Example 1:\n\n    Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n    Output: 8\n    Explanation:\u00a0We assign students to mentors in the following way:\n    - student 0 to mentor 2 with a compatibility score of 3.\n    - student 1 to mentor 0 with a compatibility score of 2.\n    - student 2 to mentor 1 with a compatibility score of 3.\n    The compatibility score sum is 3 + 2 + 3 = 8.\n\n    Example 2:\n\n    Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n    Output: 0\n    Explanation: The compatibility score of any student-mentor pair is 0.\n\n\u00a0\n    Constraints:\n\n    m == students.length == mentors.length\n    n == students[i].length == mentors[j].length\n    1 <= m, n <= 8\n    students[i][k] is either 0 or 1.\n    mentors[j][k] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    from itertools import permutations\n    ans = 0\n    for mentors_perm in permutations(mentors):\n        cur_sum = sum(sum(a == b for a, b in zip(student, mentor)) for student, mentor in zip(students, mentors_perm))\n        ans = max(ans, cur_sum)\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef maximalSquare(matrix: List[List[str]]) -> int:\n    \"\"\"\n    Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\u00a0\n    Example 1:\n\n\n    Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n    Output: 4\n\n    Example 2:\n\n\n    Input: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n    Output: 1\n\n    Example 3:\n\n    Input: matrix = [[\"0\"]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 300\n    matrix[i][j] is '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n\n"}
{"prompt": "from typing import List\n\n\ndef findFarmland(land: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\n    To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\n    land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\n    Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\n\u00a0\n    Example 1:\n\n\n    Input: land = [[1,0,0],[0,1,1],[0,1,1]]\n    Output: [[0,0,0,0],[1,1,2,2]]\n    Explanation:\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\n    The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].\n\n    Example 2:\n\n\n    Input: land = [[1,1],[1,1]]\n    Output: [[0,0,1,1]]\n    Explanation:\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].\n\n    Example 3:\n\n\n    Input: land = [[0]]\n    Output: []\n    Explanation:\n    There are no groups of farmland.\n\n\u00a0\n    Constraints:\n\n    m == land.length\n    n == land[i].length\n    1 <= m, n <= 300\n    land consists of only 0's and 1's.\n    Groups of farmland are rectangular in shape.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(land), len(land[0])\n    res = []\n\n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r, c = i, j\n                while r < m and land[r][j] == 1:\n                    r += 1\n                while c < n and land[i][c] == 1:\n                    c += 1\n                for x in range(i, r):\n                    for y in range(j, c):\n                        land[x][y] = 0\n                res.append([i, j, r - 1, c - 1])\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef find_different_binary_string(nums: List[str]) -> str:\n    \"\"\"\n    Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\n\u00a0\n    Example 1:\n\n    Input: nums = [\"01\",\"10\"]\n    Output: \"11\"\n    Explanation: \"11\" does not appear in nums. \"00\" would also be correct.\n\n    Example 2:\n\n    Input: nums = [\"00\",\"01\"]\n    Output: \"11\"\n    Explanation: \"11\" does not appear in nums. \"10\" would also be correct.\n\n    Example 3:\n\n    Input: nums = [\"111\",\"011\",\"001\"]\n    Output: \"101\"\n    Explanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 16\n    nums[i].length == n\n    nums[i] is either '0' or '1'.\n    All the strings of nums are unique.\n\n    \"\"\"\n", "canonical_solution": "    return \"\".join(\"1\" if nums[i][i] == \"0\" else \"0\" for i in range(len(nums)))\n\n"}
{"prompt": "from typing import List\n\n\ndef kthLargestNumber(nums: List[str], k: int) -> str:\n    \"\"\"\n    You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\n    Return the string that represents the kth largest integer in nums.\n    Note: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.\n\u00a0\n    Example 1:\n\n    Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\n    Output: \"3\"\n    Explanation:\n    The numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"].\n    The 4th largest integer in nums is \"3\".\n\n    Example 2:\n\n    Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\n    Output: \"2\"\n    Explanation:\n    The numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"].\n    The 3rd largest integer in nums is \"2\".\n\n    Example 3:\n\n    Input: nums = [\"0\",\"0\"], k = 2\n    Output: \"0\"\n    Explanation:\n    The numbers in nums sorted in non-decreasing order are [\"0\",\"0\"].\n    The 2nd largest integer in nums is \"0\".\n\n\u00a0\n    Constraints:\n\n    1 <= k <= nums.length <= 104\n    1 <= nums[i].length <= 100\n    nums[i] consists of only digits.\n    nums[i] will not have any leading zeros.\n\n    \"\"\"\n", "canonical_solution": "    nums.sort(key=lambda x: (len(x), x))\n    return nums[-k]\n\n"}
{"prompt": "from typing import List\n\n\ndef min_sessions(tasks: List[int], session_time: int) -> int:\n    \"\"\"\n    There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. A work session is when you work for at most sessionTime consecutive hours and then take a break.\n    You should finish the given tasks in a way that satisfies the following conditions:\n\n    If you start a task in a work session, you must complete it in the same work session.\n    You can start a new task immediately after finishing the previous one.\n    You may complete the tasks in any order.\n\n    Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above.\n    The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i].\n\u00a0\n    Example 1:\n\n    Input: tasks = [1,2,3], sessionTime = 3\n    Output: 2\n    Explanation: You can finish the tasks in two work sessions.\n    - First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n    - Second work session: finish the third task in 3 hours.\n\n    Example 2:\n\n    Input: tasks = [3,1,3,1,1], sessionTime = 8\n    Output: 2\n    Explanation: You can finish the tasks in two work sessions.\n    - First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n    - Second work session: finish the last task in 1 hour.\n\n    Example 3:\n\n    Input: tasks = [1,2,3,4,5], sessionTime = 15\n    Output: 1\n    Explanation: You can finish all the tasks in one work session.\n\n\u00a0\n    Constraints:\n\n    n == tasks.length\n    1 <= n <= 14\n    1 <= tasks[i] <= 10\n    max(tasks[i]) <= sessionTime <= 15\n\n    \"\"\"\n", "canonical_solution": "    sessions = []\n    tasks.sort(reverse=True)\n\n    for task in tasks:\n        added = False\n        for session_idx, session in enumerate(sessions):\n            if session + task <= session_time:\n                sessions[session_idx] += task\n                added = True\n                break\n\n        if not added:\n            sessions.append(task)\n\n    return len(sessions)\n\n"}
{"prompt": "from typing import List\n\n\ndef findOriginalArray(changed: List[int]) -> List[int]:\n    \"\"\"\n    An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\n    Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.\n\u00a0\n    Example 1:\n\n    Input: changed = [1,3,4,2,6,8]\n    Output: [1,3,4]\n    Explanation: One possible original array could be [1,3,4]:\n    - Twice the value of 1 is 1 * 2 = 2.\n    - Twice the value of 3 is 3 * 2 = 6.\n    - Twice the value of 4 is 4 * 2 = 8.\n    Other original arrays could be [4,3,1] or [3,1,4].\n\n    Example 2:\n\n    Input: changed = [6,3,0,1]\n    Output: []\n    Explanation: changed is not a doubled array.\n\n    Example 3:\n\n    Input: changed = [1]\n    Output: []\n    Explanation: changed is not a doubled array.\n\n\u00a0\n    Constraints:\n\n    1 <= changed.length <= 105\n    0 <= changed[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    count = {}\n    for num in changed:\n        count[num] = count.get(num, 0) + 1\n\n    sorted_values = sorted(count.keys())\n\n    original = []\n    for num in sorted_values:\n        while count[num] > 0 and count.get(num * 2, 0) > 0:\n            original.append(num)\n            count[num] -= 1\n            count[num * 2] -= 1\n        if count[num] > 0:\n            return []\n\n    return original\n\n"}
{"prompt": "from typing import List\n\n\ndef numberOfWeakCharacters(properties: List[List[int]]) -> int:\n    \"\"\"\n    You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\n    A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\n    Return the number of weak characters.\n\u00a0\n    Example 1:\n\n    Input: properties = [[5,5],[6,3],[3,6]]\n    Output: 0\n    Explanation: No character has strictly greater attack and defense than the other.\n\n    Example 2:\n\n    Input: properties = [[2,2],[3,3]]\n    Output: 1\n    Explanation: The first character is weak because the second character has a strictly greater attack and defense.\n\n    Example 3:\n\n    Input: properties = [[1,5],[10,4],[4,3]]\n    Output: 1\n    Explanation: The third character is weak because the second character has a strictly greater attack and defense.\n\n\u00a0\n    Constraints:\n\n    2 <= properties.length <= 105\n    properties[i].length == 2\n    1 <= attacki, defensei <= 105\n\n    \"\"\"\n", "canonical_solution": "    properties.sort(key=lambda x: (x[0], -x[1]))\n\n    max_defense = 0\n    weak_count = 0\n    for attack, defense in reversed(properties):\n        if defense < max_defense:\n            weak_count += 1\n        else:\n            max_defense = defense\n\n    return weak_count\n\n"}
{"prompt": "from typing import List\n\n\ndef firstDayBeenInAllRooms(nextVisit: List[int]) -> int:\n    \"\"\"\n    There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.\n    Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:\n\n    Assuming that on a day, you visit room i,\n    if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] where 0 <= nextVisit[i] <= i;\n    if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.\n\n    Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: nextVisit = [0,0]\n    Output: 2\n    Explanation:\n    - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n    \u00a0 \u00a0 On the next day you will visit room nextVisit[0] = 0\n    - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n    \u00a0 \u00a0 On the next day you will visit room (0 + 1) mod 2 = 1\n    - On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n    Example 2:\n\n    Input: nextVisit = [0,0,2]\n    Output: 6\n    Explanation:\n    Your room visiting order for each day is: [0,0,1,0,0,1,2,...].\n    Day 6 is the first day where you have been in all the rooms.\n\n    Example 3:\n\n    Input: nextVisit = [0,1,2,0]\n    Output: 6\n    Explanation:\n    Your room visiting order for each day is: [0,0,1,1,2,2,3,...].\n    Day 6 is the first day where you have been in all the rooms.\n\n\u00a0\n    Constraints:\n\n    n == nextVisit.length\n    2 <= n <= 105\n    0 <= nextVisit[i] <= i\n\n    \"\"\"\n", "canonical_solution": "    n = len(nextVisit)\n    ans = 0\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD\n        ans = (ans + dp[i]) % MOD\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef interchangeable_rectangles(rectangles: List[List[int]]) -> int:\n    \"\"\"\n    You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle.\n    Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division).\n    Return the number of pairs of interchangeable rectangles in rectangles.\n\u00a0\n    Example 1:\n\n    Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]\n    Output: 6\n    Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):\n    - Rectangle 0 with rectangle 1: 4/8 == 3/6.\n    - Rectangle 0 with rectangle 2: 4/8 == 10/20.\n    - Rectangle 0 with rectangle 3: 4/8 == 15/30.\n    - Rectangle 1 with rectangle 2: 3/6 == 10/20.\n    - Rectangle 1 with rectangle 3: 3/6 == 15/30.\n    - Rectangle 2 with rectangle 3: 10/20 == 15/30.\n\n    Example 2:\n\n    Input: rectangles = [[4,5],[7,8]]\n    Output: 0\n    Explanation: There are no interchangeable pairs of rectangles.\n\n\u00a0\n    Constraints:\n\n    n == rectangles.length\n    1 <= n <= 105\n    rectangles[i].length == 2\n    1 <= widthi, heighti <= 105\n\n    \"\"\"\n", "canonical_solution": "    ratio_count = {}\n    count = 0\n\n    for r in rectangles:\n        ratio = r[0] / r[1]\n        count += ratio_count.get(ratio, 0)\n        ratio_count[ratio] = ratio_count.get(ratio, 0) + 1\n\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef min_operations(grid: List[List[int]], x: int) -> int:\n    \"\"\"\n    You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.\n    A uni-value grid is a grid where all the elements of it are equal.\n    Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[2,4],[6,8]], x = 2\n    Output: 4\n    Explanation: We can make every element equal to 4 by doing the following: \n    - Add x to 2 once.\n    - Subtract x from 6 once.\n    - Subtract x from 8 twice.\n    A total of 4 operations were used.\n\n    Example 2:\n\n\n    Input: grid = [[1,5],[2,3]], x = 1\n    Output: 5\n    Explanation: We can make every element equal to 3.\n\n    Example 3:\n\n\n    Input: grid = [[1,2],[3,4]], x = 2\n    Output: -1\n    Explanation: It is impossible to make every element equal.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 105\n    1 <= m * n <= 105\n    1 <= x, grid[i][j] <= 104\n\n    \"\"\"\n", "canonical_solution": "    min_element = min(min(row) for row in grid)\n    min_ops = float('inf')\n\n    base = min_element\n    while True:\n        operations = 0\n        impossible = False\n        for row in grid:\n            if impossible:\n                break\n            for cell in row:\n                diff = abs(cell - base)\n                if diff % x != 0:\n                    impossible = True\n                    break\n                operations += diff // x\n        if impossible:\n            break\n        min_ops = min(min_ops, operations)\n        base -= 1\n\n    return -1 if min_ops == float('inf') else min_ops\n\n"}
{"prompt": "from typing import List\n\n\ndef productExceptSelf(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n    The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n    You must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.\n\u00a0\n    Example 1:\n    Input: nums = [1,2,3,4]\n    Output: [24,12,8,6]\n    Example 2:\n    Input: nums = [-1,1,0,-3,3]\n    Output: [0,0,9,0,0]\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 105\n    -30 <= nums[i] <= 30\n    The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\n\u00a0\n    Follow up:\u00a0Can you solve the problem in O(1)\u00a0extra\u00a0space complexity? (The output array does not count as extra space for space complexity analysis.)\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    answer = [1] * n\n\n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n\n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n\n    return answer\n\n"}
{"prompt": "from typing import List\n\n\ndef longest_palindrome(words: List[List[str]]) -> int:\n    \"\"\"\n    You are given an array of strings words. Each element of words consists of two lowercase English letters.\n    Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.\n    Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.\n    A palindrome is a string that reads the same forward and backward.\n\u00a0\n    Example 1:\n\n    Input: words = [\"lc\",\"cl\",\"gg\"]\n    Output: 6\n    Explanation: One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6.\n    Note that \"clgglc\" is another longest palindrome that can be created.\n\n    Example 2:\n\n    Input: words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n    Output: 8\n    Explanation: One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8.\n    Note that \"lcyttycl\" is another longest palindrome that can be created.\n\n    Example 3:\n\n    Input: words = [\"cc\",\"ll\",\"xx\"]\n    Output: 2\n    Explanation: One longest palindrome is \"cc\", of length 2.\n    Note that \"ll\" is another longest palindrome that can be created, and so is \"xx\".\n\n\u00a0\n    Constraints:\n\n    1 <= words.length <= 105\n    words[i].length == 2\n    words[i] consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    dict = defaultdict(int)\n    result = 0\n    has_odd = False\n\n    for word in words:\n        dict[word[0]] += 1\n        dict[word[1]] += 1\n\n    for count in dict.values():\n        result += count // 2 * 2\n        has_odd |= count % 2\n\n    return result + has_odd\n\n"}
{"prompt": "from typing import List\n\n\ndef minSwaps(nums: List[int]) -> int:\n    \"\"\"\n    A swap is defined as taking two distinct positions in an array and swapping the values in them.\n    A circular array is defined as an array where we consider the first element and the last element to be adjacent.\n    Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1,0,1,1,0,0]\n    Output: 1\n    Explanation: Here are a few of the ways to group all the 1's together:\n    [0,0,1,1,1,0,0] using 1 swap.\n    [0,1,1,1,0,0,0] using 1 swap.\n    [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\n    There is no way to group all 1's together with 0 swaps.\n    Thus, the minimum number of swaps required is 1.\n\n    Example 2:\n\n    Input: nums = [0,1,1,1,0,0,1,1,0]\n    Output: 2\n    Explanation: Here are a few of the ways to group all the 1's together:\n    [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n    [1,1,1,1,1,0,0,0,0] using 2 swaps.\n    There is no way to group all 1's together with 0 or 1 swaps.\n    Thus, the minimum number of swaps required is 2.\n\n    Example 3:\n\n    Input: nums = [1,1,0,0,1]\n    Output: 0\n    Explanation: All the 1's are already grouped together due to the circular property of the array.\n    Thus, the minimum number of swaps required is 0.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    ones = maxOnes = currOnes = left = 0\n\n    for num in nums:\n        ones += num\n\n    for right in range(len(nums)):\n        currOnes += nums[right]\n\n        if right - left + 1 > ones:\n            currOnes -= nums[left]\n            left += 1\n\n        maxOnes = max(maxOnes, currOnes)\n\n    return ones - maxOnes\n\n"}
{"prompt": "def repeat_limited_string(s: str, repeat_limit: int) -> str:\n    \"\"\"\n    You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.\n    Return the lexicographically largest repeatLimitedString possible.\n    A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.\n\u00a0\n    Example 1:\n\n    Input: s = \"cczazcc\", repeatLimit = 3\n    Output: \"zzcccac\"\n    Explanation: We use all of the characters from s to construct the repeatLimitedString \"zzcccac\".\n    The letter 'a' appears at most 1 time in a row.\n    The letter 'c' appears at most 3 times in a row.\n    The letter 'z' appears at most 2 times in a row.\n    Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n    The string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\".\n    Note that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString.\n\n    Example 2:\n\n    Input: s = \"aababab\", repeatLimit = 2\n    Output: \"bbabaa\"\n    Explanation: We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". \n    The letter 'a' appears at most 2 times in a row.\n    The letter 'b' appears at most 2 times in a row.\n    Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n    The string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\".\n    Note that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString.\n\n\u00a0\n    Constraints:\n\n    1 <= repeatLimit <= s.length <= 105\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    sorted_s = sorted(s, reverse=True)\n\n    for c in sorted_s:\n        pos = result.count(c)\n\n        if pos < repeat_limit:\n            result.insert(pos, c)\n\n    return \"\".join(result)\n\n"}
{"prompt": "def count_collisions(directions: str) -> int:\n    \"\"\"\n    There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\n    You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\n    The number of collisions can be calculated as follows:\n\n    When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\n    When a moving car collides with a stationary car, the number of collisions increases by 1.\n\n    After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n    Return the total number of collisions that will happen on the road.\n\u00a0\n    Example 1:\n\n    Input: directions = \"RLRSLL\"\n    Output: 5\n    Explanation:\n    The collisions that will happen on the road are:\n    - Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n    - Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n    - Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n    - Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\n    Thus, the total number of collisions that will happen on the road is 5. \n\n    Example 2:\n\n    Input: directions = \"LLRR\"\n    Output: 0\n    Explanation:\n    No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\n\u00a0\n    Constraints:\n\n    1 <= directions.length <= 105\n    directions[i] is either 'L', 'R', or 'S'.\n\n    \"\"\"\n", "canonical_solution": "    collision_count = 0\n    left_count = 0\n\n    for direction in directions:\n        if direction == 'L':\n            left_count += 1\n        elif direction == 'R':\n            collision_count += left_count\n\n    return collision_count\n\n"}
{"prompt": "from typing import List\n\n\ndef minSwaps(nums: List[int]) -> int:\n    \"\"\"\n    A swap is defined as taking two distinct positions in an array and swapping the values in them.\n    A circular array is defined as an array where we consider the first element and the last element to be adjacent.\n    Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1,0,1,1,0,0]\n    Output: 1\n    Explanation: Here are a few of the ways to group all the 1's together:\n    [0,0,1,1,1,0,0] using 1 swap.\n    [0,1,1,1,0,0,0] using 1 swap.\n    [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\n    There is no way to group all 1's together with 0 swaps.\n    Thus, the minimum number of swaps required is 1.\n\n    Example 2:\n\n    Input: nums = [0,1,1,1,0,0,1,1,0]\n    Output: 2\n    Explanation: Here are a few of the ways to group all the 1's together:\n    [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n    [1,1,1,1,1,0,0,0,0] using 2 swaps.\n    There is no way to group all 1's together with 0 or 1 swaps.\n    Thus, the minimum number of swaps required is 2.\n\n    Example 3:\n\n    Input: nums = [1,1,0,0,1]\n    Output: 0\n    Explanation: All the 1's are already grouped together due to the circular property of the array.\n    Thus, the minimum number of swaps required is 0.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    minPos = 0\n    maxPos = 0\n    swaps = 0\n\n    for i in range(1, n):\n        if nums[i] <= nums[minPos]:\n            minPos = i\n        if nums[i] >= nums[maxPos]:\n            maxPos = i\n\n    swaps = minPos + (n - 1 - maxPos)\n    if minPos < maxPos:\n        swaps -= 1\n\n    return swaps\n\n"}
{"prompt": "from typing import List\n\n\ndef valid_partition(nums: List[int]) -> bool:\n    \"\"\"\n    You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\n    We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\n    The subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.\n    The subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.\n    The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\n    Return true if the array has at least one valid partition. Otherwise, return false.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,4,4,5,6]\n    Output: true\n    Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\n    This partition is valid, so we return true.\n\n    Example 2:\n\n    Input: nums = [1,1,1,2]\n    Output: false\n    Explanation: There is no valid partition for this array.\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 105\n    1 <= nums[i] <= 106\n\n    \"\"\"\n", "canonical_solution": "    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    for num, cnt in count.items():\n        if cnt == 2 or cnt == 3 or (num - 1 in count and num + 1 in count):\n            return True\n    return False\n\n"}
{"prompt": "def longest_ideal_string(s: str, k: int) -> int:\n    \"\"\"\n    You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\n    t is a subsequence of the string s.\n    The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\n    Return the length of the longest ideal string.\n    A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n    Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n\u00a0\n    Example 1:\n\n    Input: s = \"acfgbd\", k = 2\n    Output: 4\n    Explanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\n    Note that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\n    Example 2:\n\n    Input: s = \"abcd\", k = 3\n    Output: 4\n    Explanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    0 <= k <= 25\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    dp = [0] * 26\n\n    for c in s:\n        current = 1\n        for i in range(26):\n            if abs(i - (ord(c) - ord('a'))) <= k:\n                current = max(current, dp[i] + 1)\n        dp[ord(c) - ord('a')] = max(dp[ord(c) - ord('a')], current)\n\n    return max(dp)\n\n"}
{"prompt": "def remove_stars(s: str) -> str:\n    \"\"\"\n    You are given a string s, which contains stars *.\n    In one operation, you can:\n\n    Choose a star in s.\n    Remove the closest non-star character to its left, as well as remove the star itself.\n\n    Return the string after all stars have been removed.\n    Note:\n\n    The input will be generated such that the operation is always possible.\n    It can be shown that the resulting string will always be unique.\n\n\u00a0\n    Example 1:\n\n    Input: s = \"leet**cod*e\"\n    Output: \"lecoe\"\n    Explanation: Performing the removals from left to right:\n    - The closest character to the 1st star is 't' in \"leet**cod*e\". s becomes \"lee*cod*e\".\n    - The closest character to the 2nd star is 'e' in \"lee*cod*e\". s becomes \"lecod*e\".\n    - The closest character to the 3rd star is 'd' in \"lecod*e\". s becomes \"lecoe\".\n    There are no more stars, so we return \"lecoe\".\n    Example 2:\n\n    Input: s = \"erase*****\"\n    Output: \"\"\n    Explanation: The entire string is removed, so we return an empty string.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of lowercase English letters and stars *.\n    The operation above can be performed on s.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    for c in s:\n        if c == '*':\n            if result:\n                result.pop()\n        else:\n            result.append(c)\n    return ''.join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef longestNiceSubarray(nums: List[int]) -> int:\n    \"\"\"\n    You are given an array nums consisting of positive integers.\n    We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\n    Return the length of the longest nice subarray.\n    A subarray is a contiguous part of an array.\n    Note that subarrays of length 1 are always considered nice.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,8,48,10]\n    Output: 3\n    Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n    - 3 AND 8 = 0.\n    - 3 AND 48 = 0.\n    - 8 AND 48 = 0.\n    It can be proven that no longer nice subarray can be obtained, so we return 3.\n    Example 2:\n\n    Input: nums = [3,1,5,11,13]\n    Output: 1\n    Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    max_len = 1\n    for i in range(n):\n        mask = 0\n        for j in range(i, n):\n            mask |= nums[j]\n            if mask & (mask - 1) == 0:\n                max_len = max(max_len, j - i + 1)\n    return max_len\n\n"}
{"prompt": "from typing import List\n\n\ndef min_groups(intervals: List[List[int]]) -> int:\n    \"\"\"\n    You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].\n    You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.\n    Return the minimum number of groups you need to make.\n    Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.\n\u00a0\n    Example 1:\n\n    Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]\n    Output: 3\n    Explanation: We can divide the intervals into the following groups:\n    - Group 1: [1, 5], [6, 8].\n    - Group 2: [2, 3], [5, 10].\n    - Group 3: [1, 10].\n    It can be proven that it is not possible to divide the intervals into fewer than 3 groups.\n\n    Example 2:\n\n    Input: intervals = [[1,3],[5,6],[8,10],[11,13]]\n    Output: 1\n    Explanation: None of the intervals overlap, so we can put all of them in one group.\n\n\u00a0\n    Constraints:\n\n    1 <= intervals.length <= 105\n    intervals[i].length == 2\n    1 <= lefti <= righti <= 106\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    intervals.sort()\n    pq = []\n    for interval in intervals:\n        if pq and pq[0] < interval[0]:\n            heapq.heappop(pq)\n        heapq.heappush(pq, interval[1])\n    return len(pq)\n\n"}
{"prompt": "from typing import List\n\n\ndef findArray(pref: List[int]) -> List[int]:\n    \"\"\"\n    You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n    pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\n    Note that ^ denotes the bitwise-xor operation.\n    It can be proven that the answer is unique.\n\u00a0\n    Example 1:\n\n    Input: pref = [5,2,0,3,1]\n    Output: [5,7,2,3,2]\n    Explanation: From the array [5,7,2,3,2] we have the following:\n    - pref[0] = 5.\n    - pref[1] = 5 ^ 7 = 2.\n    - pref[2] = 5 ^ 7 ^ 2 = 0.\n    - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n    - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n    Example 2:\n\n    Input: pref = [13]\n    Output: [13]\n    Explanation: We have pref[0] = arr[0] = 13.\n\n\u00a0\n    Constraints:\n\n    1 <= pref.length <= 105\n    0 <= pref[i] <= 106\n\n    \"\"\"\n", "canonical_solution": "    arr = [pref[0]]\n    for i in range(1, len(pref)):\n        arr.append(pref[i] ^ pref[i - 1])\n    return arr\n\n"}
{"prompt": "def nthUglyNumber(n: int) -> int:\n    \"\"\"\n    An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n    Given an integer n, return the nth ugly number.\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 12\n    Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 1\n    Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 1690\n\n    \"\"\"\n", "canonical_solution": "    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2:\n            i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3:\n            i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5:\n            i5 += 1\n\n    return ugly_numbers[n - 1]\n\n"}
{"prompt": "from typing import List\n\n\ndef generate_parenthesis(n: int) -> List[str]:\n    \"\"\"\n    Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\u00a0\n    Example 1:\n    Input: n = 3\n    Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n    Example 2:\n    Input: n = 1\n    Output: [\"()\"]\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 8\n\n    \"\"\"\n", "canonical_solution": "    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef max_star_sum(vals: List[int], edges: List[List[int]], k: int) -> int:\n    \"\"\"\n    There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\n    You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\n    A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\n    The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\n    The star sum is the sum of the values of all the nodes present in the star graph.\n    Given an integer k, return the maximum star sum of a star graph containing at most k edges.\n\u00a0\n    Example 1:\n\n\n    Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n    Output: 16\n    Explanation: The above diagram represents the input graph.\n    The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\n    It can be shown it is not possible to get a star graph with a sum greater than 16.\n\n    Example 2:\n\n    Input: vals = [-5], edges = [], k = 0\n    Output: -5\n    Explanation: There is only one possible star graph, which is node 0 itself.\n    Hence, we return -5.\n\n\u00a0\n    Constraints:\n\n    n == vals.length\n    1 <= n <= 105\n    -104 <= vals[i] <= 104\n    0 <= edges.length <= min(n * (n - 1) / 2, 105)\n    edges[i].length == 2\n    0 <= ai, bi <= n - 1\n    ai != bi\n    0 <= k <= n - 1\n\n    \"\"\"\n", "canonical_solution": "    adj = [[] for _ in range(len(vals))]\n\n    for edge in edges:\n        adj[edge[0]].append(vals[edge[1]])\n        adj[edge[1]].append(vals[edge[0]])\n\n    ans = float(\"-inf\")\n    for i in range(len(vals)):\n        adj[i].sort(reverse=True)\n        ans = max(ans, vals[i] + sum(adj[i][:k]))\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef longest_square_streak(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. A subsequence of nums is called a square streak if:\n\n    The length of the subsequence is at least 2, and\n    after sorting the subsequence, each element (except the first element) is the square of the previous number.\n\n    Return the length of the longest square streak in nums, or return -1 if there is no square streak.\n    A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,3,6,16,8,2]\n    Output: 3\n    Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n    - 4 = 2 * 2.\n    - 16 = 4 * 4.\n    Therefore, [4,16,2] is a square streak.\n    It can be shown that every subsequence of length 4 is not a square streak.\n\n    Example 2:\n\n    Input: nums = [2,3,5,6,7]\n    Output: -1\n    Explanation: There is no square streak in nums so return -1.\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 105\n    2 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    num_set = set(nums)\n    longest_streak = -1\n\n    for num in num_set:\n        streak = 1\n\n        while int(num ** 0.5) in num_set:\n            streak += 1\n            num = int(num ** 0.5)\n\n        longest_streak = max(longest_streak, streak)\n\n    return longest_streak if longest_streak >= 2 else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef maxScore(nums1: List[int], nums2: List[int], k: int) -> int:\n    \"\"\"\n    You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\n    For chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\n    The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\n    It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n\n    Return the maximum possible score.\n    A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\n\u00a0\n    Example 1:\n\n    Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n    Output: 12\n    Explanation: \n    The four possible subsequence scores are:\n    - We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n    - We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n    - We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n    - We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\n    Therefore, we return the max score, which is 12.\n\n    Example 2:\n\n    Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n    Output: 30\n    Explanation: \n    Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.\n\n\u00a0\n    Constraints:\n\n    n == nums1.length == nums2.length\n    1 <= n <= 105\n    0 <= nums1[i], nums2[j] <= 105\n    1 <= k <= n\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums1)\n    res = 0\n    sum_n1 = 0\n    min_n2 = nums2[0]\n    i, j = 0, 0\n    while j < n:\n        sum_n1 += nums1[j]\n        min_n2 = min(min_n2, nums2[j])\n        if j - i + 1 > k:\n            sum_n1 -= nums1[i]\n            i += 1\n        if j + 1 >= k:\n            res = max(res, sum_n1 * min_n2)\n        j += 1\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef count_fair_pairs(nums: List[int], lower: int, upper: int) -> int:\n    \"\"\"\n    Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.\n    A pair (i, j) is fair if:\n\n    0 <= i < j < n, and\n    lower <= nums[i] + nums[j] <= upper\n\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6\n    Output: 6\n    Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).\n\n    Example 2:\n\n    Input: nums = [1,7,9,2,5], lower = 11, upper = 11\n    Output: 1\n    Explanation: There is a single fair pair: (2,3).\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums.length == n\n    -109\u00a0<= nums[i] <= 109\n    -109\u00a0<= lower <= upper <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    fair_pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lower <= nums[i] + nums[j] <= upper:\n                fair_pairs += 1\n    return fair_pairs\n\n"}
{"prompt": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcabcbb\"\n    Output: 3\n    Explanation: The answer is \"abc\", with the length of 3.\n\n    Example 2:\n\n    Input: s = \"bbbbb\"\n    Output: 1\n    Explanation: The answer is \"b\", with the length of 1.\n\n    Example 3:\n\n    Input: s = \"pwwkew\"\n    Output: 3\n    Explanation: The answer is \"wke\", with the length of 3.\n    Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\u00a0\n    Constraints:\n\n    0 <= s.length <= 5 * 104\n    s consists of English letters, digits, symbols and spaces.\n\n    \"\"\"\n", "canonical_solution": "    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n\n"}
{"prompt": "def numSquares(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the least number of perfect square numbers that sum to n.\n    A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\u00a0\n    Example 1:\n\n    Input: n = 12\n    Output: 3\n    Explanation: 12 = 4 + 4 + 4.\n\n    Example 2:\n\n    Input: n = 13\n    Output: 2\n    Explanation: 13 = 4 + 9.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 104\n\n    \"\"\"\n", "canonical_solution": "    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n\n    return dp[n]\n\n"}
{"prompt": "from typing import List\n\n\ndef findDuplicate(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums containing\u00a0n + 1 integers where each integer is in the range [1, n] inclusive.\n    There is only one repeated number in nums, return this\u00a0repeated\u00a0number.\n    You must solve the problem without modifying the array nums\u00a0and uses only constant extra space.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,4,2,2]\n    Output: 2\n\n    Example 2:\n\n    Input: nums = [3,1,3,4,2]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n    nums.length == n + 1\n    1 <= nums[i] <= n\n    All the integers in nums appear only once except for precisely one integer which appears two or more times.\n\n\u00a0\n    Follow up:\n\n    How can we prove that at least one duplicate number must exist in nums?\n    Can you solve the problem in linear runtime complexity?\n\n    \"\"\"\n", "canonical_solution": "    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n"}
{"prompt": "from typing import List\n\n\ndef gameOfLife(board: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    According to\u00a0Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n    The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n    Any live cell with fewer than two live neighbors dies as if caused by under-population.\n    Any live cell with two or three live neighbors lives on to the next generation.\n    Any live cell with more than three live neighbors dies, as if by over-population.\n    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n    The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.\n\u00a0\n    Example 1:\n\n\n    Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n    Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\n    Example 2:\n\n\n    Input: board = [[1,1],[1,0]]\n    Output: [[1,1],[1,1]]\n\n\u00a0\n    Constraints:\n\n    m == board.length\n    n == board[i].length\n    1 <= m, n <= 25\n    board[i][j] is 0 or 1.\n\n\u00a0\n    Follow up:\n\n    Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n    In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n\n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n\n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n\n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n\n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n\n    return result\n\n"}
{"prompt": "def get_hint(secret: str, guess: str) -> str:\n    \"\"\"\n    You are playing the Bulls and Cows game with your friend.\n    You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n    The number of \"bulls\", which are digits in the guess that are in the correct position.\n    The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\n    Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.\n    The hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\n\u00a0\n    Example 1:\n\n    Input: secret = \"1807\", guess = \"7810\"\n    Output: \"1A3B\"\n    Explanation: Bulls are connected with a '|' and cows are underlined:\n    \"1807\"\n      |\n    \"7810\"\n    Example 2:\n\n    Input: secret = \"1123\", guess = \"0111\"\n    Output: \"1A1B\"\n    Explanation: Bulls are connected with a '|' and cows are underlined:\n    \"1123\"        \"1123\"\n      |      or     |\n    \"0111\"        \"0111\"\n    Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n\n\u00a0\n    Constraints:\n\n    1 <= secret.length, guess.length <= 1000\n    secret.length == guess.length\n    secret and guess consist of digits only.\n\n    \"\"\"\n", "canonical_solution": "    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n\n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n\n    return f\"{bulls}A{cows}B\"\n\n"}
{"prompt": "from typing import List\n\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\u00a0\n    Example 1:\n\n    Input: nums = [10,9,2,5,3,7,101,18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n    Example 2:\n\n    Input: nums = [0,1,0,3,2,3]\n    Output: 4\n\n    Example 3:\n\n    Input: nums = [7,7,7,7,7,7,7]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2500\n    -104 <= nums[i] <= 104\n\n\u00a0\n    Follow up:\u00a0Can you come up with an algorithm that runs in\u00a0O(n log(n)) time complexity?\n    \"\"\"\n", "canonical_solution": "    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n\n"}
{"prompt": "def isAdditiveNumber(num: str) -> bool:\n    \"\"\"\n    An additive number is a string whose digits can form an additive sequence.\n    A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n    Given a string containing only digits, return true if it is an additive number or false otherwise.\n    Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\u00a0\n    Example 1:\n\n    Input: \"112358\"\n    Output: true\n    Explanation: \n    The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n    1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\n    Example 2:\n\n    Input: \"199100199\"\n    Output: true\n    Explanation: \n    The additive sequence is: 1, 99, 100, 199.\u00a0\n    1 + 99 = 100, 99 + 100 = 199\n\n\u00a0\n    Constraints:\n\n    1 <= num.length <= 35\n    num consists only of digits.\n\n\u00a0\n    Follow up: How would you handle overflow for very large input integers?\n    \"\"\"\n", "canonical_solution": "    def add(num1, num2):\n        carry, result = 0, []\n        i, j = len(num1) - 1, len(num2) - 1\n        while i >= 0 or j >= 0 or carry > 0:\n            n1 = int(num1[i]) if i >= 0 else 0\n            n2 = int(num2[j]) if j >= 0 else 0\n            _sum = n1 + n2 + carry\n            carry = _sum // 10\n            result.append(str(_sum % 10))\n            i, j = i - 1, j - 1\n        return ''.join(result[::-1])\n\n    def check(num1, num2, remaining):\n        if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n            return False\n        _sum = add(num1, num2)\n        if remaining == _sum:\n            return True\n        if not remaining.startswith(_sum):\n            return False\n        return check(num2, _sum, remaining[len(_sum):])\n    for i in range(1, len(num) // 2 + 1):\n        for j in range(1, (len(num) - i) // 2 + 1):\n            if check(num[:i], num[i:i+j], num[i+j:]):\n                return True\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef nthSuperUglyNumber(n: int, primes: List[int]) -> int:\n    \"\"\"\n    A super ugly number is a positive integer whose prime factors are in the array primes.\n    Given an integer n and an array of integers primes, return the nth super ugly number.\n    The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\u00a0\n    Example 1:\n\n    Input: n = 12, primes = [2,7,13,19]\n    Output: 32\n    Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n\n    Example 2:\n\n    Input: n = 1, primes = [2,3,5]\n    Output: 1\n    Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n    1 <= primes.length <= 100\n    2 <= primes[i] <= 1000\n    primes[i] is guaranteed to be a prime number.\n    All the values of primes are unique and sorted in ascending order.\n\n    \"\"\"\n", "canonical_solution": "    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n\n"}
{"prompt": "def removeDuplicateLetters(s: str) -> str:\n    \"\"\"\n    Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n\u00a0\n    Example 1:\n\n    Input: s = \"bcabc\"\n    Output: \"abc\"\n\n    Example 2:\n\n    Input: s = \"cbacdcbc\"\n    Output: \"acdb\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 104\n    s consists of lowercase English letters.\n\n\u00a0\n    Note: This question is the same as 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\n    \"\"\"\n", "canonical_solution": "    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxProduct(words: List[str]) -> int:\n    \"\"\"\n    Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\n\u00a0\n    Example 1:\n\n    Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\n    Output: 16\n    Explanation: The two words can be \"abcw\", \"xtfn\".\n\n    Example 2:\n\n    Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\n    Output: 4\n    Explanation: The two words can be \"ab\", \"cd\".\n\n    Example 3:\n\n    Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n    Output: 0\n    Explanation: No such pair of words.\n\n\u00a0\n    Constraints:\n\n    2 <= words.length <= 1000\n    1 <= words[i].length <= 1000\n    words[i] consists only of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n\n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n\n    return max_product\n\n"}
{"prompt": "def bulbSwitch(n: int) -> int:\n    \"\"\"\n    There are n bulbs that are initially off. You first turn on all the bulbs, then\u00a0you turn off every second bulb.\n    On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\n    Return the number of bulbs that are on after n rounds.\n\u00a0\n    Example 1:\n\n\n    Input: n = 3\n    Output: 1\n    Explanation: At first, the three bulbs are [off, off, off].\n    After the first round, the three bulbs are [on, on, on].\n    After the second round, the three bulbs are [on, off, on].\n    After the third round, the three bulbs are [on, off, off]. \n    So you should return 1 because there is only one bulb is on.\n    Example 2:\n\n    Input: n = 0\n    Output: 0\n\n    Example 3:\n\n    Input: n = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 109\n\n    \"\"\"\n", "canonical_solution": "    return int(n**0.5)\n\n"}
{"prompt": "from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -> int:\n    \"\"\"\n    You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n    Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n    You may assume that you have an infinite number of each kind of coin.\n\u00a0\n    Example 1:\n\n    Input: coins = [1,2,5], amount = 11\n    Output: 3\n    Explanation: 11 = 5 + 5 + 1\n\n    Example 2:\n\n    Input: coins = [2], amount = 3\n    Output: -1\n\n    Example 3:\n\n    Input: coins = [1], amount = 0\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= coins.length <= 12\n    1 <= coins[i] <= 231 - 1\n    0 <= amount <= 104\n\n    \"\"\"\n", "canonical_solution": "    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n\n"}
{"prompt": "def is_valid_serialization(preorder: str) -> bool:\n    \"\"\"\n    One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.\n\n    For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where '#' represents a null node.\n    Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.\n    It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer.\n    You may assume that the input format is always valid.\n\n    For example, it could never contain two consecutive commas, such as \"1,,3\".\n\n    Note:\u00a0You are not allowed to reconstruct the tree.\n\u00a0\n    Example 1:\n    Input: preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n    Output: true\n    Example 2:\n    Input: preorder = \"1,#\"\n    Output: false\n    Example 3:\n    Input: preorder = \"9,#,#,1\"\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= preorder.length <= 104\n    preorder consist of integers in the range [0, 100] and '#' separated by commas ','.\n\n    \"\"\"\n", "canonical_solution": "    nodes = preorder.split(',')\n    node_count = 1\n\n    for node in nodes:\n        node_count -= 1\n        if node_count < 0:\n            return False\n        if node != '#':\n            node_count += 2\n\n    return node_count == 0\n\n"}
{"prompt": "def divide(dividend: int, divisor: int) -> int:\n    \"\"\"\n    Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n    The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n    Return the quotient after dividing dividend by divisor.\n    Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\u00a0\n    Example 1:\n\n    Input: dividend = 10, divisor = 3\n    Output: 3\n    Explanation: 10/3 = 3.33333.. which is truncated to 3.\n\n    Example 2:\n\n    Input: dividend = 7, divisor = -3\n    Output: -2\n    Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n\u00a0\n    Constraints:\n\n    -231 <= dividend, divisor <= 231 - 1\n    divisor != 0\n\n    \"\"\"\n", "canonical_solution": "    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n\n"}
{"prompt": "def integer_break(n: int) -> int:\n    \"\"\"\n    Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n    Return the maximum product you can get.\n\u00a0\n    Example 1:\n\n    Input: n = 2\n    Output: 1\n    Explanation: 2 = 1 + 1, 1 \u00d7 1 = 1.\n\n    Example 2:\n\n    Input: n = 10\n    Output: 36\n    Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 58\n\n    \"\"\"\n", "canonical_solution": "    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n\n"}
{"prompt": "def countNumbersWithUniqueDigits(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\u00a0\n    Example 1:\n\n    Input: n = 2\n    Output: 91\n    Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n    Example 2:\n\n    Input: n = 0\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 8\n\n    \"\"\"\n", "canonical_solution": "    if n == 0:\n        return 1\n\n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n\n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n\n    return total\n\n"}
{"prompt": "def canMeasureWater(jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n    \"\"\"\n    You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.\n    If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.\n    Operations allowed:\n\n    Fill any of the jugs with water.\n    Empty any of the jugs.\n    Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.\n\n\u00a0\n    Example 1:\n\n    Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\n    Output: true\n    Explanation: The famous Die Hard example \n\n    Example 2:\n\n    Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\n    Output: false\n\n    Example 3:\n\n    Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\n    Output: true\n\n\u00a0\n    Constraints:\n\n    1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106\n\n    \"\"\"\n", "canonical_solution": "    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    if targetCapacity > jug1Capacity + jug2Capacity:\n        return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0\n\n"}
{"prompt": "from typing import List\n\n\ndef superPow(a: int, b: List[int]) -> int:\n    \"\"\"\n    Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n\u00a0\n    Example 1:\n\n    Input: a = 2, b = [3]\n    Output: 8\n\n    Example 2:\n\n    Input: a = 2, b = [1,0]\n    Output: 1024\n\n    Example 3:\n\n    Input: a = 1, b = [4,3,3,8,5,2]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= a <= 231 - 1\n    1 <= b.length <= 2000\n    0 <= b[i] <= 9\n    b does not contain leading zeros.\n\n    \"\"\"\n", "canonical_solution": "    def powmod(a, b):\n        if b == 0:\n            return 1\n        res = powmod(a, b // 2)\n        return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337\n    n = 0\n    for bi in b:\n        n = (n * 10 + bi) % 1140\n    return powmod(a % 1337, n + 1140)\n\n"}
{"prompt": "def getMoneyAmount(n: int) -> int:\n    \"\"\"\n    We are playing the Guessing Game. The game will work as follows:\n\n    I pick a number between\u00a01\u00a0and\u00a0n.\n    You guess a number.\n    If you guess the right number, you win the game.\n    If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.\n    Every time you guess a wrong number\u00a0x, you will pay\u00a0x\u00a0dollars. If you run out of money, you lose the game.\n\n    Given a particular\u00a0n, return\u00a0the minimum amount of money you need to\u00a0guarantee a win regardless of what number I pick.\n\u00a0\n    Example 1:\n\n\n    Input: n = 10\n    Output: 16\n    Explanation: The winning strategy is as follows:\n    - The range is [1,10]. Guess 7.\n    \u00a0   \u00a0   - If this is my number, your total is $0. Otherwise, you pay $7.\n    \u00a0   \u00a0   - If my number is higher, the range is [8,10]. Guess 9.\n    \u00a0       \u00a0       - If this is my number, your total is $7. Otherwise, you pay $9.\n    \u00a0       \u00a0       - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n    \u00a0       \u00a0       - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    \u00a0   \u00a0   - If my number is lower, the range is [1,6]. Guess 3.\n    \u00a0       \u00a0       - If this is my number, your total is $7. Otherwise, you pay $3.\n    \u00a0       \u00a0       - If my number is higher, the range is [4,6]. Guess 5.\n    \u00a0           \u00a0           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n    \u00a0           \u00a0           - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n    \u00a0           \u00a0           - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n    \u00a0       \u00a0       - If my number is lower, the range is [1,2]. Guess 1.\n    \u00a0           \u00a0           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n    \u00a0           \u00a0           - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\n    The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 0\n    Explanation:\u00a0There is only one possible number, so you can guess 1 and not have to pay anything.\n\n    Example 3:\n\n    Input: n = 2\n    Output: 1\n    Explanation:\u00a0There are two possible numbers, 1 and 2.\n    - Guess 1.\n    \u00a0   \u00a0   - If this is my number, your total is $0. Otherwise, you pay $1.\n    \u00a0   \u00a0   - If my number is higher, it must be 2. Guess 2. Your total is $1.\n    The worst case is that you pay $1.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 200\n\n    \"\"\"\n", "canonical_solution": "    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n\n"}
{"prompt": "from typing import List\n\n\ndef wiggleMaxLength(nums: List[int]) -> int:\n    \"\"\"\n    A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n    For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\n    In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\n    A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n    Given an integer array nums, return the length of the longest wiggle subsequence of nums.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,7,4,9,2,5]\n    Output: 6\n    Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n    Example 2:\n\n    Input: nums = [1,17,5,10,13,15,10,5,16,8]\n    Output: 7\n    Explanation: There are several subsequences that achieve this length.\n    One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n\n    Example 3:\n\n    Input: nums = [1,2,3,4,5,6,7,8,9]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    0 <= nums[i] <= 1000\n\n\u00a0\n    Follow up: Could you solve this in O(n) time?\n    \"\"\"\n", "canonical_solution": "    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n\n"}
{"prompt": "from typing import List\n\n\ndef kthSmallest(matrix: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.\n    Note that it is the kth smallest element in the sorted order, not the kth distinct element.\n    You must find a solution with a memory complexity better than O(n2).\n\u00a0\n    Example 1:\n\n    Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    Output: 13\n    Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13\n\n    Example 2:\n\n    Input: matrix = [[-5]], k = 1\n    Output: -5\n\n\u00a0\n    Constraints:\n\n    n == matrix.length == matrix[i].length\n    1 <= n <= 300\n    -109 <= matrix[i][j] <= 109\n    All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.\n    1 <= k <= n2\n\n\u00a0\n    Follow up:\n\n    Could you solve the problem with a constant memory (i.e., O(1) memory complexity)?\n    Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    n = len(matrix)\n    min_heap = []\n\n    for i in range(n):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n\n    while k > 1:\n        val, row, col = heapq.heappop(min_heap)\n\n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n\n        k -= 1\n\n    return min_heap[0][0]\n\n"}
{"prompt": "from typing import List\n\n\ndef lexical_order(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n    You must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.\u00a0\n\u00a0\n    Example 1:\n    Input: n = 13\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n    Example 2:\n    Input: n = 2\n    Output: [1,2]\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 5 * 104\n\n    \"\"\"\n", "canonical_solution": "    def lexicographical_order_helper(current, n, result):\n        if current > n:\n            return\n\n        result.append(current)\n        for i in range(10):\n            lexicographical_order_helper(current * 10 + i, n, result)\n    result = []\n    for i in range(1, 10):\n        lexicographical_order_helper(i, n, result)\n    return result\n\n"}
{"prompt": "def length_longest_path(input: str) -> int:\n    \"\"\"\n    Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\n    Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.\n    In text form, it looks like this (with \u27f6 representing the tab character):\n\n    dir\n    \u27f6 subdir1\n    \u27f6 \u27f6 file1.ext\n    \u27f6 \u27f6 subsubdir1\n    \u27f6 subdir2\n    \u27f6 \u27f6 subsubdir2\n    \u27f6 \u27f6 \u27f6 file2.ext\n\n    If we were to write this representation in code, it will look like this: \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\". Note that the '\\n' and '\\t' are the new-line and tab characters.\n    Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is \"dir/subdir2/subsubdir2/file2.ext\". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.\n    Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.\n    Note that the testcases are generated such that the file system is valid and no file or directory name has length 0.\n\u00a0\n    Example 1:\n\n\n    Input: input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"\n    Output: 20\n    Explanation: We have only one file, and the absolute path is \"dir/subdir2/file.ext\" of length 20.\n\n    Example 2:\n\n\n    Input: input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n    Output: 32\n    Explanation: We have two files:\n    \"dir/subdir1/file1.ext\" of length 21\n    \"dir/subdir2/subsubdir2/file2.ext\" of length 32.\n    We return 32 since it is the longest absolute path to a file.\n\n    Example 3:\n\n    Input: input = \"a\"\n    Output: 0\n    Explanation: We do not have any files, just a single directory named \"a\".\n\n\u00a0\n    Constraints:\n\n    1 <= input.length <= 104\n    input may contain lowercase or uppercase English letters, a new line character '\\n', a tab character '\\t', a dot '.', a space ' ', and digits.\n    All file and directory names have positive length.\n\n    \"\"\"\n", "canonical_solution": "    dir_length_stack = []\n    max_file_length = 0\n    lines = input.split('\\n')\n\n    for line in lines:\n        level = line.count('\\t')\n        line = line.lstrip('\\t')\n\n        while len(dir_length_stack) > level:\n            dir_length_stack.pop()\n\n        if dir_length_stack:\n            length = dir_length_stack[-1] + len(line) + 1\n        else:\n            length = len(line)\n        dir_length_stack.append(length)\n\n        if '.' in line:\n            max_file_length = max(max_file_length, length)\n\n    return max_file_length\n\n"}
{"prompt": "def last_remaining(n: int) -> int:\n    \"\"\"\n    You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:\n\n    Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n    Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n    Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\n    Given the integer n, return the last number that remains in arr.\n\u00a0\n    Example 1:\n\n    Input: n = 9\n    Output: 6\n    Explanation:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    arr = [2, 4, 6, 8]\n    arr = [2, 6]\n    arr = [6]\n\n    Example 2:\n\n    Input: n = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 109\n\n    \"\"\"\n", "canonical_solution": "    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head\n\n"}
{"prompt": "from typing import List\n\n\ndef validUtf8(data: List[int]) -> bool:\n    \"\"\"\n    Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n    A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\n    For a 1-byte character, the first bit is a 0, followed by its Unicode code.\n    For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.\n\n    This is how the UTF-8 encoding would work:\n\n         Number of Bytes   |        UTF-8 Octet Sequence\n                           |              (binary)\n       --------------------+-----------------------------------------\n                1          |   0xxxxxxx\n                2          |   110xxxxx 10xxxxxx\n                3          |   1110xxxx 10xxxxxx 10xxxxxx\n                4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n    x denotes a bit in the binary form of a byte that may be either 0 or 1.\n    Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\u00a0\n    Example 1:\n\n    Input: data = [197,130,1]\n    Output: true\n    Explanation: data represents the octet sequence: 11000101 10000010 00000001.\n    It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n    Example 2:\n\n    Input: data = [235,140,4]\n    Output: false\n    Explanation: data represented the octet sequence: 11101011 10001100 00000100.\n    The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n    The next byte is a continuation byte which starts with 10 and that's correct.\n    But the second continuation byte does not start with 10, so it is invalid.\n\n\u00a0\n    Constraints:\n\n    1 <= data.length <= 2 * 104\n    0 <= data[i] <= 255\n\n    \"\"\"\n", "canonical_solution": "    count = 0\n    for byte in data:\n        if count == 0:\n            if byte >> 5 == 0b110:\n                count = 1\n            elif byte >> 4 == 0b1110:\n                count = 2\n            elif byte >> 3 == 0b11110:\n                count = 3\n            elif byte >> 7:\n                return False\n        else:\n            if byte >> 6 != 0b10:\n                return False\n            count -= 1\n    return count == 0\n\n"}
{"prompt": "def decodeString(s: str) -> str:\n    \"\"\"\n    Given an encoded string, return its decoded string.\n    The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n    You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\n    The test cases are generated so that the length of the output will never exceed 105.\n\u00a0\n    Example 1:\n\n    Input: s = \"3[a]2[bc]\"\n    Output: \"aaabcbc\"\n\n    Example 2:\n\n    Input: s = \"3[a2[c]]\"\n    Output: \"accaccacc\"\n\n    Example 3:\n\n    Input: s = \"2[abc]3[cd]ef\"\n    Output: \"abcabccdcdcdef\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 30\n    s consists of lowercase English letters, digits, and square brackets '[]'.\n    s is guaranteed to be a valid input.\n    All the integers in s are in the range [1, 300].\n\n    \"\"\"\n", "canonical_solution": "    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n\n"}
{"prompt": "def longestSubstring(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\n    if no such substring exists, return 0.\n\u00a0\n    Example 1:\n\n    Input: s = \"aaabb\", k = 3\n    Output: 3\n    Explanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.\n\n    Example 2:\n\n    Input: s = \"ababbc\", k = 2\n    Output: 5\n    Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 104\n    s consists of only lowercase English letters.\n    1 <= k <= 105\n\n    \"\"\"\n", "canonical_solution": "    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxRotateFunction(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums of length n.\n    Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n\n    F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n\n    Return the maximum value of F(0), F(1), ..., F(n-1).\n    The test cases are generated so that the answer fits in a 32-bit integer.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,3,2,6]\n    Output: 26\n    Explanation:\n    F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n    F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n    F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n    F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n    So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n\n    Example 2:\n\n    Input: nums = [100]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 105\n    -100 <= nums[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f\n\n"}
{"prompt": "from typing import List\n\n\ndef calcEquation(equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n    \"\"\"\n    You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n    You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n    Return the answers to all queries. If a single answer cannot be determined, return -1.0.\n    Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n    Note:\u00a0The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\u00a0\n    Example 1:\n\n    Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n    Explanation: \n    Given: a / b = 2.0, b / c = 3.0\n    queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \n    return: [6.0, 0.5, -1.0, 1.0, -1.0 ]\n    note: x is undefined => -1.0\n    Example 2:\n\n    Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    Output: [3.75000,0.40000,5.00000,0.20000]\n\n    Example 3:\n\n    Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    Output: [0.50000,2.00000,-1.00000,-1.00000]\n\n\u00a0\n    Constraints:\n\n    1 <= equations.length <= 20\n    equations[i].length == 2\n    1 <= Ai.length, Bi.length <= 5\n    values.length == equations.length\n    0.0 < values[i] <= 20.0\n    1 <= queries.length <= 20\n    queries[i].length == 2\n    1 <= Cj.length, Dj.length <= 5\n    Ai, Bi, Cj, Dj consist of lower case English letters and digits.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n\n    def dfs(s1, s2, graph):\n        if s1 not in graph or s2 not in graph:\n            return -1.0\n        if s1 == s2:\n            return 1.0\n\n        for neighbor, weight in graph[s1]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                temp = dfs(neighbor, s2, graph)\n                if temp > 0:\n                    return weight * temp\n        return -1.0\n    graph = defaultdict(list)\n    for (s1, s2), value in zip(equations, values):\n        graph[s1].append((s2, value))\n        graph[s2].append((s1, 1 / value))\n\n    ans = []\n    for s1, s2 in queries:\n        visited = set()\n        ans.append(dfs(s1, s2, graph))\n    return ans\n\n"}
{"prompt": "def findNthDigit(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n\u00a0\n    Example 1:\n\n    Input: n = 3\n    Output: 3\n\n    Example 2:\n\n    Input: n = 11\n    Output: 0\n    Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])\n\n"}
{"prompt": "from typing import List\n\n\ndef searchRange(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n    If target is not found in the array, return [-1, -1].\n    You must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.\n\u00a0\n    Example 1:\n    Input: nums = [5,7,7,8,8,10], target = 8\n    Output: [3,4]\n    Example 2:\n    Input: nums = [5,7,7,8,8,10], target = 6\n    Output: [-1,-1]\n    Example 3:\n    Input: nums = [], target = 0\n    Output: [-1,-1]\n\n\u00a0\n    Constraints:\n\n    0 <= nums.length <= 105\n    -109\u00a0<= nums[i]\u00a0<= 109\n    nums is a non-decreasing array.\n    -109\u00a0<= target\u00a0<= 109\n\n    \"\"\"\n", "canonical_solution": "    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n\n    return [start, end]\n\n"}
{"prompt": "from typing import List\n\n\ndef canPartition(nums: List[int]) -> bool:\n    \"\"\"\n    Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,5,11,5]\n    Output: true\n    Explanation: The array can be partitioned as [1, 5, 5] and [11].\n\n    Example 2:\n\n    Input: nums = [1,2,3,5]\n    Output: false\n    Explanation: The array cannot be partitioned into equal sum subsets.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 200\n    1 <= nums[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[target]\n\n"}
{"prompt": "from typing import List\n\n\ndef pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n    The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\n    The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n    Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\n\u00a0\n    Example 1:\n\n\n    Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n    Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n    Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n    [0,4]: [0,4] -> Pacific Ocean \n    \u00a0      \u00a0      [0,4] -> Atlantic Ocean\n    [1,3]: [1,3] -> [0,3] -> Pacific Ocean \n    \u00a0      \u00a0      [1,3] -> [1,4] -> Atlantic Ocean\n    [1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n    \u00a0      \u00a0      [1,4] -> Atlantic Ocean\n    [2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n    \u00a0      \u00a0      [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n    [3,0]: [3,0] -> Pacific Ocean \n    \u00a0      \u00a0      [3,0] -> [4,0] -> Atlantic Ocean\n    [3,1]: [3,1] -> [3,0] -> Pacific Ocean \n    \u00a0      \u00a0      [3,1] -> [4,1] -> Atlantic Ocean\n    [4,0]: [4,0] -> Pacific Ocean \n           [4,0] -> Atlantic Ocean\n    Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n    Example 2:\n\n    Input: heights = [[1]]\n    Output: [[0,0]]\n    Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\u00a0\n    Constraints:\n\n    m == heights.length\n    n == heights[r].length\n    1 <= m, n <= 200\n    0 <= heights[r][c] <= 105\n\n    \"\"\"\n", "canonical_solution": "    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef countBattleships(board: List[List[str]]) -> int:\n    \"\"\"\n    Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\n    Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\u00a0\n    Example 1:\n\n\n    Input: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n    Output: 2\n\n    Example 2:\n\n    Input: board = [[\".\"]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    m == board.length\n    n == board[i].length\n    1 <= m, n <= 200\n    board[i][j] is either '.' or 'X'.\n\n\u00a0\n    Follow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board?\n    \"\"\"\n", "canonical_solution": "    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                    (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef findMaximumXOR(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,10,5,25,2,8]\n    Output: 28\n    Explanation: The maximum result is 5 XOR 25 = 28.\n\n    Example 2:\n\n    Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n    Output: 127\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2 * 105\n    0 <= nums[i] <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor\n\n"}
{"prompt": "from typing import List\n\n\ndef isValidSudoku(board: List[List[str]]) -> bool:\n    \"\"\"\n    Determine if a\u00a09 x 9 Sudoku board\u00a0is valid.\u00a0Only the filled cells need to be validated\u00a0according to the following rules:\n\n    Each row\u00a0must contain the\u00a0digits\u00a01-9 without repetition.\n    Each column must contain the digits\u00a01-9\u00a0without repetition.\n    Each of the nine\u00a03 x 3 sub-boxes of the grid must contain the digits\u00a01-9\u00a0without repetition.\n\n    Note:\n\n    A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n    Only the filled cells need to be validated according to the mentioned\u00a0rules.\n\n\u00a0\n    Example 1:\n\n\n    Input: board = \n    [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n    Output: true\n\n    Example 2:\n\n    Input: board = \n    [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n    Output: false\n    Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\u00a0\n    Constraints:\n\n    board.length == 9\n    board[i].length == 9\n    board[i][j] is a digit 1-9 or '.'.\n\n    \"\"\"\n", "canonical_solution": "    seen = set()\n\n    for i in range(9):\n        for j in range(9):\n            current_val = board[i][j]\n\n            if current_val != '.':\n                row = f\"{current_val} in row {i}\"\n                col = f\"{current_val} in col {j}\"\n                box = f\"{current_val} in box {i // 3}-{j // 3}\"\n\n                if row in seen or col in seen or box in seen:\n                    return False\n\n                seen.add(row)\n                seen.add(col)\n                seen.add(box)\n\n    return True\n\n"}
{"prompt": "def characterReplacement(s: str, k: int) -> int:\n    \"\"\"\n    You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\n    Return the length of the longest substring containing the same letter you can get after performing the above operations.\n\u00a0\n    Example 1:\n\n    Input: s = \"ABAB\", k = 2\n    Output: 4\n    Explanation: Replace the two 'A's with two 'B's or vice versa.\n\n    Example 2:\n\n    Input: s = \"AABABBA\", k = 1\n    Output: 4\n    Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\n    The substring \"BBBB\" has the longest repeating letters, which is 4.\n    There may exists other ways to achive this answer too.\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s consists of only uppercase English letters.\n    0 <= k <= s.length\n\n    \"\"\"\n", "canonical_solution": "    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef findRightInterval(intervals: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n    The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\n    Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\n\u00a0\n    Example 1:\n\n    Input: intervals = [[1,2]]\n    Output: [-1]\n    Explanation: There is only one interval in the collection, so it outputs -1.\n\n    Example 2:\n\n    Input: intervals = [[3,4],[2,3],[1,2]]\n    Output: [-1,0,1]\n    Explanation: There is no right interval for [3,4].\n    The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\n    The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\n\n    Example 3:\n\n    Input: intervals = [[1,4],[2,3],[3,4]]\n    Output: [-1,2,-1]\n    Explanation: There is no right interval for [1,4] and [3,4].\n    The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\n\n\u00a0\n    Constraints:\n\n    1 <= intervals.length <= 2 * 104\n    intervals[i].length == 2\n    -106 <= starti <= endi <= 106\n    The start point of each interval is unique.\n\n    \"\"\"\n", "canonical_solution": "    starts = {interval[0]: index for index, interval in enumerate(intervals)}\n    res = []\n\n    for interval in intervals:\n        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)\n        res.append(starts[right] if right != -1 else -1)\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef find_anagrams(s: str, p: str) -> List[int]:\n    \"\"\"\n    Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\n    An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\u00a0\n    Example 1:\n\n    Input: s = \"cbaebabacd\", p = \"abc\"\n    Output: [0,6]\n    Explanation:\n    The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\n    The substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n\n    Example 2:\n\n    Input: s = \"abab\", p = \"ab\"\n    Output: [0,1,2]\n    Explanation:\n    The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\n    The substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\n    The substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length, p.length <= 3 * 104\n    s and p consist of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    if len(s) < len(p):\n        return []\n\n    s_count = [0] * 26\n    p_count = [0] * 26\n    for c in p:\n        p_count[ord(c) - ord('a')] += 1\n\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef find_duplicates(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.\n    You must write an algorithm that runs in\u00a0O(n)\u00a0time and uses only constant extra space.\n\u00a0\n    Example 1:\n    Input: nums = [4,3,2,7,8,2,3,1]\n    Output: [2,3]\n    Example 2:\n    Input: nums = [1,1,2]\n    Output: [1]\n    Example 3:\n    Input: nums = [1]\n    Output: []\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 105\n    1 <= nums[i] <= n\n    Each element in nums appears once or twice.\n\n    \"\"\"\n", "canonical_solution": "    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n\n"}
{"prompt": "from typing import List\n\n\ndef compress(chars: List[str]) -> int:\n    \"\"\"\n    Given an array of characters chars, compress it using the following algorithm:\n    Begin with an empty string s. For each group of consecutive repeating characters in chars:\n\n    If the group's length is 1, append the character to s.\n    Otherwise, append the character followed by the group's length.\n\n    The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\n    After you are done modifying the input array, return the new length of the array.\n    You must write an algorithm that uses only constant extra space.\n\u00a0\n    Example 1:\n\n    Input: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n    Output: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n    Explanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n\n    Example 2:\n\n    Input: chars = [\"a\"]\n    Output: Return 1, and the first character of the input array should be: [\"a\"]\n    Explanation: The only group is \"a\", which remains uncompressed since it's a single character.\n\n    Example 3:\n\n    Input: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n    Output: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n    Explanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n\u00a0\n    Constraints:\n\n    1 <= chars.length <= 2000\n    chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.\n\n    \"\"\"\n", "canonical_solution": "    index, i = 0, 0\n\n    while i < len(chars):\n        count = 1\n        while i + count < len(chars) and chars[i] == chars[i + count]:\n            count += 1\n\n        chars[index] = chars[i]\n        index += 1\n\n        if count > 1:\n            count_str = str(count)\n            for c in count_str:\n                chars[index] = c\n                index += 1\n\n        i += count\n\n    return index\n\n"}
{"prompt": "from typing import Union, List\n\n\ndef numberOfBoomerangs(points: List[Union[List[int], List[float]]]) -> int:\n    \"\"\"\n    You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\n    Return the number of boomerangs.\n\u00a0\n    Example 1:\n\n    Input: points = [[0,0],[1,0],[2,0]]\n    Output: 2\n    Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].\n\n    Example 2:\n\n    Input: points = [[1,1],[2,2],[3,3]]\n    Output: 2\n\n    Example 3:\n\n    Input: points = [[1,1]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == points.length\n    1 <= n <= 500\n    points[i].length == 2\n    -104 <= xi, yi <= 104\n    All the points are unique.\n\n    \"\"\"\n", "canonical_solution": "    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n\n"}
{"prompt": "def count_and_say(n: int) -> str:\n    \"\"\"\n    The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n    countAndSay(1) = \"1\"\n    countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\n    To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n    For example, the saying and conversion for digit string \"3322251\":\n\n    Given a positive integer n, return the nth term of the count-and-say sequence.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: \"1\"\n    Explanation: This is the base case.\n\n    Example 2:\n\n    Input: n = 4\n    Output: \"1211\"\n    Explanation:\n    countAndSay(1) = \"1\"\n    countAndSay(2) = say \"1\" = one 1 = \"11\"\n    countAndSay(3) = say \"11\" = two 1's = \"21\"\n    countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 30\n\n    \"\"\"\n", "canonical_solution": "    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef min_moves(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\n    In one move, you can increment n - 1 elements of the array by 1.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3]\n    Output: 3\n    Explanation: Only three moves are needed (remember each move increments two elements):\n    [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n\n    Example 2:\n\n    Input: nums = [1,1,1]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n    The answer is guaranteed to fit in a 32-bit integer.\n\n    \"\"\"\n", "canonical_solution": "    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves\n\n"}
{"prompt": "from typing import List\n\n\ndef fourSumCount(nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n    \"\"\"\n    Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\n    0 <= i, j, k, l < n\n    nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n\n\u00a0\n    Example 1:\n\n    Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n    Output: 2\n    Explanation:\n    The two tuples are:\n    1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n    2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n\n    Example 2:\n\n    Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    n == nums1.length\n    n == nums2.length\n    n == nums3.length\n    n == nums4.length\n    1 <= n <= 200\n    -228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228\n\n    \"\"\"\n", "canonical_solution": "    hashMap = {}\n    count = 0\n\n    for i in nums1:\n        for j in nums2:\n            hashMap[i + j] = hashMap.get(i + j, 0) + 1\n\n    for k in nums3:\n        for l in nums4:\n            count += hashMap.get(-(k + l), 0)\n\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef find132pattern(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\n    Return true if there is a 132 pattern in nums, otherwise, return false.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3,4]\n    Output: false\n    Explanation: There is no 132 pattern in the sequence.\n\n    Example 2:\n\n    Input: nums = [3,1,4,2]\n    Output: true\n    Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n\n    Example 3:\n\n    Input: nums = [-1,3,2,0]\n    Output: true\n    Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 2 * 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef min_moves2(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\n    In one move, you can increment or decrement an element of the array by 1.\n    Test cases are designed so that the answer will fit in a 32-bit integer.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3]\n    Output: 2\n    Explanation:\n    Only two moves are needed (remember each move increments or decrements one element):\n    [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n\n    Example 2:\n\n    Input: nums = [1,10,2,9]\n    Output: 16\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    mid = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - mid)\n    return moves\n\n"}
{"prompt": "from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n    The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n    The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\u00a0\n    Example 1:\n\n    Input: candidates = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n    Explanation:\n    2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n    7 is a candidate, and 7 = 7.\n    These are the only two combinations.\n\n    Example 2:\n\n    Input: candidates = [2,3,5], target = 8\n    Output: [[2,2,2,2],[2,3,3],[3,5]]\n\n    Example 3:\n\n    Input: candidates = [2], target = 1\n    Output: []\n\n\u00a0\n    Constraints:\n\n    1 <= candidates.length <= 30\n    2 <= candidates[i] <= 40\n    All elements of candidates are distinct.\n    1 <= target <= 40\n\n    \"\"\"\n", "canonical_solution": "    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n\n        return result\n\n    return findCombinations(0, target)\n\n"}
{"prompt": "def canIWin(maxChoosableInteger: int, desiredTotal: int) -> bool:\n    \"\"\"\n    In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n    What if we change the game so that players cannot re-use integers?\n    For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n    Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\u00a0\n    Example 1:\n\n    Input: maxChoosableInteger = 10, desiredTotal = 11\n    Output: false\n    Explanation:\n    No matter which integer the first player choose, the first player will lose.\n    The first player can choose an integer from 1 up to 10.\n    If the first player choose 1, the second player can only choose integers from 2 up to 10.\n    The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n    Same with other integers chosen by the first player, the second player will always win.\n\n    Example 2:\n\n    Input: maxChoosableInteger = 10, desiredTotal = 0\n    Output: true\n\n    Example 3:\n\n    Input: maxChoosableInteger = 10, desiredTotal = 1\n    Output: true\n\n\u00a0\n    Constraints:\n\n    1 <= maxChoosableInteger <= 20\n    0 <= desiredTotal <= 300\n\n    \"\"\"\n", "canonical_solution": "    if maxChoosableInteger >= desiredTotal:\n        return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n        return False\n\n    memo = {}\n\n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n\n        memo[state] = False\n        return False\n\n    return canWin(0)\n\n"}
{"prompt": "from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\u00a0where the candidate numbers sum to target.\n    Each number in candidates\u00a0may only be used once in the combination.\n    Note:\u00a0The solution set must not contain duplicate combinations.\n\u00a0\n    Example 1:\n\n    Input: candidates = [10,1,2,7,6,1,5], target = 8\n    Output: \n    [\n    [1,1,6],\n    [1,2,5],\n    [1,7],\n    [2,6]\n    ]\n\n    Example 2:\n\n    Input: candidates = [2,5,2,1,2], target = 5\n    Output: \n    [\n    [1,2,2],\n    [5]\n    ]\n\n\u00a0\n    Constraints:\n\n    1 <=\u00a0candidates.length <= 100\n    1 <=\u00a0candidates[i] <= 50\n    1 <= target <= 30\n\n    \"\"\"\n", "canonical_solution": "    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef makesquare(matchsticks: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n    Return true if you can make this square and false otherwise.\n\u00a0\n    Example 1:\n\n\n    Input: matchsticks = [1,1,2,2,2]\n    Output: true\n    Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n\n    Example 2:\n\n    Input: matchsticks = [3,3,3,3,4]\n    Output: false\n    Explanation: You cannot find a way to form a square with all the matchsticks.\n\n\u00a0\n    Constraints:\n\n    1 <= matchsticks.length <= 15\n    1 <= matchsticks[i] <= 108\n\n    \"\"\"\n", "canonical_solution": "    from itertools import chain\n\n    def dfs(matchsticks, sums, target, index):\n        if index == len(matchsticks):\n            return sums[0] == target and sums[1] == target and sums[2] == target\n        for i in range(4):\n            if sums[i] + matchsticks[index] <= target:\n                sums[i] += matchsticks[index]\n                if dfs(matchsticks, sums, target, index + 1):\n                    return True\n                sums[i] -= matchsticks[index]\n        return False\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\n"}
{"prompt": "from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -> int:\n    \"\"\"\n    You are given an array of binary strings strs and two integers m and n.\n    Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\n    A set x is a subset of a set y if all elements of x are also elements of y.\n\u00a0\n    Example 1:\n\n    Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    Output: 4\n    Explanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\n    Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n    {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n\n    Example 2:\n\n    Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    Output: 2\n    Explanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n\n\u00a0\n    Constraints:\n\n    1 <= strs.length <= 600\n    1 <= strs[i].length <= 100\n    strs[i] consists only of digits '0' and '1'.\n    1 <= m, n <= 100\n\n    \"\"\"\n", "canonical_solution": "    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    return dp[m][n]\n\n"}
{"prompt": "from typing import List\n\n\ndef findRadius(houses: List[int], heaters: List[int]) -> int:\n    \"\"\"\n    Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\n    Every house can be warmed, as long as the house is within the heater's warm radius range.\u00a0\n    Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters\u00a0so that those heaters could cover all houses.\n    Notice that\u00a0all the heaters follow your radius standard, and the warm radius will the same.\n\u00a0\n    Example 1:\n\n    Input: houses = [1,2,3], heaters = [2]\n    Output: 1\n    Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n\n    Example 2:\n\n    Input: houses = [1,2,3,4], heaters = [1,4]\n    Output: 1\n    Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n    Example 3:\n\n    Input: houses = [1,5], heaters = [2]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= houses.length, heaters.length <= 3 * 104\n    1 <= houses[i], heaters[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    houses.sort()\n    heaters.sort()\n    result, i = 0, 0\n\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        result = max(result, abs(heaters[i] - house))\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef total_hamming_distance(nums: List[int]) -> int:\n    \"\"\"\n    The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n    Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,14,2]\n    Output: 6\n    Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n    showing the four bits relevant in this case).\n    The answer will be:\n    HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n\n    Example 2:\n\n    Input: nums = [4,14,4]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    0 <= nums[i] <= 109\n    The answer for the given input will fit in a 32-bit integer.\n\n    \"\"\"\n", "canonical_solution": "    total_distance = 0\n    n = len(nums)\n\n    for i in range(32):\n        bit_count = sum(((num >> i) & 1) for num in nums)\n        total_distance += bit_count * (n - bit_count)\n\n    return total_distance\n\n"}
{"prompt": "def magical_string(n: int) -> int:\n    \"\"\"\n    A magical string s consists of only '1' and '2' and obeys the following rules:\n\n    The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\n    The first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\n    Given an integer n, return the number of 1's in the first n number in the magical string s.\n\u00a0\n    Example 1:\n\n    Input: n = 6\n    Output: 3\n    Explanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 105\n\n    \"\"\"\n", "canonical_solution": "    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones\n\n"}
{"prompt": "from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -> int:\n    \"\"\"\n    You are given an integer array nums and an integer target.\n    You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\n    For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\n    Return the number of different expressions that you can build, which evaluates to target.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1,1,1], target = 3\n    Output: 5\n    Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n    -1 + 1 + 1 + 1 + 1 = 3\n    +1 - 1 + 1 + 1 + 1 = 3\n    +1 + 1 - 1 + 1 + 1 = 3\n    +1 + 1 + 1 - 1 + 1 = 3\n    +1 + 1 + 1 + 1 - 1 = 3\n\n    Example 2:\n\n    Input: nums = [1], target = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 20\n    0 <= nums[i] <= 1000\n    0 <= sum(nums[i]) <= 1000\n    -1000 <= target <= 1000\n\n    \"\"\"\n", "canonical_solution": "    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n\n"}
{"prompt": "from typing import List\n\n\ndef nextGreaterElements(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\n    The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,1]\n    Output: [2,-1,2]\n    Explanation: The first 1's next greater number is 2; \n    The number 2 can't find next greater number. \n    The second 1's next greater number needs to search circularly, which is also 2.\n\n    Example 2:\n\n    Input: nums = [1,2,3,4,3]\n    Output: [2,3,4,-1,4]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    -109 <= nums[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    result = [-1] * len(nums)\n    stack = []\n\n    for i in range(len(nums) * 2):\n        index = i % len(nums)\n        while stack and nums[stack[-1]] < nums[index]:\n            result[stack.pop()] = nums[index]\n        if i < len(nums):\n            stack.append(index)\n\n    return result\n\n"}
{"prompt": "def longestPalindromeSubseq(s: str) -> int:\n    \"\"\"\n    Given a string s, find the longest palindromic subsequence's length in s.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\n    Example 1:\n\n    Input: s = \"bbbab\"\n    Output: 4\n    Explanation: One possible longest palindromic subsequence is \"bbbb\".\n\n    Example 2:\n\n    Input: s = \"cbbd\"\n    Output: 2\n    Explanation: One possible longest palindromic subsequence is \"bb\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    s consists only of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n\n"}
{"prompt": "from typing import List\n\n\ndef change(amount: int, coins: List[int]) -> int:\n    \"\"\"\n    You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n    Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n    You may assume that you have an infinite number of each kind of coin.\n    The answer is guaranteed to fit into a signed 32-bit integer.\n\u00a0\n    Example 1:\n\n    Input: amount = 5, coins = [1,2,5]\n    Output: 4\n    Explanation: there are four ways to make up the amount:\n    5=5\n    5=2+2+1\n    5=2+1+1+1\n    5=1+1+1+1+1\n\n    Example 2:\n\n    Input: amount = 3, coins = [2]\n    Output: 0\n    Explanation: the amount of 3 cannot be made up just with coins of 2.\n\n    Example 3:\n\n    Input: amount = 10, coins = [10]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= coins.length <= 300\n    1 <= coins[i] <= 5000\n    All the values of coins are unique.\n    0 <= amount <= 5000\n\n    \"\"\"\n", "canonical_solution": "    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n\n"}
{"prompt": "from typing import List\n\n\ndef checkSubarraySum(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\n    A good subarray is a subarray where:\n\n    its length is at least two, and\n    the sum of the elements of the subarray is a multiple of k.\n\n    Note that:\n\n    A subarray is a contiguous part of the array.\n    An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\n\n\u00a0\n    Example 1:\n\n    Input: nums = [23,2,4,6,7], k = 6\n    Output: true\n    Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\n    Example 2:\n\n    Input: nums = [23,2,6,4,7], k = 6\n    Output: true\n    Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n    42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\n    Example 3:\n\n    Input: nums = [23,2,6,4,7], k = 13\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    0 <= nums[i] <= 109\n    0 <= sum(nums[i]) <= 231 - 1\n    1 <= k <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    n, sum_ = len(nums), 0\n    mp = {0: -1}\n    for i, num in enumerate(nums):\n        sum_ += num\n        if k != 0:\n            sum_ %= k\n        if sum_ in mp:\n            if i - mp[sum_] > 1:\n                return True\n        else:\n            mp[sum_] = i\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef findLongestWord(s: str, dictionary: List[str]) -> str:\n    \"\"\"\n    Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n\u00a0\n    Example 1:\n\n    Input: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n    Output: \"apple\"\n\n    Example 2:\n\n    Input: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n    Output: \"a\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    1 <= dictionary.length <= 1000\n    1 <= dictionary[i].length <= 1000\n    s and dictionary[i] consist of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    def is_subsequence(target, source):\n        iter_source = iter(source)\n        return all(char in iter_source for char in target)\n\n    dictionary = sorted(dictionary)\n    longest = ''\n    for word in dictionary:\n        if is_subsequence(word, s) and len(word) > len(longest):\n            longest = word\n    return longest\n\n"}
{"prompt": "from typing import List\n\n\ndef findMaxLength(nums: List[int]) -> int:\n    \"\"\"\n    Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1]\n    Output: 2\n    Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\n    Example 2:\n\n    Input: nums = [0,1,0]\n    Output: 2\n    Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len\n\n"}
{"prompt": "from typing import List\n\n\ndef jump(nums: List[int]) -> int:\n    \"\"\"\n    You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n    Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n    0 <= j <= nums[i] and\n    i + j < n\n\n    Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n\u00a0\n    Example 1:\n\n    Input: nums = [2,3,1,1,4]\n    Output: 2\n    Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n    Example 2:\n\n    Input: nums = [2,3,0,1,4]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    0 <= nums[i] <= 1000\n    It's guaranteed that you can reach nums[n - 1].\n\n    \"\"\"\n", "canonical_solution": "    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n\n"}
{"prompt": "def complexNumberMultiply(num1: str, num2: str) -> str:\n    \"\"\"\n    A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\n    real is the real part and is an integer in the range [-100, 100].\n    imaginary is the imaginary part and is an integer in the range [-100, 100].\n    i2 == -1.\n\n    Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\n\u00a0\n    Example 1:\n\n    Input: num1 = \"1+1i\", num2 = \"1+1i\"\n    Output: \"0+2i\"\n    Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n\n    Example 2:\n\n    Input: num1 = \"1+-1i\", num2 = \"1+-1i\"\n    Output: \"0+-2i\"\n    Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n\n\u00a0\n    Constraints:\n\n    num1 and num2 are valid complex numbers.\n\n    \"\"\"\n", "canonical_solution": "    real1, imag1 = map(int, num1[:-1].split('+'))\n    real2, imag2 = map(int, num2[:-1].split('+'))\n\n    real = real1 * real2 - imag1 * imag2\n    imag = real1 * imag2 + real2 * imag1\n\n    return f\"{real}+{imag}i\"\n\n"}
{"prompt": "from typing import List\n\n\ndef findMinDifference(timePoints: List[str]) -> int:\n    \"\"\"\n    Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.\n\u00a0\n    Example 1:\n    Input: timePoints = [\"23:59\",\"00:00\"]\n    Output: 1\n    Example 2:\n    Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    2 <= timePoints.length <= 2 * 104\n    timePoints[i] is in the format \"HH:MM\".\n\n    \"\"\"\n", "canonical_solution": "    timePoints.sort()\n    min_difference = float('inf')\n\n    for i in range(len(timePoints)):\n        h1, m1 = map(int, timePoints[i].split(':'))\n        h2, m2 = map(int, timePoints[(i+1) % len(timePoints)].split(':'))\n        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))\n        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)\n\n    return min_difference\n\n"}
{"prompt": "from typing import List\n\n\ndef singleNonDuplicate(nums: List[int]) -> int:\n    \"\"\"\n    You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n    Return the single element that appears only once.\n    Your solution must run in O(log n) time and O(1) space.\n\u00a0\n    Example 1:\n    Input: nums = [1,1,2,3,3,4,4,8,8]\n    Output: 2\n    Example 2:\n    Input: nums = [3,3,7,7,10,11,11]\n    Output: 10\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    0 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]\n\n"}
{"prompt": "from typing import List\n\n\ndef updateMatrix(mat: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n    The distance between two adjacent cells is 1.\n\u00a0\n    Example 1:\n\n\n    Input: mat = [[0,0,0],[0,1,0],[0,0,0]]\n    Output: [[0,0,0],[0,1,0],[0,0,0]]\n\n    Example 2:\n\n\n    Input: mat = [[0,0,0],[0,1,0],[1,1,1]]\n    Output: [[0,0,0],[0,1,0],[1,2,1]]\n\n\u00a0\n    Constraints:\n\n    m == mat.length\n    n == mat[i].length\n    1 <= m, n <= 104\n    1 <= m * n <= 104\n    mat[i][j] is either 0 or 1.\n    There is at least one 0 in mat.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance\n\n"}
{"prompt": "from typing import List\n\n\ndef findCircleNum(isConnected: List[List[int]]) -> int:\n    \"\"\"\n    There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n    A province is a group of directly or indirectly connected cities and no other cities outside of the group.\n    You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n    Return the total number of provinces.\n\u00a0\n    Example 1:\n\n\n    Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n    Output: 2\n\n    Example 2:\n\n\n    Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 200\n    n == isConnected.length\n    n == isConnected[i].length\n    isConnected[i][j] is 1 or 0.\n    isConnected[i][i] == 1\n    isConnected[i][j] == isConnected[j][i]\n\n    \"\"\"\n", "canonical_solution": "    def dfs(isConnected, visited, i):\n        visited[i] = True\n        for j in range(len(isConnected)):\n            if isConnected[i][j] == 1 and not visited[j]:\n                dfs(isConnected, visited, j)\n\n    provinces = 0\n    visited = [False] * len(isConnected)\n    for i in range(len(isConnected)):\n        if not visited[i]:\n            dfs(isConnected, visited, i)\n            provinces += 1\n    return provinces\n\n"}
{"prompt": "from typing import List\n\n\ndef optimal_division(nums: List[int]) -> str:\n    \"\"\"\n    You are given an integer array nums. The adjacent integers in nums will perform the float division.\n\n    For example, for nums = [2,3,4], we will evaluate the expression \"2/3/4\".\n\n    However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n    Return the corresponding expression that has the maximum value in string format.\n    Note: your expression should not contain redundant parenthesis.\n\u00a0\n    Example 1:\n\n    Input: nums = [1000,100,10,2]\n    Output: \"1000/(100/10/2)\"\n    Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200\n    However, the bold parenthesis in \"1000/((100/10)/2)\" are redundant since they do not influence the operation priority.\n    So you should return \"1000/(100/10/2)\".\n    Other cases:\n    1000/(100/10)/2 = 50\n    1000/(100/(10/2)) = 50\n    1000/100/10/2 = 0.5\n    1000/100/(10/2) = 2\n\n    Example 2:\n\n    Input: nums = [2,3,4]\n    Output: \"2/(3/4)\"\n    Explanation: (2/(3/4)) = 8/3 = 2.667\n    It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 10\n    2 <= nums[i] <= 1000\n    There is only one optimal division for the given input.\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef least_bricks(wall: List[List[int]]) -> int:\n    \"\"\"\n    There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.\n    Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\n    Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.\n\u00a0\n    Example 1:\n\n\n    Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n    Output: 2\n\n    Example 2:\n\n    Input: wall = [[1],[1],[1]]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    n == wall.length\n    1 <= n <= 104\n    1 <= wall[i].length <= 104\n    1 <= sum(wall[i].length) <= 2 * 104\n    sum(wall[i]) is the same for each row i.\n    1 <= wall[i][j] <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    edge_count = defaultdict(int)\n    max_count = 0\n\n    for row in wall:\n        edge_position = 0\n        for i in range(len(row) - 1):\n            edge_position += row[i]\n            edge_count[edge_position] += 1\n            max_count = max(max_count, edge_count[edge_position])\n\n    return len(wall) - max_count\n\n"}
{"prompt": "def nextGreaterElement(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\n    Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\n\u00a0\n    Example 1:\n    Input: n = 12\n    Output: 21\n    Example 2:\n    Input: n = 21\n    Output: -1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    from itertools import permutations\n    num_str = str(n)\n    num_permutations = sorted(set(int(\"\".join(p)) for p in permutations(num_str)))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:\n        return num_permutations[index + 1]\n    return -1\n\n"}
{"prompt": "from typing import List\n\n\ndef subarraySum(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n    A subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\n    Example 1:\n    Input: nums = [1,1,1], k = 2\n    Output: 2\n    Example 2:\n    Input: nums = [1,2,3], k = 3\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2 * 104\n    -1000 <= nums[i] <= 1000\n    -107 <= k <= 107\n\n    \"\"\"\n", "canonical_solution": "    prefix_sum_frequency = {0: 1}\n    prefix_sum, result = 0, 0\n\n    for num in nums:\n        prefix_sum += num\n        result += prefix_sum_frequency.get(prefix_sum - k, 0)\n        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef arrayNesting(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\n    You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\n\n    The first element in s[k] starts with the selection of the element nums[k] of index = k.\n    The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.\n    We stop adding right before a duplicate element occurs in s[k].\n\n    Return the longest length of a set s[k].\n\u00a0\n    Example 1:\n\n    Input: nums = [5,4,0,3,1,6,2]\n    Output: 4\n    Explanation: \n    nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\n    One of the longest sets s[k]:\n    s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n\n    Example 2:\n\n    Input: nums = [0,1,2]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    0 <= nums[i] < nums.length\n    All the values of nums are unique.\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    max_len = 0\n    for i in range(n):\n        if nums[i] != -1:\n            start = nums[i]\n            count = 0\n            while nums[start] != -1:\n                temp = start\n                start = nums[start]\n                count += 1\n                nums[temp] = -1\n            max_len = max(max_len, count)\n    return max_len\n\n"}
{"prompt": "def checkInclusion(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n    In other words, return true if one of s1's permutations is the substring of s2.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"ab\", s2 = \"eidbaooo\"\n    Output: true\n    Explanation: s2 contains one permutation of s1 (\"ba\").\n\n    Example 2:\n\n    Input: s1 = \"ab\", s2 = \"eidboaoo\"\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 104\n    s1 and s2 consist of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    if len(s1) > len(s2):\n        return False\n\n    s1_map = [0] * 26\n    s2_map = [0] * 26\n\n    for i in range(len(s1)):\n        s1_map[ord(s1[i]) - ord('a')] += 1\n        s2_map[ord(s2[i]) - ord('a')] += 1\n\n    for i in range(len(s2) - len(s1)):\n        if s1_map == s2_map:\n            return True\n\n        s2_map[ord(s2[i]) - ord('a')] -= 1\n        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1\n\n    return s1_map == s2_map\n\n"}
{"prompt": "def findPaths(m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:\n    \"\"\"\n    There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.\n    Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n\n    Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n    Output: 6\n\n    Example 2:\n\n\n    Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n    Output: 12\n\n\u00a0\n    Constraints:\n\n    1 <= m, n <= 50\n    0 <= maxMove <= 50\n    0 <= startRow < m\n    0 <= startColumn < n\n\n    \"\"\"\n", "canonical_solution": "    MOD = 10**9 + 7\n    dp = [[[0] * n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):\n        for i in range(m):\n            for j in range(n):\n                for move in moves:\n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD\n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]\n\n"}
{"prompt": "from typing import List\n\n\ndef findUnsortedSubarray(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.\n    Return the shortest such subarray and output its length.\n\u00a0\n    Example 1:\n\n    Input: nums = [2,6,4,8,10,9,15]\n    Output: 5\n    Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n\n    Example 2:\n\n    Input: nums = [1,2,3,4]\n    Output: 0\n\n    Example 3:\n\n    Input: nums = [1]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    -105 <= nums[i] <= 105\n\n\u00a0\n    Follow up: Can you solve it in O(n) time complexity?\"\"\"\n", "canonical_solution": "    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1\n\n"}
{"prompt": "def fractionAddition(expression: str) -> str:\n    \"\"\"\n    Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\n    The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\n\u00a0\n    Example 1:\n\n    Input: expression = \"-1/2+1/2\"\n    Output: \"0/1\"\n\n    Example 2:\n\n    Input: expression = \"-1/2+1/2+1/3\"\n    Output: \"1/3\"\n\n    Example 3:\n\n    Input: expression = \"1/3-1/2\"\n    Output: \"-1/6\"\n\n\u00a0\n    Constraints:\n\n    The input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n    Each fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\n    The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\n    The number of given fractions will be in the range [1, 10].\n    The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\n\n    \"\"\"\n", "canonical_solution": "    from fractions import Fraction\n    fractions = expression.replace('+', ' +').replace('-', ' -').split()\n    result = sum(Fraction(fraction) for fraction in fractions)\n    return f\"{result.numerator}/{result.denominator}\"\n\n"}
{"prompt": "from typing import List\n\n\ndef validSquare(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n    \"\"\"\n    Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square.\n    The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order.\n    A valid square has four equal sides with positive length and four equal angles (90-degree angles).\n\u00a0\n    Example 1:\n\n    Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n    Output: true\n\n    Example 2:\n\n    Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n    Output: false\n\n    Example 3:\n\n    Input: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n    Output: true\n\n\u00a0\n    Constraints:\n\n    p1.length == p2.length == p3.length == p4.length == 2\n    -104 <= xi, yi <= 104\n\n    \"\"\"\n", "canonical_solution": "    def dist_sq(p, q):\n        return (p[0] - q[0])**2 + (p[1] - q[1])**2\n\n    points = [p1, p2, p3, p4]\n    dists = set()\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.add(dist_sq(points[i], points[j]))\n\n    return len(dists) == 2 and 0 not in dists\n\n"}
{"prompt": "from typing import List\n\n\ndef group_anagrams(strs: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n    An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\u00a0\n    Example 1:\n    Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n    Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n    Example 2:\n    Input: strs = [\"\"]\n    Output: [[\"\"]]\n    Example 3:\n    Input: strs = [\"a\"]\n    Output: [[\"a\"]]\n\n\u00a0\n    Constraints:\n\n    1 <= strs.length <= 104\n    0 <= strs[i].length <= 100\n    strs[i] consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    anagram_map = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_map[key].append(s)\n\n    return list(anagram_map.values())\n\n"}
{"prompt": "from typing import List\n\n\ndef find_duplicate(paths: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\n    A group of duplicate files consists of at least two files that have the same content.\n    A single directory info string in the input list has the following format:\n\n    \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\n\n    It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\n    The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n\n    \"directory_path/file_name.txt\"\n\n\u00a0\n    Example 1:\n    Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n    Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n    Example 2:\n    Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n    Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n\n\u00a0\n    Constraints:\n\n    1 <= paths.length <= 2 * 104\n    1 <= paths[i].length <= 3000\n    1 <= sum(paths[i].length) <= 5 * 105\n    paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.\n    You may assume no files or directories share the same name in the same directory.\n    You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.\n\n\u00a0\n    Follow up:\n\n    Imagine you are given a real file system, how will you search files? DFS or BFS?\n    If the file content is very large (GB level), how will you modify your solution?\n    If you can only read the file by 1kb each time, how will you modify your solution?\n    What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?\n    How to make sure the duplicated files you find are not false positive?\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        directory = parts[0]\n        for file in parts[1:]:\n            start = file.index('(')\n            end = file.index(')')\n            content = file[start + 1:end]\n            file_path = directory + '/' + file[:start]\n            content_map[content].append(file_path)\n\n    result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1]\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef triangleNumber(nums: list) -> int:\n    \"\"\"\n    Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\u00a0\n    Example 1:\n\n    Input: nums = [2,2,3,4]\n    Output: 3\n    Explanation: Valid combinations are: \n    2,3,4 (using the first 2)\n    2,3,4 (using the second 2)\n    2,2,3\n\n    Example 2:\n\n    Input: nums = [4,2,3,4]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    0 <= nums[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef least_interval(tasks: List[str], n: int) -> int:\n    \"\"\"\n    Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n    However, there is a non-negative integer\u00a0n that represents the cooldown period between\u00a0two same tasks\u00a0(the same letter in the array), that is that there must be at least n units of time between any two same tasks.\n    Return the least number of units of times that the CPU will take to finish all the given tasks.\n\u00a0\n    Example 1:\n\n    Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n    Output: 8\n    Explanation: \n    A -> B -> idle -> A -> B -> idle -> A -> B\n    There is at least 2 units of time between any two same tasks.\n\n    Example 2:\n\n    Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n    Output: 6\n    Explanation: On this case any permutation of size 6 would work since n = 0.\n    [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n    [\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n    [\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n    ...\n    And so on.\n\n    Example 3:\n\n    Input: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n    Output: 16\n    Explanation: \n    One possible solution is\n    A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n\n\u00a0\n    Constraints:\n\n    1 <= task.length <= 104\n    tasks[i] is upper-case English letter.\n    The integer n is in the range [0, 100].\n\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    task_freq = Counter(tasks)\n\n    max_f = max(task_freq.values())\n    max_count = sum(1 for count in task_freq.values() if count == max_f)\n\n    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)\n\n"}
{"prompt": "from typing import Union\n\n\ndef myPow(x: float, n: int) -> float:\n    \"\"\"\n    Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\u00a0\n    Example 1:\n\n    Input: x = 2.00000, n = 10\n    Output: 1024.00000\n\n    Example 2:\n\n    Input: x = 2.10000, n = 3\n    Output: 9.26100\n\n    Example 3:\n\n    Input: x = 2.00000, n = -2\n    Output: 0.25000\n    Explanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\u00a0\n    Constraints:\n\n    -100.0 < x < 100.0\n    -231 <= n <= 231-1\n    n is an integer.\n    Either x is not zero or n > 0.\n    -104 <= xn <= 104\n\n    \"\"\"\n", "canonical_solution": "    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n\n"}
{"prompt": "def judge_square_sum(c: int) -> bool:\n    \"\"\"\n    Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.\n\u00a0\n    Example 1:\n\n    Input: c = 5\n    Output: true\n    Explanation: 1 * 1 + 2 * 2 = 5\n\n    Example 2:\n\n    Input: c = 3\n    Output: false\n\n\u00a0\n    Constraints:\n\n    0 <= c <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    for a in range(int(c ** 0.5) + 1):\n        b = int((c - a * a) ** 0.5)\n        if a * a + b * b == c:\n            return True\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef exclusiveTime(n: int, logs: List[str]) -> List[int]:\n    \"\"\"\n    On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.\n    Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n    You are given a list logs, where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\". For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3, and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.\n    A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.\n    Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.\n\u00a0\n    Example 1:\n\n\n    Input: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n    Output: [3,4]\n    Explanation:\n    Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\n    Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\n    Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\n    So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n    Example 2:\n\n    Input: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n    Output: [8]\n    Explanation:\n    Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\n    Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n    Function 0 (initial call) resumes execution then immediately calls itself again.\n    Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\n    Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\n    So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\n    Example 3:\n\n    Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n    Output: [7,1]\n    Explanation:\n    Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\n    Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n    Function 0 (initial call) resumes execution then immediately calls function 1.\n    Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\n    Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\n    So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 100\n    1 <= logs.length <= 500\n    0 <= function_id < n\n    0 <= timestamp <= 109\n    No two start events will happen at the same timestamp.\n    No two end events will happen at the same timestamp.\n    Each function has an \"end\" log for each \"start\" log.\n\n    \"\"\"\n", "canonical_solution": "    res = [0] * n\n    stack = []\n    prev_time = 0\n\n    for log in logs:\n        parts = log.split(':')\n        id = int(parts[0])\n        type = parts[1]\n        time = int(parts[2])\n\n        if type == \"start\":\n            if stack:\n                res[stack[-1]] += time - prev_time\n            stack.append(id)\n            prev_time = time\n        else:\n            res[stack.pop()] += time - prev_time + 1\n            prev_time = time + 1\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef findLongestChain(pairs: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n    A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.\n    Return the length longest chain which can be formed.\n    You do not need to use up all the given intervals. You can select pairs in any order.\n\u00a0\n    Example 1:\n\n    Input: pairs = [[1,2],[2,3],[3,4]]\n    Output: 2\n    Explanation: The longest chain is [1,2] -> [3,4].\n\n    Example 2:\n\n    Input: pairs = [[1,2],[7,8],[4,5]]\n    Output: 3\n    Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].\n\n\u00a0\n    Constraints:\n\n    n == pairs.length\n    1 <= n <= 1000\n    -1000 <= lefti < righti <= 1000\n\n    \"\"\"\n", "canonical_solution": "    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n\n"}
{"prompt": "def countSubstrings(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of palindromic substrings in it.\n    A string is a palindrome when it reads the same backward as forward.\n    A substring is a contiguous sequence of characters within the string.\n\u00a0\n    Example 1:\n\n    Input: s = \"abc\"\n    Output: 3\n    Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n\n    Example 2:\n\n    Input: s = \"aaa\"\n    Output: 6\n    Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n\n"}
{"prompt": "def predict_party_victory(senate: str) -> str:\n    \"\"\"\n    In the world of Dota2, there are two parties: the Radiant and the Dire.\n    The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\n    Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\n    Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\n    Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\n    The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n    Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\n\u00a0\n    Example 1:\n\n    Input: senate = \"RD\"\n    Output: \"Radiant\"\n    Explanation: \n    The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n    And the second senator can't exercise any rights anymore since his right has been banned. \n    And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n    Example 2:\n\n    Input: senate = \"RDD\"\n    Output: \"Dire\"\n    Explanation: \n    The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n    And the second senator can't exercise any rights anymore since his right has been banned. \n    And the third senator comes from Dire and he can ban the first senator's right in round 1. \n    And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n\u00a0\n    Constraints:\n\n    n == senate.length\n    1 <= n <= 104\n    senate[i] is either 'R' or 'D'.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    radiant = deque()\n    dire = deque()\n    n = len(senate)\n\n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n\n    while radiant and dire:\n        r = radiant.popleft()\n        d = dire.popleft()\n\n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n\n    return \"Dire\" if not radiant else \"Radiant\"\n\n"}
{"prompt": "def min_steps(n: int) -> int:\n    \"\"\"\n    There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n\n    Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n    Paste: You can paste the characters which are copied last time.\n\n    Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.\n\u00a0\n    Example 1:\n\n    Input: n = 3\n    Output: 3\n    Explanation: Initially, we have one character 'A'.\n    In step 1, we use Copy All operation.\n    In step 2, we use Paste operation to get 'AA'.\n    In step 3, we use Paste operation to get 'AAA'.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 1000\n\n    \"\"\"\n", "canonical_solution": "    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef checkPossibility(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n    We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\n\u00a0\n    Example 1:\n\n    Input: nums = [4,2,3]\n    Output: true\n    Explanation: You could modify the first 4 to 1 to get a non-decreasing array.\n\n    Example 2:\n\n    Input: nums = [4,2,1]\n    Output: false\n    Explanation: You cannot get a non-decreasing array by modifying at most one element.\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 104\n    -105 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    cnt = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            cnt += 1\n            if i == 1 or nums[i] >= nums[i - 2]:\n                nums[i-1] = nums[i]\n            else:\n                nums[i] = nums[i - 1]\n            if cnt > 1:\n                return False\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSubArray(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\u00a0\n    Example 1:\n\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n    Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n\n    Example 2:\n\n    Input: nums = [1]\n    Output: 1\n    Explanation: The subarray [1] has the largest sum 1.\n\n    Example 3:\n\n    Input: nums = [5,4,-1,7,8]\n    Output: 23\n    Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n\n\u00a0\n    Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n    \"\"\"\n", "canonical_solution": "    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n"}
{"prompt": "def maximumSwap(num: int) -> int:\n    \"\"\"\n    You are given an integer num. You can swap two digits at most once to get the maximum valued number.\n    Return the maximum valued number you can get.\n\u00a0\n    Example 1:\n\n    Input: num = 2736\n    Output: 7236\n    Explanation: Swap the number 2 and the number 7.\n\n    Example 2:\n\n    Input: num = 9973\n    Output: 9973\n    Explanation: No swap.\n\n\u00a0\n    Constraints:\n\n    0 <= num <= 108\n\n    \"\"\"\n", "canonical_solution": "    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num\n\n"}
{"prompt": "from typing import List\n\n\ndef findNumberOfLIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array\u00a0nums, return the number of longest increasing subsequences.\n    Notice that the sequence has to be strictly increasing.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,5,4,7]\n    Output: 2\n    Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n\n    Example 2:\n\n    Input: nums = [2,2,2,2,2]\n    Output: 5\n    Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2000\n    -106 <= nums[i] <= 106\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n\n"}
{"prompt": "def checkValidString(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\n    The following rules define a valid string:\n\n    Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n    Any right parenthesis ')' must have a corresponding left parenthesis '('.\n    Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n    '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n\n\u00a0\n    Example 1:\n    Input: s = \"()\"\n    Output: true\n    Example 2:\n    Input: s = \"(*)\"\n    Output: true\n    Example 3:\n    Input: s = \"(*))\"\n    Output: true\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 100\n    s[i] is '(', ')' or '*'.\n\n    \"\"\"\n", "canonical_solution": "    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef spiralOrder(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an m x n matrix, return all elements of the matrix in spiral order.\n\u00a0\n    Example 1:\n\n\n    Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n    Output: [1,2,3,6,9,8,7,4,5]\n\n    Example 2:\n\n\n    Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n    Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\u00a0\n    Constraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 10\n    -100 <= matrix[i][j] <= 100\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    if not matrix:\n        return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1):\n            result.append(matrix[rowStart][i])\n        rowStart += 1\n\n        for i in range(rowStart, rowEnd + 1):\n            result.append(matrix[i][colEnd])\n        colEnd -= 1\n\n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1):\n                result.append(matrix[rowEnd][i])\n        rowEnd -= 1\n\n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1):\n                result.append(matrix[i][colStart])\n        colStart += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef canJump(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n    Return true if you can reach the last index, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [2,3,1,1,4]\n    Output: true\n    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n    Example 2:\n\n    Input: nums = [3,2,1,0,4]\n    Output: false\n    Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    0 <= nums[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n\n"}
{"prompt": "def convert(s: str, numRows: int) -> str:\n    \"\"\"\n    The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n    P   A   H   N\n    A P L S I I G\n    Y   I   R\n\n    And then read line by line: \"PAHNAPLSIIGYIR\"\n    Write the code that will take a string and make this conversion given a number of rows:\n\n    string convert(string s, int numRows);\n\n\u00a0\n    Example 1:\n\n    Input: s = \"PAYPALISHIRING\", numRows = 3\n    Output: \"PAHNAPLSIIGYIR\"\n\n    Example 2:\n\n    Input: s = \"PAYPALISHIRING\", numRows = 4\n    Output: \"PINALSIGYAHRPI\"\n    Explanation:\n    P     I    N\n    A   L S  I G\n    Y A   H R\n    P     I\n\n    Example 3:\n\n    Input: s = \"A\", numRows = 1\n    Output: \"A\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    s consists of English letters (lower-case and upper-case), ',' and '.'.\n    1 <= numRows <= 1000\n\n    \"\"\"\n", "canonical_solution": "    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAreaOfIsland(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n    The area of an island is the number of cells with a value 1 in the island.\n    Return the maximum area of an island in grid. If there is no island, return 0.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n    Output: 6\n    Explanation: The answer is not 11, because the island must be connected 4-directionally.\n\n    Example 2:\n\n    Input: grid = [[0,0,0,0,0,0,0,0]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 50\n    grid[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n\n"}
{"prompt": "from typing import List\n\n\ndef canPartitionKSubsets(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,3,2,3,5,2,1], k = 4\n    Output: true\n    Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n\n    Example 2:\n\n    Input: nums = [1,2,3,4], k = 3\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= k <= nums.length <= 16\n    1 <= nums[i] <= 104\n    The frequency of each element is in the range [1, 4].\n\n    \"\"\"\n", "canonical_solution": "    def dfs(nums, visited, start, target, curr_sum, k):\n        if k == 1:\n            return True\n        if curr_sum == target:\n            return dfs(nums, visited, 0, target, 0, k - 1)\n        for i in range(start, len(nums)):\n            if not visited[i] and curr_sum + nums[i] <= target:\n                visited[i] = True\n                if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):\n                    return True\n                visited[i] = False\n        return False\n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, visited, 0, target, 0, k)\n\n"}
{"prompt": "def minimumDeleteSum(s1: str, s2: str) -> int:\n    \"\"\"\n    Given two strings s1 and\u00a0s2, return the lowest ASCII sum of deleted characters to make two strings equal.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"sea\", s2 = \"eat\"\n    Output: 231\n    Explanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\n    Deleting \"t\" from \"eat\" adds 116 to the sum.\n    At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n    Example 2:\n\n    Input: s1 = \"delete\", s2 = \"leet\"\n    Output: 403\n    Explanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\",\n    adds 100[d] + 101[e] + 101[e] to the sum.\n    Deleting \"e\" from \"leet\" adds 101[e] to the sum.\n    At the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\n    If instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 1000\n    s1 and s2 consist of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n\n"}
{"prompt": "from typing import List\n\n\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n\u00a0\n    Example 1:\n\n    Input: nums = [10,5,2,6], k = 100\n    Output: 8\n    Explanation: The 8 subarrays that have product less than 100 are:\n    [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n    Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n\n    Example 2:\n\n    Input: nums = [1,2,3], k = 0\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    1 <= nums[i] <= 1000\n    0 <= k <= 106\n\n    \"\"\"\n", "canonical_solution": "    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef maxProfit(prices: List[int], fee: int) -> int:\n    \"\"\"\n    You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\n    Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n    Note:\n\n    You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n    The transaction fee is only charged once for each stock purchase and sale.\n\n\u00a0\n    Example 1:\n\n    Input: prices = [1,3,2,8,4,9], fee = 2\n    Output: 8\n    Explanation: The maximum profit can be achieved by:\n    - Buying at prices[0] = 1\n    - Selling at prices[3] = 8\n    - Buying at prices[4] = 4\n    - Selling at prices[5] = 9\n    The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n    Example 2:\n\n    Input: prices = [1,3,7,5,10,3], fee = 3\n    Output: 6\n\n\u00a0\n    Constraints:\n\n    1 <= prices.length <= 5 * 104\n    1 <= prices[i] < 5 * 104\n    0 <= fee < 5 * 104\n\n    \"\"\"\n", "canonical_solution": "    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n\n"}
{"prompt": "from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\n\u00a0\n    Example 1:\n\n    Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n    Output: 3\n    Explanation: The repeated subarray with maximum length is [3,2,1].\n\n    Example 2:\n\n    Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n    Output: 5\n    Explanation: The repeated subarray with maximum length is [0,0,0,0,0].\n\n\u00a0\n    Constraints:\n\n    1 <= nums1.length, nums2.length <= 1000\n    0 <= nums1[i], nums2[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n\n"}
{"prompt": "from typing import List\n\n\ndef longest_word(words: List[str]) -> str:\n    \"\"\"\n    Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\n    If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n    Note that the word should be built from left to right with each additional character being added to the end of a previous word.\u00a0\n\u00a0\n    Example 1:\n\n    Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]\n    Output: \"world\"\n    Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".\n\n    Example 2:\n\n    Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]\n    Output: \"apple\"\n    Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".\n\n\u00a0\n    Constraints:\n\n    1 <= words.length <= 1000\n    1 <= words[i].length <= 30\n    words[i] consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result\n\n"}
{"prompt": "def monotoneIncreasingDigits(n: int) -> int:\n    \"\"\"\n    An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.\n    Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits.\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 9\n\n    Example 2:\n\n    Input: n = 1234\n    Output: 1234\n\n    Example 3:\n\n    Input: n = 332\n    Output: 299\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 109\n\n    \"\"\"\n", "canonical_solution": "    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))\n\n"}
{"prompt": "from typing import List\n\n\ndef daily_temperatures(temperatures: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\u00a0\n    Example 1:\n    Input: temperatures = [73,74,75,71,69,72,76,73]\n    Output: [1,1,4,2,1,1,0,0]\n    Example 2:\n    Input: temperatures = [30,40,50,60]\n    Output: [1,1,1,0]\n    Example 3:\n    Input: temperatures = [30,60,90]\n    Output: [1,1,0]\n\n\u00a0\n    Constraints:\n\n    1 <=\u00a0temperatures.length <= 105\n    30 <=\u00a0temperatures[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef networkDelayTime(times: List[List[int]], n: int, k: int) -> int:\n    \"\"\"\n    You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\n    We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\n\u00a0\n    Example 1:\n\n\n    Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n    Output: 2\n\n    Example 2:\n\n    Input: times = [[1,2,1]], n = 2, k = 1\n    Output: 1\n\n    Example 3:\n\n    Input: times = [[1,2,1]], n = 2, k = 2\n    Output: -1\n\n\u00a0\n    Constraints:\n\n    1 <= k <= n <= 100\n    1 <= times.length <= 6000\n    times[i].length == 3\n    1 <= ui, vi <= n\n    ui != vi\n    0 <= wi <= 100\n    All the pairs (ui, vi) are unique. (i.e., no multiple edges.)\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef openLock(deadends: List[str], target: str) -> int:\n    \"\"\"\n    You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\n    The lock initially starts at '0000', a string representing the state of the 4 wheels.\n    You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n    Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\u00a0\n    Example 1:\n\n    Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    Output: 6\n    Explanation: \n    A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\n    Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\n    because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\n    Example 2:\n\n    Input: deadends = [\"8888\"], target = \"0009\"\n    Output: 1\n    Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\n    Example 3:\n\n    Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n    Output: -1\n    Explanation: We cannot reach the target without getting stuck.\n\n\u00a0\n    Constraints:\n\n    1 <= deadends.length <= 500\n    deadends[i].length == 4\n    target.length == 4\n    target will not be in the list deadends.\n    target and deadends[i] consist of digits only.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    dead = set(deadends)\n    visited = set()\n    q = deque([\"0000\"])\n\n    if \"0000\" in dead:\n        return -1\n\n    visited.add(\"0000\")\n    moves = 0\n\n    while q:\n        level_size = len(q)\n        for i in range(level_size):\n            cur = q.popleft()\n\n            if cur == target:\n                return moves\n\n            for j in range(4):\n                for k in [-1, 1]:\n                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]\n\n                    if next_val not in visited and next_val not in dead:\n                        visited.add(next_val)\n                        q.append(next_val)\n\n        moves += 1\n\n    return -1\n\n"}
{"prompt": "from typing import List\n\n\ndef openLock(deadends: List[str], target: str) -> int:\n    \"\"\"\n    You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\n    The lock initially starts at '0000', a string representing the state of the 4 wheels.\n    You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n    Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\u00a0\n    Example 1:\n\n    Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    Output: 6\n    Explanation: \n    A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\n    Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\n    because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\n    Example 2:\n\n    Input: deadends = [\"8888\"], target = \"0009\"\n    Output: 1\n    Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\n    Example 3:\n\n    Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n    Output: -1\n    Explanation: We cannot reach the target without getting stuck.\n\n\u00a0\n    Constraints:\n\n    1 <= deadends.length <= 500\n    deadends[i].length == 4\n    target.length == 4\n    target will not be in the list deadends.\n    target and deadends[i] consist of digits only.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    dead = set(deadends)\n    visited = set()\n    wheel_states = deque([(\"0000\", 0)])\n\n    if \"0000\" in dead:\n        return -1\n\n    while wheel_states:\n        current_state, turns = wheel_states.popleft()\n\n        if current_state == target:\n            return turns\n\n        for i in range(4):\n            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]\n            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]\n\n            if up_state not in visited and up_state not in dead:\n                wheel_states.append((up_state, turns + 1))\n                visited.add(up_state)\n\n            if down_state not in visited and down_state not in dead:\n                wheel_states.append((down_state, turns + 1))\n                visited.add(down_state)\n\n    return -1\n\n"}
{"prompt": "def reachNumber(target: int) -> int:\n    \"\"\"\n    You are standing at position 0 on an infinite number line. There is a destination at position target.\n    You can make some number of moves numMoves so that:\n\n    On each move, you can either go left or right.\n    During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\n\n    Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.\n\u00a0\n    Example 1:\n\n    Input: target = 2\n    Output: 3\n    Explanation:\n    On the 1st move, we step from 0 to 1 (1 step).\n    On the 2nd move, we step from 1 to -1 (2 steps).\n    On the 3rd move, we step from -1 to 2 (3 steps).\n\n    Example 2:\n\n    Input: target = 3\n    Output: 2\n    Explanation:\n    On the 1st move, we step from 0 to 1 (1 step).\n    On the 2nd move, we step from 1 to 3 (2 steps).\n\n\u00a0\n    Constraints:\n\n    -109 <= target <= 109\n    target != 0\n\n    \"\"\"\n", "canonical_solution": "    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step\n\n"}
{"prompt": "from typing import List\n\n\ndef pyramid_transition(bottom: str, allowed: List[str]) -> bool:\n    \"\"\"\n    You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top.\n    To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given\u00a0as a list of\u00a0three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.\n\n    For example, \"ABC\" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from \"BAC\" where 'B' is on the left bottom and 'A' is on the right bottom.\n\n    You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.\n    Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.\n\u00a0\n    Example 1:\n\n\n    Input: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n    Output: true\n    Explanation: The allowed triangular patterns are shown on the right.\n    Starting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"A\" on level 1.\n    There are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed.\n\n    Example 2:\n\n\n    Input: bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n    Output: false\n    Explanation: The allowed triangular patterns are shown on the right.\n    Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.\n\n\u00a0\n    Constraints:\n\n    2 <= bottom.length <= 6\n    0 <= allowed.length <= 216\n    allowed[i].length == 3\n    The letters in all input strings are from the set {'A', 'B', 'C', 'D', 'E', 'F'}.\n    All the values of allowed are unique.\n\n    \"\"\"\n", "canonical_solution": "    def pyramid_transition_helper(bottom, top, idx, mapping):\n        if len(bottom) == 1:\n            return True\n        if idx == len(bottom) - 1:\n            return pyramid_transition_helper(top, \"\", 0, mapping)\n        key = bottom[idx:idx + 2]\n        if key not in mapping:\n            return False\n        for c in mapping[key]:\n            if pyramid_transition_helper(bottom, top + c, idx + 1, mapping):\n                return True\n        return False\n    mapping = {}\n    for s in allowed:\n        key = s[:2]\n        if key not in mapping:\n            mapping[key] = []\n        mapping[key].append(s[2])\n    return pyramid_transition_helper(bottom, \"\", 0, mapping)\n\n"}
{"prompt": "from typing import List\n\n\ndef pyramidTransition(bottom: str, allowed: List[str]) -> bool:\n    \"\"\"\n    You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top.\n    To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given\u00a0as a list of\u00a0three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.\n\n    For example, \"ABC\" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from \"BAC\" where 'B' is on the left bottom and 'A' is on the right bottom.\n\n    You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.\n    Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.\n\u00a0\n    Example 1:\n\n\n    Input: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n    Output: true\n    Explanation: The allowed triangular patterns are shown on the right.\n    Starting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"A\" on level 1.\n    There are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed.\n\n    Example 2:\n\n\n    Input: bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n    Output: false\n    Explanation: The allowed triangular patterns are shown on the right.\n    Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.\n\n\u00a0\n    Constraints:\n\n    2 <= bottom.length <= 6\n    0 <= allowed.length <= 216\n    allowed[i].length == 3\n    The letters in all input strings are from the set {'A', 'B', 'C', 'D', 'E', 'F'}.\n    All the values of allowed are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n\n    def dfs(curr, bottom, mapping):\n        if len(bottom) == 1:\n            return True\n        for i in range(len(bottom) - 1):\n            if bottom[i:i+2] not in mapping:\n                return False\n        curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n        return dfs(curr, curr, mapping)\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\n"}
{"prompt": "from typing import List\n\n\ndef partition_labels(s: str) -> List[int]:\n    \"\"\"\n    You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n    Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\n    Return a list of integers representing the size of these parts.\n\u00a0\n    Example 1:\n\n    Input: s = \"ababcbacadefegdehijhklij\"\n    Output: [9,7,8]\n    Explanation:\n    The partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\n    This is a partition so that each letter appears in at most one part.\n    A partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n\n    Example 2:\n\n    Input: s = \"eccbbbbdec\"\n    Output: [10]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 500\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    last = {c: i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef orderOfLargestPlusSign(n: int, mines: List[List[int]]) -> int:\n    \"\"\"\n    You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\n    Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\n    An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\n\u00a0\n    Example 1:\n\n\n    Input: n = 5, mines = [[4,2]]\n    Output: 2\n    Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n    Example 2:\n\n\n    Input: n = 1, mines = [[0,0]]\n    Output: 0\n    Explanation: There is no plus sign, so return 0.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 500\n    1 <= mines.length <= 5000\n    0 <= xi, yi < n\n    All the pairs (xi, yi) are unique.\n\n    \"\"\"\n", "canonical_solution": "    grid = [[1] * n for _ in range(n)]\n    for mine in mines:\n        grid[mine[0]][mine[1]] = 0\n\n    left, right, up, down = [list(grid) for _ in range(4)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)\n                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)\n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j]:\n                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)\n                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)\n                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))\n\n    return ans\n\n"}
{"prompt": "def uniquePaths(m: int, n: int) -> int:\n    \"\"\"\n    There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n    Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n    The test cases are generated so that the answer will be less than or equal to 2 * 109.\n\u00a0\n    Example 1:\n\n\n    Input: m = 3, n = 7\n    Output: 28\n\n    Example 2:\n\n    Input: m = 3, n = 2\n    Output: 3\n    Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n    1. Right -> Down -> Down\n    2. Down -> Down -> Right\n    3. Down -> Right -> Down\n\n\u00a0\n    Constraints:\n\n    1 <= m, n <= 100\n\n    \"\"\"\n", "canonical_solution": "    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n\n"}
{"prompt": "from typing import List\n\n\ndef numRabbits(answers: List[int]) -> int:\n    \"\"\"\n    There is a forest with an unknown number of rabbits. We asked n rabbits \"How many rabbits have the same color as you?\" and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit.\n    Given the array answers, return the minimum number of rabbits that could be in the forest.\n\u00a0\n    Example 1:\n\n    Input: answers = [1,1,2]\n    Output: 5\n    Explanation:\n    The two rabbits that answered \"1\" could both be the same color, say red.\n    The rabbit that answered \"2\" can't be red or the answers would be inconsistent.\n    Say the rabbit that answered \"2\" was blue.\n    Then there should be 2 other blue rabbits in the forest that didn't answer into the array.\n    The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n\n    Example 2:\n\n    Input: answers = [10,10,10]\n    Output: 11\n\n\u00a0\n    Constraints:\n\n    1 <= answers.length <= 1000\n    0 <= answers[i] < 1000\n\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    count = Counter(answers)\n    rabbits = 0\n    for ans, cnt in count.items():\n        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)\n    return rabbits\n\n"}
{"prompt": "def rotatedDigits(n: int) -> int:\n    \"\"\"\n    An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\n    A number is valid if each digit remains a digit after rotation. For example:\n\n    0, 1, and 8 rotate to themselves,\n    2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n    6 and 9 rotate to each other, and\n    the rest of the numbers do not rotate to any other number and become invalid.\n\n    Given an integer n, return the number of good integers in the range [1, n].\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 4\n    Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\n    Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 0\n\n    Example 3:\n\n    Input: n = 2\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 104\n\n    \"\"\"\n", "canonical_solution": "    def isGood(num: int) -> bool:\n        changed = False\n        while num:\n            digit = num % 10\n            if digit in (3, 4, 7):\n                return False\n            if digit in (2, 5, 6, 9):\n                changed = True\n            num //= 10\n        return changed\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef is_ideal_permutation(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1].\n    The number of global inversions is the number of the different pairs (i, j) where:\n\n    0 <= i < j < n\n    nums[i] > nums[j]\n\n    The number of local inversions is the number of indices i where:\n\n    0 <= i < n - 1\n    nums[i] > nums[i + 1]\n\n    Return true if the number of global inversions is equal to the number of local inversions.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,0,2]\n    Output: true\n    Explanation: There is 1 global inversion and 1 local inversion.\n\n    Example 2:\n\n    Input: nums = [1,2,0]\n    Output: false\n    Explanation: There are 2 global inversions and 1 local inversion.\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 105\n    0 <= nums[i] < n\n    All the integers of nums are unique.\n    nums is a permutation of all the numbers in the range [0, n - 1].\n\n    \"\"\"\n", "canonical_solution": "    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    return True\n\n"}
{"prompt": "def customSortString(order: str, s: str) -> str:\n    \"\"\"\n    You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.\n    Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.\n    Return any permutation of s that satisfies this property.\n\u00a0\n    Example 1:\n\n    Input: order = \"cba\", s = \"abcd\"\n    Output: \"cbad\"\n    Explanation: \n    \"a\", \"b\", \"c\" appear in order, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\". \n    Since \"d\" does not appear in order, it can be at any position in the returned string. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\n\n    Example 2:\n\n    Input: order = \"cbafg\", s = \"abcd\"\n    Output: \"cbad\"\n\n\u00a0\n    Constraints:\n\n    1 <= order.length <= 26\n    1 <= s.length <= 200\n    order and s consist of lowercase English letters.\n    All the characters of order are unique.\n\n    \"\"\"\n", "canonical_solution": "    priority = {char: idx for idx, char in enumerate(order)}\n    return \"\".join(sorted(s, key=lambda x: priority.get(x, 0)))\n\n"}
{"prompt": "def canTransform(start: str, end: str) -> bool:\n    \"\"\"\n    In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\n\u00a0\n    Example 1:\n\n    Input: start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"\n    Output: true\n    Explanation: We can transform start to end following these steps:\n    RXXLRXRXL ->\n    XRXLRXRXL ->\n    XRLXRXRXL ->\n    XRLXXRRXL ->\n    XRLXXRRLX\n\n    Example 2:\n\n    Input: start = \"X\", end = \"L\"\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= start.length\u00a0<= 104\n    start.length == end.length\n    Both start and end will only consist of characters in 'L', 'R', and\u00a0'X'.\n\n    \"\"\"\n", "canonical_solution": "    if len(start) != len(end):\n        return False\n\n    i, j = 0, 0\n    n = len(start)\n    while i < n and j < n:\n        while i < n and start[i] == 'X':\n            i += 1\n        while j < n and end[j] == 'X':\n            j += 1\n\n        if start[i] != end[j]:\n            return False\n\n        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j):\n            return False\n\n        i += 1\n        j += 1\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef numRabbits(answers: List[int]) -> int:\n    \"\"\"\n    There is a forest with an unknown number of rabbits. We asked n rabbits \"How many rabbits have the same color as you?\" and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit.\n    Given the array answers, return the minimum number of rabbits that could be in the forest.\n\u00a0\n    Example 1:\n\n    Input: answers = [1,1,2]\n    Output: 5\n    Explanation:\n    The two rabbits that answered \"1\" could both be the same color, say red.\n    The rabbit that answered \"2\" can't be red or the answers would be inconsistent.\n    Say the rabbit that answered \"2\" was blue.\n    Then there should be 2 other blue rabbits in the forest that didn't answer into the array.\n    The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n\n    Example 2:\n\n    Input: answers = [10,10,10]\n    Output: 11\n\n\u00a0\n    Constraints:\n\n    1 <= answers.length <= 1000\n    0 <= answers[i] < 1000\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    count = defaultdict(int)\n    res = 0\n    for a in answers:\n        count[a] += 1\n        if count[a] == 1:\n            res += (a + 1)\n        elif count[a] > a + 1:\n            count[a] = 1\n            res += (a + 1)\n    return res\n\n"}
{"prompt": "from typing import Union, List\n\n\ndef letterCasePermutation(s: Union[List[str], str]) -> List[str]:\n    \"\"\"\n    Given a string s, you\u00a0can transform every letter individually to be lowercase or uppercase to create another string.\n    Return a list of all possible strings we could create. Return the output in any order.\n\u00a0\n    Example 1:\n\n    Input: s = \"a1b2\"\n    Output: [\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]\n\n    Example 2:\n\n    Input: s = \"3z4\"\n    Output: [\"3z4\",\"3Z4\"]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 12\n    s consists of lowercase English letters, uppercase English letters, and digits.\n\n    \"\"\"\n", "canonical_solution": "    def backtrack(index):\n        if index == len(s):\n            result.append(\"\".join(s))\n            return\n        backtrack(index + 1)\n        if s[index].isalpha():\n            s[index] = s[index].swapcase()\n            backtrack(index + 1)\n            s[index] = s[index].swapcase()\n\n    result = []\n    s = list(s)\n    backtrack(0)\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n    Note: You can only move either down or right at any point in time.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n    Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n\n    Example 2:\n\n    Input: grid = [[1,2,3],[4,5,6]]\n    Output: 12\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 200\n    0 <= grid[i][j] <= 200\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n\n"}
{"prompt": "from typing import List\n\n\ndef isBipartite(graph: List[List[int]]) -> bool:\n    \"\"\"\n    There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\n    There are no self-edges (graph[u] does not contain u).\n    There are no parallel edges (graph[u] does not contain duplicate values).\n    If v is in graph[u], then u is in graph[v] (the graph is undirected).\n    The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\n    A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n    Return true if and only if it is bipartite.\n\u00a0\n    Example 1:\n\n\n    Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n    Output: false\n    Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n    Example 2:\n\n\n    Input: graph = [[1,3],[0,2],[1,3],[0,2]]\n    Output: true\n    Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n\u00a0\n    Constraints:\n\n    graph.length == n\n    1 <= n <= 100\n    0 <= graph[u].length < n\n    0 <= graph[u][i] <= n - 1\n    graph[u]\u00a0does not contain\u00a0u.\n    All the values of graph[u] are unique.\n    If graph[u] contains v, then graph[v] contains u.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True\n\n"}
{"prompt": "def rotated_digits(n: int) -> int:\n    \"\"\"\n    An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\n    A number is valid if each digit remains a digit after rotation. For example:\n\n    0, 1, and 8 rotate to themselves,\n    2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n    6 and 9 rotate to each other, and\n    the rest of the numbers do not rotate to any other number and become invalid.\n\n    Given an integer n, return the number of good integers in the range [1, n].\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 4\n    Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\n    Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 0\n\n    Example 3:\n\n    Input: n = 2\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 104\n\n    \"\"\"\n", "canonical_solution": "    count = 0\n    for i in range(1, n + 1):\n        is_valid_after_rotation = True\n        is_different_after_rotation = False\n        num = i\n        while num:\n            digit = num % 10\n            if digit in {3, 4, 7}:\n                is_valid_after_rotation = False\n                break\n            if digit in {2, 5, 6, 9}:\n                is_different_after_rotation = True\n            num //= 10\n        if is_valid_after_rotation and is_different_after_rotation:\n            count += 1\n    return count\n\n"}
{"prompt": "def custom_sort_string(order: str, s: str) -> str:\n    \"\"\"\n    You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.\n    Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.\n    Return any permutation of s that satisfies this property.\n\u00a0\n    Example 1:\n\n    Input: order = \"cba\", s = \"abcd\"\n    Output: \"cbad\"\n    Explanation: \n    \"a\", \"b\", \"c\" appear in order, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\". \n    Since \"d\" does not appear in order, it can be at any position in the returned string. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\n\n    Example 2:\n\n    Input: order = \"cbafg\", s = \"abcd\"\n    Output: \"cbad\"\n\n\u00a0\n    Constraints:\n\n    1 <= order.length <= 26\n    1 <= s.length <= 200\n    order and s consist of lowercase English letters.\n    All the characters of order are unique.\n\n    \"\"\"\n", "canonical_solution": "    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))\n\n"}
{"prompt": "from typing import List\n\n\ndef numMatchingSubseq(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\n    A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n    For example, \"ace\" is a subsequence of \"abcde\".\n\n\u00a0\n    Example 1:\n\n    Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n    Output: 3\n    Explanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".\n\n    Example 2:\n\n    Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 5 * 104\n    1 <= words.length <= 5000\n    1 <= words[i].length <= 50\n    s and words[i] consist of only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    from bisect import bisect_left\n    from collections import defaultdict\n    positions = defaultdict(list)\n\n    for i, c in enumerate(s):\n        positions[c].append(i)\n\n    count = 0\n\n    for word in words:\n        index = -1\n        isSubsequence = True\n\n        for c in word:\n            position_list = positions.get(c, [])\n            i = bisect_left(position_list, index + 1)\n            if (i == len(position_list)):\n                isSubsequence = False\n                break\n            index = position_list[i]\n\n        if isSubsequence:\n            count += 1\n\n    return count\n\n"}
{"prompt": "def reverse(x: int) -> int:\n    \"\"\"\n    Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n    Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\u00a0\n    Example 1:\n\n    Input: x = 123\n    Output: 321\n\n    Example 2:\n\n    Input: x = -123\n    Output: -321\n\n    Example 3:\n\n    Input: x = 120\n    Output: 21\n\n\u00a0\n    Constraints:\n\n    -231 <= x <= 231 - 1\n\n    \"\"\"\n", "canonical_solution": "    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n\n"}
{"prompt": "from typing import List\n\n\ndef max_increase_keeping_skyline(grid: List[List[int]]) -> int:\n    \"\"\"\n    There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.\n    A city's skyline is the\u00a0outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.\n    We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n    Return the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n    Output: 35\n    Explanation: The building heights are shown in the center of the above image.\n    The skylines when viewed from each cardinal direction are drawn in red.\n    The grid after increasing the height of buildings without affecting skylines is:\n    gridNew = [ [8, 4, 8, 7],\n                [7, 4, 7, 7],\n                [9, 4, 8, 7],\n                [3, 3, 3, 3] ]\n\n    Example 2:\n\n    Input: grid = [[0,0,0],[0,0,0],[0,0,0]]\n    Output: 0\n    Explanation: Increasing the height of any building will result in the skyline changing.\n\n\u00a0\n    Constraints:\n\n    n == grid.length\n    n == grid[r].length\n    2 <= n <= 50\n    0 <= grid[r][c] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(grid)\n    row_max = [0] * n\n    col_max = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            row_max[i] = max(row_max[i], grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n\n    total_sum = 0\n    for i in range(n):\n        for j in range(n):\n            total_sum += min(row_max[i], col_max[j]) - grid[i][j]\n\n    return total_sum\n\n"}
{"prompt": "from typing import List\n\n\ndef maxProfitAssignment(difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n    \"\"\"\n    You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n    difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n    worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\n    Every worker can be assigned at most one job, but one job can be completed multiple times.\n\n    For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\n    Return the maximum profit we can achieve after assigning the workers to the jobs.\n\u00a0\n    Example 1:\n\n    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n    Output: 100\n    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\n    Example 2:\n\n    Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == difficulty.length\n    n == profit.length\n    m == worker.length\n    1 <= n, m <= 104\n    1 <= difficulty[i], profit[i], worker[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAreaOfIsland(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n    The area of an island is the number of cells with a value 1 in the island.\n    Return the maximum area of an island in grid. If there is no island, return 0.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n    Output: 6\n    Explanation: The answer is not 11, because the island must be connected 4-directionally.\n\n    Example 2:\n\n    Input: grid = [[0,0,0,0,0,0,0,0]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 50\n    grid[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef ambiguousCoordinates(s: str) -> List[str]:\n    \"\"\"\n    We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\n    For example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n\n    Return a list of strings representing all possibilities for what our original coordinates could have been.\n    Our original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\n    The final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n\u00a0\n    Example 1:\n\n    Input: s = \"(123)\"\n    Output: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n\n    Example 2:\n\n    Input: s = \"(0123)\"\n    Output: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\n    Explanation: 0.0, 00, 0001 or 00.01 are not allowed.\n\n    Example 3:\n\n    Input: s = \"(00011)\"\n    Output: [\"(0, 0.011)\",\"(0.001, 1)\"]\n\n\u00a0\n    Constraints:\n\n    4 <= s.length <= 12\n    s[0] == '(' and s[s.length - 1] == ')'.\n    The rest of s are digits.\n\n    \"\"\"\n", "canonical_solution": "    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n\n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n\n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n\n    return res\n\n"}
{"prompt": "def pushDominoes(dominoes: str) -> str:\n    \"\"\"\n    There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n    After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n    When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n    For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n    You are given a string dominoes representing the initial state where:\n\n    dominoes[i] = 'L', if the ith domino has been pushed to the left,\n    dominoes[i] = 'R', if the ith domino has been pushed to the right, and\n    dominoes[i] = '.', if the ith domino has not been pushed.\n\n    Return a string representing the final state.\n\u00a0\n    Example 1:\n\n    Input: dominoes = \"RR.L\"\n    Output: \"RR.L\"\n    Explanation: The first domino expends no additional force on the second domino.\n\n    Example 2:\n\n\n    Input: dominoes = \".L.R...LR..L..\"\n    Output: \"LL.RR.LLRRLL..\"\n\n\u00a0\n    Constraints:\n\n    n == dominoes.length\n    1 <= n <= 105\n    dominoes[i] is either 'L', 'R', or '.'.\n\n    \"\"\"\n", "canonical_solution": "    n = len(dominoes)\n    forces = [0] * n\n\n    force = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            force = n\n        elif dominoes[i] == 'L':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] += force\n\n    force = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            force = n\n        elif dominoes[i] == 'R':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] -= force\n\n    return \"\".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])\n\n"}
{"prompt": "from typing import List\n\n\ndef numFactoredBinaryTrees(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\n    We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\n    Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,4]\n    Output: 3\n    Explanation: We can make these trees: [2], [4], [4, 2, 2]\n    Example 2:\n\n    Input: arr = [2,4,5,10]\n    Output: 7\n    Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 1000\n    2 <= arr[i] <= 109\n    All the values of arr are unique.\n\n    \"\"\"\n", "canonical_solution": "    MOD = 10**9 + 7\n    n = len(arr)\n    arr.sort()\n    dp = {}\n    for i, x in enumerate(arr):\n        dp[x] = 1\n        for y in arr[:i]:\n            if x % y == 0 and x // y in dp:\n                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD\n    return sum(dp.values()) % MOD\n\n"}
{"prompt": "from typing import List\n\n\ndef longestMountain(arr: List[int]) -> int:\n    \"\"\"\n    You may recall that an array arr is a mountain array if and only if:\n\n    arr.length >= 3\n    There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\n    arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n    arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n    Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,1,4,7,3,2,5]\n    Output: 5\n    Explanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\n    Example 2:\n\n    Input: arr = [2,2,2]\n    Output: 0\n    Explanation: There is no mountain.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 104\n    0 <= arr[i] <= 104\n\n\u00a0\n    Follow up:\n\n    Can you solve it using only one pass?\n    Can you solve it in O(1) space?\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef maxDistToClosest(seats: List[int]) -> int:\n    \"\"\"\n    You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\n    There is at least one empty seat, and at least one person sitting.\n    Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\u00a0\n    Return that maximum distance to the closest person.\n\u00a0\n    Example 1:\n\n\n    Input: seats = [1,0,0,0,1,0,1]\n    Output: 2\n    Explanation: \n    If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\n    If Alex sits in any other open seat, the closest person has distance 1.\n    Thus, the maximum distance to the closest person is 2.\n\n    Example 2:\n\n    Input: seats = [1,0,0,0]\n    Output: 3\n    Explanation: \n    If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\n    This is the maximum distance possible, so the answer is 3.\n\n    Example 3:\n\n    Input: seats = [0,1]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    2 <= seats.length <= 2 * 104\n    seats[i]\u00a0is 0 or\u00a01.\n    At least one seat is empty.\n    At least one seat is occupied.\n\n    \"\"\"\n", "canonical_solution": "    n = len(seats)\n    maxDist = 0\n    lastPerson = -1\n\n    for i in range(n):\n        if seats[i] == 1:\n            if lastPerson == -1:\n                maxDist = i\n            else:\n                maxDist = max(maxDist, (i - lastPerson) // 2)\n            lastPerson = i\n\n    maxDist = max(maxDist, n - 1 - lastPerson)\n    return maxDist\n\n"}
{"prompt": "from typing import List\n\n\ndef numFriendRequests(ages: List[int]) -> int:\n    \"\"\"\n    There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\n    A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\n\n    age[y] <= 0.5 * age[x] + 7\n    age[y] > age[x]\n    age[y] > 100 && age[x] < 100\n\n    Otherwise, x will send a friend request to y.\n    Note that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\n    Return the total number of friend requests made.\n\u00a0\n    Example 1:\n\n    Input: ages = [16,16]\n    Output: 2\n    Explanation: 2 people friend request each other.\n\n    Example 2:\n\n    Input: ages = [16,17,18]\n    Output: 2\n    Explanation: Friend requests are made 17 -> 16, 18 -> 17.\n\n    Example 3:\n\n    Input: ages = [20,30,100,110,120]\n    Output: 3\n    Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n\u00a0\n    Constraints:\n\n    n == ages.length\n    1 <= n <= 2 * 104\n    1 <= ages[i] <= 120\n\n    \"\"\"\n", "canonical_solution": "    count = [0] * 121\n    total_requests = 0\n\n    for age in ages:\n        count[age] += 1\n\n    for a in range(1, 121):\n        for b in range(1, 121):\n            if a * 0.5 + 7 >= b:\n                continue\n            if a < b:\n                continue\n            if a < b * 2:\n                total_requests += count[a] * count[b]\n                if a == b:\n                    total_requests -= count[a]\n\n    return total_requests\n\n"}
{"prompt": "from typing import List\n\n\ndef max_profit_assignment(difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n    \"\"\"\n    You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n    difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n    worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\n    Every worker can be assigned at most one job, but one job can be completed multiple times.\n\n    For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\n    Return the maximum profit we can achieve after assigning the workers to the jobs.\n\u00a0\n    Example 1:\n\n    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n    Output: 100\n    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\n    Example 2:\n\n    Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == difficulty.length\n    n == profit.length\n    m == worker.length\n    1 <= n, m <= 104\n    1 <= difficulty[i], profit[i], worker[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit\n\n"}
{"prompt": "from typing import List\n\n\ndef findReplaceString(s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n    \"\"\"\n    You are given a 0-indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k.\n    To complete the ith replacement operation:\n\n    Check if the substring sources[i] occurs at index indices[i] in the original string s.\n    If it does not occur, do nothing.\n    Otherwise if it does occur, replace that substring with targets[i].\n\n    For example, if s = \"abcd\", indices[i] = 0, sources[i] = \"ab\", and targets[i] = \"eee\", then the result of this replacement will be \"eeecd\".\n    All replacement operations must occur simultaneously, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will not overlap.\n\n    For example, a testcase with s = \"abc\", indices = [0, 1], and sources = [\"ab\",\"bc\"] will not be generated because the \"ab\" and \"bc\" replacements overlap.\n\n    Return the resulting string after performing all replacement operations on s.\n    A substring is a contiguous sequence of characters in a string.\n\u00a0\n    Example 1:\n\n\n    Input: s = \"abcd\", indices = [0, 2], sources = [\"a\", \"cd\"], targets = [\"eee\", \"ffff\"]\n    Output: \"eeebffff\"\n    Explanation:\n    \"a\" occurs at index 0 in s, so we replace it with \"eee\".\n    \"cd\" occurs at index 2 in s, so we replace it with \"ffff\".\n\n    Example 2:\n\n\n    Input: s = \"abcd\", indices = [0, 2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n    Output: \"eeecd\"\n    Explanation:\n    \"ab\" occurs at index 0 in s, so we replace it with \"eee\".\n    \"ec\" does not occur at index 2 in s, so we do nothing.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    k == indices.length == sources.length == targets.length\n    1 <= k <= 100\n    0 <= indexes[i] < s.length\n    1 <= sources[i].length, targets[i].length <= 50\n    s consists of only lowercase English letters.\n    sources[i] and targets[i] consist of only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    index_mapping = sorted(\n        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]\n    )\n    result = []\n    last_idx = 0\n\n    for idx, i in index_mapping:\n        result.append(s[last_idx:idx])\n        result.append(targets[i])\n        last_idx = idx + len(sources[i])\n\n    result.append(s[last_idx:])\n    return \"\".join(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef largestOverlap(img1: List[List[int]], img2: List[List[int]]) -> int:\n    \"\"\"\n    You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.\n    We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.\n    Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased.\n    Return the largest possible overlap.\n\u00a0\n    Example 1:\n\n\n    Input: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n    Output: 3\n    Explanation: We translate img1 to right by 1 unit and down by 1 unit.\n\n    The number of positions that have a 1 in both images is 3 (shown in red).\n\n\n    Example 2:\n\n    Input: img1 = [[1]], img2 = [[1]]\n    Output: 1\n\n    Example 3:\n\n    Input: img1 = [[0]], img2 = [[0]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == img1.length == img1[i].length\n    n == img2.length == img2[i].length\n    1 <= n <= 30\n    img1[i][j] is either 0 or 1.\n    img2[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])\n\n"}
{"prompt": "from typing import Union\n\n\ndef new21Game(n: int, k: int, maxPts: int) -> float:\n    \"\"\"\n    Alice plays the following game, loosely based on the card game \"21\".\n    Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\n    Alice stops drawing numbers when she gets k or more points.\n    Return the probability that Alice has n or fewer points.\n    Answers within 10-5 of the actual answer are considered accepted.\n\u00a0\n    Example 1:\n\n    Input: n = 10, k = 1, maxPts = 10\n    Output: 1.00000\n    Explanation: Alice gets a single card, then stops.\n\n    Example 2:\n\n    Input: n = 6, k = 1, maxPts = 10\n    Output: 0.60000\n    Explanation: Alice gets a single card, then stops.\n    In 6 out of 10 possibilities, she is at or below 6 points.\n\n    Example 3:\n\n    Input: n = 21, k = 17, maxPts = 10\n    Output: 0.73278\n\n\u00a0\n    Constraints:\n\n    0 <= k <= n <= 104\n    1 <= maxPts <= 104\n\n    \"\"\"\n", "canonical_solution": "    if k == 0 or n >= k + maxPts:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    s, ans = 1, 0\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        else:\n            ans += dp[i]\n        if i >= maxPts:\n            s -= dp[i - maxPts]\n\n    return ans\n\n"}
{"prompt": "def push_dominoes(dominoes: str) -> str:\n    \"\"\"\n    There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n    After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n    When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n    For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n    You are given a string dominoes representing the initial state where:\n\n    dominoes[i] = 'L', if the ith domino has been pushed to the left,\n    dominoes[i] = 'R', if the ith domino has been pushed to the right, and\n    dominoes[i] = '.', if the ith domino has not been pushed.\n\n    Return a string representing the final state.\n\u00a0\n    Example 1:\n\n    Input: dominoes = \"RR.L\"\n    Output: \"RR.L\"\n    Explanation: The first domino expends no additional force on the second domino.\n\n    Example 2:\n\n\n    Input: dominoes = \".L.R...LR..L..\"\n    Output: \"LL.RR.LLRRLL..\"\n\n\u00a0\n    Constraints:\n\n    n == dominoes.length\n    1 <= n <= 105\n    dominoes[i] is either 'L', 'R', or '.'.\n\n    \"\"\"\n", "canonical_solution": "    prev, cur = None, dominoes\n    while prev != cur:\n        prev = cur\n        cur_lst = list(prev)\n        for i in range(len(cur)):\n            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':\n                cur_lst[i - 1] = 'L'\n            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':\n                cur_lst[i + 1] = 'R'\n        cur = ''.join(cur_lst)\n    return cur\n\n"}
{"prompt": "from typing import List\n\n\ndef can_visit_all_rooms(rooms: List[List[int]]) -> bool:\n    \"\"\"\n    There are n rooms labeled from 0 to n - 1\u00a0and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n    When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n    Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: rooms = [[1],[2],[3],[]]\n    Output: true\n    Explanation: \n    We visit room 0 and pick up key 1.\n    We then visit room 1 and pick up key 2.\n    We then visit room 2 and pick up key 3.\n    We then visit room 3.\n    Since we were able to visit every room, we return true.\n\n    Example 2:\n\n    Input: rooms = [[1,3],[3,0,1],[2],[0]]\n    Output: false\n    Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n\n\u00a0\n    Constraints:\n\n    n == rooms.length\n    2 <= n <= 1000\n    0 <= rooms[i].length <= 1000\n    1 <= sum(rooms[i].length) <= 3000\n    0 <= rooms[i][j] < n\n    All the values of rooms[i] are unique.\n\n    \"\"\"\n", "canonical_solution": "    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n\n"}
{"prompt": "from typing import List\n\n\ndef splitIntoFibonacci(num: str) -> List[int]:\n    \"\"\"\n    You are given a string of digits num, such as \"123456579\". We can split it into a Fibonacci-like sequence [123, 456, 579].\n    Formally, a Fibonacci-like sequence is a list f of non-negative integers such that:\n\n    0 <= f[i] < 231, (that is, each integer fits in a 32-bit signed integer type),\n    f.length >= 3, and\n    f[i] + f[i + 1] == f[i + 2] for all 0 <= i < f.length - 2.\n\n    Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\n    Return any Fibonacci-like sequence split from num, or return [] if it cannot be done.\n\u00a0\n    Example 1:\n\n    Input: num = \"1101111\"\n    Output: [11,0,11,11]\n    Explanation: The output [110, 1, 111] would also be accepted.\n\n    Example 2:\n\n    Input: num = \"112358130\"\n    Output: []\n    Explanation: The task is impossible.\n\n    Example 3:\n\n    Input: num = \"0123\"\n    Output: []\n    Explanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid.\n\n\u00a0\n    Constraints:\n\n    1 <= num.length <= 200\n    num contains only digits.\n\n    \"\"\"\n", "canonical_solution": "    ans = []\n\n    def backtrack(index, prev1, prev2):\n        if index == len(num):\n            return len(ans) >= 3\n        curr = 0\n        for i in range(index, len(num)):\n            if i > index and num[index] == '0':\n                break\n            curr = curr * 10 + ord(num[i]) - ord('0')\n            if curr > 2**31 - 1:\n                break\n            if len(ans) >= 2:\n                if curr < prev1 + prev2:\n                    continue\n                elif curr > prev1 + prev2:\n                    break\n            ans.append(curr)\n            if backtrack(i + 1, prev2, curr):\n                return True\n            ans.pop()\n        return False\n\n    backtrack(0, 0, 0)\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef longest_mountain(arr: List[int]) -> int:\n    \"\"\"\n    You may recall that an array arr is a mountain array if and only if:\n\n    arr.length >= 3\n    There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\n    arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n    arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n    Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,1,4,7,3,2,5]\n    Output: 5\n    Explanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\n    Example 2:\n\n    Input: arr = [2,2,2]\n    Output: 0\n    Explanation: There is no mountain.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 104\n    0 <= arr[i] <= 104\n\n\u00a0\n    Follow up:\n\n    Can you solve it using only one pass?\n    Can you solve it in O(1) space?\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length\n\n"}
{"prompt": "from typing import List\n\n\ndef is_n_straight_hand(hand: List[int], group_size: int) -> bool:\n    \"\"\"\n    Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n    Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n    Output: true\n    Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]\n\n    Example 2:\n\n    Input: hand = [1,2,3,4,5], groupSize = 4\n    Output: false\n    Explanation: Alice's hand can not be rearranged into groups of 4.\n\n\n\u00a0\n    Constraints:\n\n    1 <= hand.length <= 104\n    0 <= hand[i] <= 109\n    1 <= groupSize <= hand.length\n\n\u00a0\n    Note: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    counts = Counter(hand)\n\n    for card in sorted(counts):\n        if counts[card] > 0:\n            for i in range(group_size - 1, -1, -1):\n                if counts[card + i] < counts[card]:\n                    return False\n                counts[card + i] -= counts[card]\n\n    return True\n\n"}
{"prompt": "def simplifyPath(path: str) -> str:\n    \"\"\"\n    Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n    In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n    The canonical path should have the following format:\n\n    The path starts with a single slash '/'.\n    Any two directories are separated by a single slash '/'.\n    The path does not end with a trailing '/'.\n    The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n\n    Return the simplified canonical path.\n\u00a0\n    Example 1:\n\n    Input: path = \"/home/\"\n    Output: \"/home\"\n    Explanation: Note that there is no trailing slash after the last directory name.\n\n    Example 2:\n\n    Input: path = \"/../\"\n    Output: \"/\"\n    Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\n    Example 3:\n\n    Input: path = \"/home//foo/\"\n    Output: \"/home/foo\"\n    Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n\n\u00a0\n    Constraints:\n\n    1 <= path.length <= 3000\n    path consists of English letters, digits, period '.', slash '/' or '_'.\n    path is a valid absolute Unix path.\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n\n"}
{"prompt": "from typing import List\n\n\ndef max_dist_to_closest(seats: List[int]) -> int:\n    \"\"\"\n    You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\n    There is at least one empty seat, and at least one person sitting.\n    Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\u00a0\n    Return that maximum distance to the closest person.\n\u00a0\n    Example 1:\n\n\n    Input: seats = [1,0,0,0,1,0,1]\n    Output: 2\n    Explanation: \n    If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\n    If Alex sits in any other open seat, the closest person has distance 1.\n    Thus, the maximum distance to the closest person is 2.\n\n    Example 2:\n\n    Input: seats = [1,0,0,0]\n    Output: 3\n    Explanation: \n    If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\n    This is the maximum distance possible, so the answer is 3.\n\n    Example 3:\n\n    Input: seats = [0,1]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    2 <= seats.length <= 2 * 104\n    seats[i]\u00a0is 0 or\u00a01.\n    At least one seat is empty.\n    At least one seat is occupied.\n\n    \"\"\"\n", "canonical_solution": "    max_dist = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)\n            last_person = i\n    return max(max_dist, len(seats) - 1 - last_person)\n\n"}
{"prompt": "from typing import List\n\n\ndef peakIndexInMountainArray(arr: List[int]) -> int:\n    \"\"\"\n    An array arr is a mountain if the following properties hold:\n\n    arr.length >= 3\n    There exists some i with 0 < i < arr.length - 1 such that:\n\n    arr[0] < arr[1] < ... < arr[i - 1] < arr[i] \n    arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n    Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].\n    You must solve it in O(log(arr.length)) time complexity.\n\u00a0\n    Example 1:\n\n    Input: arr = [0,1,0]\n    Output: 1\n\n    Example 2:\n\n    Input: arr = [0,2,1,0]\n    Output: 1\n\n    Example 3:\n\n    Input: arr = [0,10,5,2]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    3 <= arr.length <= 105\n    0 <= arr[i] <= 106\n    arr is guaranteed to be a mountain array.\n\n    \"\"\"\n", "canonical_solution": "    low, high = 0, len(arr) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n"}
{"prompt": "def scoreOfParentheses(s: str) -> int:\n    \"\"\"\n    Given a balanced parentheses string s, return the score of the string.\n    The score of a balanced parentheses string is based on the following rule:\n\n    \"()\" has score 1.\n    AB has score A + B, where A and B are balanced parentheses strings.\n    (A) has score 2 * A, where A is a balanced parentheses string.\n\n\u00a0\n    Example 1:\n\n    Input: s = \"()\"\n    Output: 1\n\n    Example 2:\n\n    Input: s = \"(())\"\n    Output: 2\n\n    Example 3:\n\n    Input: s = \"()()\"\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    2 <= s.length <= 50\n    s consists of only '(' and ')'.\n    s is a balanced parentheses string.\n\n    \"\"\"\n", "canonical_solution": "    score, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if s[i - 1] == '(':\n                score += 1 << depth\n    return score\n\n"}
{"prompt": "from typing import List\n\n\ndef matrixScore(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n binary matrix grid.\n    A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\n    Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\n    Return the highest possible score after making any number of moves (including zero moves).\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n    Output: 39\n    Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n    Example 2:\n\n    Input: grid = [[0]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 20\n    grid[i][j] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        if grid[i][0] == 0:\n            for j in range(n):\n                grid[i][j] = 1 - grid[i][j]\n    for j in range(1, n):\n        count = sum(grid[i][j] for i in range(m))\n        if count <= m // 2:\n            for i in range(m):\n                grid[i][j] = 1 - grid[i][j]\n    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))\n\n"}
{"prompt": "def prime_palindrome(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the smallest prime palindrome greater than or equal to n.\n    An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n    For example, 2, 3, 5, 7, 11, and 13 are all primes.\n\n    An integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n    For example, 101 and 12321 are palindromes.\n\n    The test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n\u00a0\n    Example 1:\n    Input: n = 6\n    Output: 7\n    Example 2:\n    Input: n = 8\n    Output: 11\n    Example 3:\n    Input: n = 13\n    Output: 101\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 108\n\n    \"\"\"\n", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 1\n        return True\n    while True:\n        if is_prime(n) and is_palindrome(n):\n            return n\n        n += 1\n\n"}
{"prompt": "def reorderedPowerOf2(n: int) -> bool:\n    \"\"\"\n    You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero.\n    Return true if and only if we can do this so that the resulting number is a power of two.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: true\n\n    Example 2:\n\n    Input: n = 10\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 109\n\n    \"\"\"\n", "canonical_solution": "    from itertools import permutations as perm\n    for p in set(perm(str(n))):\n        if p[0] != '0' and (bin(int(''.join(p))).count('1') == 1):\n            return True\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef lenLongestFibSubseq(arr: List[int]) -> int:\n    \"\"\"\n    A sequence x1, x2, ..., xn is Fibonacci-like if:\n\n    n >= 3\n    xi + xi+1 == xi+2 for all i + 2 <= n\n\n    Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\n    A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2,3,4,5,6,7,8]\n    Output: 5\n    Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].\n    Example 2:\n\n    Input: arr = [1,3,7,11,12,14,18]\n    Output: 3\n    Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].\n\u00a0\n    Constraints:\n\n    3 <= arr.length <= 1000\n    1 <= arr[i] < arr[i + 1] <= 109\n\n    \"\"\"\n", "canonical_solution": "    index = {x: i for i, x in enumerate(arr)}\n\n    longest = dict()\n    ans = 0\n\n    for k, z in enumerate(arr):\n        for j, y in enumerate(arr[:k]):\n            i = index.get(z - y, None)\n            if i is not None and i < j:\n                longest[j, k] = longest.get((i, j), 1) + 1\n                ans = max(ans, longest[j, k] + 1)\n\n    return ans if ans >= 3 else 0\n\n"}
{"prompt": "from typing import List\n\n\ndef minEatingSpeed(piles: List[int], h: int) -> int:\n    \"\"\"\n    Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n    Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n    Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n    Return the minimum integer k such that she can eat all the bananas within h hours.\n\u00a0\n    Example 1:\n\n    Input: piles = [3,6,7,11], h = 8\n    Output: 4\n\n    Example 2:\n\n    Input: piles = [30,11,23,4,20], h = 5\n    Output: 30\n\n    Example 3:\n\n    Input: piles = [30,11,23,4,20], h = 6\n    Output: 23\n\n\u00a0\n    Constraints:\n\n    1 <= piles.length <= 104\n    piles.length <= h <= 109\n    1 <= piles[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    left, right = 1, max(piles)\n    while left < right:\n        mid = left + (right - left) // 2\n        totalHours = sum((pile + mid - 1) // mid for pile in piles)\n        if totalHours > h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n"}
{"prompt": "from typing import List\n\n\ndef num_rescue_boats(people: List[int], limit: int) -> int:\n    \"\"\"\n    You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\n    Return the minimum number of boats to carry every given person.\n\u00a0\n    Example 1:\n\n    Input: people = [1,2], limit = 3\n    Output: 1\n    Explanation: 1 boat (1, 2)\n\n    Example 2:\n\n    Input: people = [3,2,2,1], limit = 3\n    Output: 3\n    Explanation: 3 boats (1, 2), (2) and (3)\n\n    Example 3:\n\n    Input: people = [3,5,3,4], limit = 5\n    Output: 4\n    Explanation: 4 boats (3), (3), (4), (5)\n\n\u00a0\n    Constraints:\n\n    1 <= people.length <= 5 * 104\n    1 <= people[i] <= limit <= 3 * 104\n\n    \"\"\"\n", "canonical_solution": "    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats\n\n"}
{"prompt": "from typing import List\n\n\ndef possible_bipartition(n: int, dislikes: List[List[int]]) -> bool:\n    \"\"\"\n    We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.\n    Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.\n\u00a0\n    Example 1:\n\n    Input: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n    Output: true\n    Explanation: The first group has [1,4], and the second group has [2,3].\n\n    Example 2:\n\n    Input: n = 3, dislikes = [[1,2],[1,3],[2,3]]\n    Output: false\n    Explanation: We need at least 3 groups to divide them. We cannot put them in two groups.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 2000\n    0 <= dislikes.length <= 104\n    dislikes[i].length == 2\n    1 <= ai < bi <= n\n    All the pairs of dislikes are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n\n    def dfs(person, group):\n        if person in groups:\n            return groups[person] == group\n        groups[person] = group\n        for other in dislike_list[person]:\n            if not dfs(other, -group):\n                return False\n        return True\n\n    groups = {}\n    dislike_list = defaultdict(list)\n    for p1, p2 in dislikes:\n        dislike_list[p1].append(p2)\n        dislike_list[p2].append(p1)\n\n    for person in range(1, n + 1):\n        if person not in groups and not dfs(person, 1):\n            return False\n\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef totalFruit(fruits: List[str]) -> int:\n    \"\"\"\n    You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\n    You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\n    You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\n    Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n    Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\n\n    Given the integer array fruits, return the maximum number of fruits you can pick.\n\u00a0\n    Example 1:\n\n    Input: fruits = [1,2,1]\n    Output: 3\n    Explanation: We can pick from all 3 trees.\n\n    Example 2:\n\n    Input: fruits = [0,1,2,2]\n    Output: 3\n    Explanation: We can pick from trees [1,2,2].\n    If we had started at the first tree, we would only pick from trees [0,1].\n\n    Example 3:\n\n    Input: fruits = [1,2,3,2,2]\n    Output: 4\n    Explanation: We can pick from trees [2,3,2,2].\n    If we had started at the first tree, we would only pick from trees [1,2].\n\n\u00a0\n    Constraints:\n\n    1 <= fruits.length <= 105\n    0 <= fruits[i] < fruits.length\n\n    \"\"\"\n", "canonical_solution": "    left, right, max_count = 0, 0, 0\n    count = {}\n\n    while right < len(fruits):\n        count[fruits[right]] = count.get(fruits[right], 0) + 1\n        while len(count) > 2:\n            count[fruits[left]] -= 1\n            if count[fruits[left]] == 0:\n                del count[fruits[left]]\n            left += 1\n        max_count = max(max_count, right - left + 1)\n        right += 1\n\n    return max_count\n\n"}
{"prompt": "def myAtoi(s: str) -> int:\n    \"\"\"\n    Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n    The algorithm for myAtoi(string s) is as follows:\n\n    Read in and ignore any leading whitespace.\n    Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n    Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n    Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n    If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n    Return the integer as the final result.\n\n    Note:\n\n    Only the space character ' ' is considered a whitespace character.\n    Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n\u00a0\n    Example 1:\n\n    Input: s = \"42\"\n    Output: 42\n    Explanation: The underlined characters are what is read in, the caret is the current reader position.\n    Step 1: \"42\" (no characters read because there is no leading whitespace)\n             ^\n    Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n             ^\n    Step 3: \"42\" (\"42\" is read in)\n               ^\n    The parsed integer is 42.\n    Since 42 is in the range [-231, 231 - 1], the final result is 42.\n\n    Example 2:\n\n    Input: s = \"   -42\"\n    Output: -42\n    Explanation:\n    Step 1: \"   -42\" (leading whitespace is read and ignored)\n                ^\n    Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                 ^\n    Step 3: \"   -42\" (\"42\" is read in)\n                   ^\n    The parsed integer is -42.\n    Since -42 is in the range [-231, 231 - 1], the final result is -42.\n\n    Example 3:\n\n    Input: s = \"4193 with words\"\n    Output: 4193\n    Explanation:\n    Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n             ^\n    Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n             ^\n    Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                 ^\n    The parsed integer is 4193.\n    Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n\n\u00a0\n    Constraints:\n\n    0 <= s.length <= 200\n    s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n\n    \"\"\"\n", "canonical_solution": "    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ':\n        i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1:\n            return 2**31 - 1\n        if result * sign < -2**31:\n            return -2**31\n    return result * sign\n\n"}
{"prompt": "from typing import List\n\n\ndef partitionDisjoint(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\n\n    Every element in left is less than or equal to every element in right.\n    left and right are non-empty.\n    left has the smallest possible size.\n\n    Return the length of left after such a partitioning.\n    Test cases are generated such that partitioning exists.\n\u00a0\n    Example 1:\n\n    Input: nums = [5,0,3,8,6]\n    Output: 3\n    Explanation: left = [5,0,3], right = [8,6]\n\n    Example 2:\n\n    Input: nums = [1,1,1,0,6,12]\n    Output: 4\n    Explanation: left = [1,1,1,0], right = [6,12]\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 105\n    0 <= nums[i] <= 106\n    There is at least one valid answer for the given input.\n\n    \"\"\"\n", "canonical_solution": "    left_max, global_max, left_length = nums[0], nums[0], 1\n    for i in range(1, len(nums)):\n        if nums[i] < left_max:\n            left_max = global_max\n            left_length = i + 1\n        else:\n            global_max = max(global_max, nums[i])\n    return left_length\n\n"}
{"prompt": "from typing import List\n\n\ndef word_subsets(words1: List[str], words2: List[str]) -> List[str]:\n    \"\"\"\n    You are given two string arrays words1 and words2.\n    A string b is a subset of string a if every letter in b occurs in a including multiplicity.\n\n    For example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n\n    A string a from words1 is universal if for every string b in words2, b is a subset of a.\n    Return an array of all the universal strings in words1. You may return the answer in any order.\n\u00a0\n    Example 1:\n\n    Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\n    Output: [\"facebook\",\"google\",\"leetcode\"]\n\n    Example 2:\n\n    Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\n    Output: [\"apple\",\"google\",\"leetcode\"]\n\n\u00a0\n    Constraints:\n\n    1 <= words1.length, words2.length <= 104\n    1 <= words1[i].length, words2[i].length <= 10\n    words1[i] and words2[i] consist only of lowercase English letters.\n    All the strings of words1 are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import Counter\n    max_chars = Counter()\n    for word in words2:\n        chars = Counter(word)\n        for c, count in chars.items():\n            max_chars[c] = max(max_chars[c], count)\n\n    result = []\n    for word in words1:\n        word_chars = Counter(word)\n        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)\n        if universal:\n            result.append(word)\n\n    return result\n\n"}
{"prompt": "def minAddToMakeValid(s: str) -> int:\n    \"\"\"\n    A parentheses string is valid if and only if:\n\n    It is the empty string,\n    It can be written as AB (A concatenated with B), where A and B are valid strings, or\n    It can be written as (A), where A is a valid string.\n\n    You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\n\n    For example, if s = \"()))\", you can insert an opening parenthesis to be \"(()))\" or a closing parenthesis to be \"())))\".\n\n    Return the minimum number of moves required to make s valid.\n\u00a0\n    Example 1:\n\n    Input: s = \"())\"\n    Output: 1\n\n    Example 2:\n\n    Input: s = \"(((\"\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    s[i] is either '(' or ')'.\n\n    \"\"\"\n", "canonical_solution": "    result = balance = 0\n    for c in s:\n        balance += 1 if c == '(' else -1\n        if balance == -1:\n            result += 1\n            balance += 1\n    return result + balance\n\n"}
{"prompt": "from typing import List\n\n\ndef threeSumMulti(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\n    As the answer can be very large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8\n    Output: 20\n    Explanation: \n    Enumerating by the values (arr[i], arr[j], arr[k]):\n    (1, 2, 5) occurs 8 times;\n    (1, 3, 4) occurs 8 times;\n    (2, 2, 4) occurs 2 times;\n    (2, 3, 3) occurs 2 times.\n\n    Example 2:\n\n    Input: arr = [1,1,2,2,2,2], target = 5\n    Output: 12\n    Explanation: \n    arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\n    We choose one 1 from [1,1] in 2 ways,\n    and two 2s from [2,2,2,2] in 6 ways.\n\n    Example 3:\n\n    Input: arr = [2,1,3], target = 6\n    Output: 1\n    Explanation: (1, 2, 3) occured one time in the array so we return 1.\n\n\u00a0\n    Constraints:\n\n    3 <= arr.length <= 3000\n    0 <= arr[i] <= 100\n    0 <= target <= 300\n\n    \"\"\"\n", "canonical_solution": "    MOD = 1000000007\n    ans = 0\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        j, k = i + 1, n - 1\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s > target:\n                k -= 1\n            elif s < target:\n                j += 1\n            else:\n                if arr[j] != arr[k]:\n                    left_count = right_count = 1\n\n                    while j < n - 1 and arr[j] == arr[j + 1]:\n                        left_count += 1\n                        j += 1\n\n                    while k > 0 and arr[k] == arr[k - 1]:\n                        right_count += 1\n                        k -= 1\n\n                    ans += left_count * right_count\n                    ans %= MOD\n                    j += 1\n                    k -= 1\n                else:\n                    ans += (k - j + 1) * (k - j) // 2\n                    ans %= MOD\n                    break\n\n    return ans\n\n"}
{"prompt": "def minFlipsMonoIncr(s: str) -> int:\n    \"\"\"\n    A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\n    You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\n    Return the minimum number of flips to make s monotone increasing.\n\u00a0\n    Example 1:\n\n    Input: s = \"00110\"\n    Output: 1\n    Explanation: We flip the last digit to get 00111.\n\n    Example 2:\n\n    Input: s = \"010110\"\n    Output: 2\n    Explanation: We flip to get 011111, or alternatively 000111.\n\n    Example 3:\n\n    Input: s = \"00011000\"\n    Output: 2\n    Explanation: We flip to get 00000000.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    s[i] is either '0' or '1'.\n\n    \"\"\"\n", "canonical_solution": "    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount\n\n"}
{"prompt": "from typing import List\n\n\ndef subsets(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given an integer array nums of unique elements, return all possible subsets (the power set).\n    The solution set must not contain duplicate subsets. Return the solution in any order.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3]\n    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n    Example 2:\n\n    Input: nums = [0]\n    Output: [[],[0]]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 10\n    -10 <= nums[i] <= 10\n    All the numbers of\u00a0nums are unique.\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef num_subarrays_with_sum(nums: List[int], goal: int) -> int:\n    \"\"\"\n    Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\n    A subarray is a contiguous part of the array.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,0,1,0,1], goal = 2\n    Output: 4\n    Explanation: The 4 subarrays are bolded and underlined below:\n    [1,0,1,0,1]\n    [1,0,1,0,1]\n    [1,0,1,0,1]\n    [1,0,1,0,1]\n\n    Example 2:\n\n    Input: nums = [0,0,0,0,0], goal = 0\n    Output: 15\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    nums[i] is either 0 or 1.\n    0 <= goal <= nums.length\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1\n    cumulative_sum, result = 0, 0\n\n    for num in nums:\n        cumulative_sum += num\n        result += prefix_sum_count[cumulative_sum - goal]\n        prefix_sum_count[cumulative_sum] += 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef minFallingPathSum(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\n    A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\n\u00a0\n    Example 1:\n\n\n    Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]\n    Output: 13\n    Explanation: There are two falling paths with a minimum sum as shown.\n\n    Example 2:\n\n\n    Input: matrix = [[-19,57],[-40,-5]]\n    Output: -59\n    Explanation: The falling path with a minimum sum is shown.\n\n\u00a0\n    Constraints:\n\n    n == matrix.length == matrix[i].length\n    1 <= n <= 100\n    -100 <= matrix[i][j] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            min_val = matrix[i - 1][j]\n            if j > 0:\n                min_val = min(min_val, matrix[i - 1][j - 1])\n            if j < n - 1:\n                min_val = min(min_val, matrix[i - 1][j + 1])\n            matrix[i][j] += min_val\n    return min(matrix[-1])\n\n"}
{"prompt": "def knightDialer(n: int) -> int:\n    \"\"\"\n    The chess knight has a unique movement,\u00a0it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\n    A chess knight can move as indicated in the chess diagram below:\n\n    We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell\u00a0(i.e. blue cell).\n\n    Given an integer n, return how many distinct phone numbers of length n we can dial.\n    You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\n    As the answer may be very large, return the answer modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: 10\n    Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n    Example 2:\n\n    Input: n = 2\n    Output: 20\n    Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\n    Example 3:\n\n    Input: n = 3131\n    Output: 136006598\n    Explanation: Please take care of the mod.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 5000\n\n    \"\"\"\n", "canonical_solution": "    if n == 1:\n        return 10\n    MOD = 10**9 + 7\n    moves = [\n        [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],\n        [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n    ]\n    dp = [1] * 10\n    for _ in range(2, n + 1):\n        new_dp = [0] * 10\n        for j in range(10):\n            for move in moves[j]:\n                new_dp[j] = (new_dp[j] + dp[move]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\n"}
{"prompt": "from typing import List\n\n\ndef subarraysDivByK(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n    A subarray is a contiguous part of an array.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,5,0,-2,-3,1], k = 5\n    Output: 7\n    Explanation: There are 7 subarrays with a sum divisible by k = 5:\n    [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n    Example 2:\n\n    Input: nums = [5], k = 9\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    -104 <= nums[i] <= 104\n    2 <= k <= 104\n\n    \"\"\"\n", "canonical_solution": "    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n\n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n\n    return count\n\n"}
{"prompt": "from typing import List, Tuple\n\n\ndef min_area_rect(points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n    Return the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.\n\u00a0\n    Example 1:\n\n\n    Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\n    Output: 4\n\n    Example 2:\n\n\n    Input: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= points.length <= 500\n    points[i].length == 2\n    0 <= xi, yi <= 4 * 104\n    All the given points are unique.\n\n    \"\"\"\n", "canonical_solution": "    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0\n\n"}
{"prompt": "from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n    The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\u00a0\n    Example 1:\n\n\n    Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n    Output: true\n\n    Example 2:\n\n\n    Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n    Output: true\n\n    Example 3:\n\n\n    Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n    Output: false\n\n\u00a0\n    Constraints:\n\n    m == board.length\n    n = board[i].length\n    1 <= m, n <= 6\n    1 <= word.length <= 15\n    board and word consists of only lowercase and uppercase English letters.\n\n\u00a0\n    Follow up: Could you use search pruning to make your solution faster with a larger board?\n    \"\"\"\n", "canonical_solution": "    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False\n\n"}
{"prompt": "from typing import List\n\n\ndef validateStackSequences(pushed: List[int], popped: List[int]) -> bool:\n    \"\"\"\n    Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n    Output: true\n    Explanation: We might do the following sequence:\n    push(1), push(2), push(3), push(4),\n    pop() -> 4,\n    push(5),\n    pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n    Example 2:\n\n    Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n    Output: false\n    Explanation: 1 cannot be popped before 2.\n\n\u00a0\n    Constraints:\n\n    1 <= pushed.length <= 1000\n    0 <= pushed[i] <= 1000\n    All the elements of pushed are unique.\n    popped.length == pushed.length\n    popped is a permutation of pushed.\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    popIndex = 0\n\n    for pushValue in pushed:\n        stack.append(pushValue)\n        while stack and stack[-1] == popped[popIndex]:\n            stack.pop()\n            popIndex += 1\n\n    return not stack\n\n"}
{"prompt": "from typing import List\n\n\ndef removeStones(stones: List[List[int]]) -> int:\n    \"\"\"\n    On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\n    A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\n    Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\n\u00a0\n    Example 1:\n\n    Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n    Output: 5\n    Explanation: One way to remove 5 stones is as follows:\n    1. Remove stone [2,2] because it shares the same row as [2,1].\n    2. Remove stone [2,1] because it shares the same column as [0,1].\n    3. Remove stone [1,2] because it shares the same row as [1,0].\n    4. Remove stone [1,0] because it shares the same column as [0,0].\n    5. Remove stone [0,1] because it shares the same row as [0,0].\n    Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n\n    Example 2:\n\n    Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n    Output: 3\n    Explanation: One way to make 3 moves is as follows:\n    1. Remove stone [2,2] because it shares the same row as [2,0].\n    2. Remove stone [2,0] because it shares the same column as [0,0].\n    3. Remove stone [0,2] because it shares the same row as [0,0].\n    Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n\n    Example 3:\n\n    Input: stones = [[0,0]]\n    Output: 0\n    Explanation: [0,0] is the only stone on the plane, so you cannot remove it.\n\n\u00a0\n    Constraints:\n\n    1 <= stones.length <= 1000\n    0 <= xi, yi <= 104\n    No two stones are at the same coordinate point.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    row_groups = defaultdict(int)\n    col_groups = defaultdict(int)\n    group_count = 0\n\n    groups = defaultdict(list)\n\n    for x, y in stones:\n        if x not in row_groups:\n            row_groups[x] = group_count\n            group_count += 1\n        if y + 10001 not in col_groups:  # Offset by max row index\n            col_groups[y + 10001] = group_count\n            group_count += 1\n\n        group_x, group_y = row_groups[x], col_groups[y + 10001]\n        groups[group_x].append(group_y)\n        groups[group_y].append(group_x)\n\n    visited = [False] * group_count\n\n    def dfs(groupId):\n        if visited[groupId]:\n            return 0\n        visited[groupId] = True\n        size = 1\n        for neighbor in groups[groupId]:\n            size += dfs(neighbor)\n        return size\n\n    max_stones = 0\n    for groupId in range(group_count):\n        max_stones += dfs(groupId) - 1\n\n    return max_stones\n\n"}
{"prompt": "from typing import List\n\n\ndef bag_of_tokens_score(tokens: List[int], power: int) -> int:\n    \"\"\"\n    You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).\n    Your goal is to maximize your total score by potentially playing each token in one of two ways:\n\n    If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i] power and gaining 1 score.\n    If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score.\n\n    Each token may be played at most once and in any order. You do not have to play all the tokens.\n    Return the largest possible score you can achieve after playing any number of tokens.\n\u00a0\n    Example 1:\n\n    Input: tokens = [100], power = 50\n    Output: 0\n    Explanation: Playing the only token in the bag is impossible because you either have too little power or too little score.\n\n    Example 2:\n\n    Input: tokens = [100,200], power = 150\n    Output: 1\n    Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1.\n    There is no need to play the 1st token since you cannot play it face up to add to your score.\n\n    Example 3:\n\n    Input: tokens = [100,200,300,400], power = 200\n    Output: 2\n    Explanation: Play the tokens in this order to get a score of 2:\n    1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.\n    2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.\n    3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.\n    4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.\n\n\u00a0\n    Constraints:\n\n    0 <= tokens.length <= 1000\n    0 <= tokens[i],\u00a0power < 104\n\n    \"\"\"\n", "canonical_solution": "    tokens.sort()\n    max_score = score = 0\n    left, right = 0, len(tokens) - 1\n\n    while left <= right:\n        if power >= tokens[left]:\n            power -= tokens[left]\n            left += 1\n            score += 1\n            max_score = max(max_score, score)\n        elif score > 0:\n            power += tokens[right]\n            right -= 1\n            score -= 1\n        else:\n            break\n\n    return max_score\n\n"}
{"prompt": "from typing import List\n\n\ndef largestTimeFromDigits(arr: List[int]) -> str:\n    \"\"\"\n    Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n    24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\n    Return the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2,3,4]\n    Output: \"23:41\"\n    Explanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n\n    Example 2:\n\n    Input: arr = [5,5,5,5]\n    Output: \"\"\n    Explanation: There are no valid 24-hour times as \"55:55\" is not valid.\n\n\u00a0\n    Constraints:\n\n    arr.length == 4\n    0 <= arr[i] <= 9\n\n    \"\"\"\n", "canonical_solution": "    from itertools import permutations\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)\n\n"}
{"prompt": "from typing import List\n\n\ndef deckRevealedIncreasing(deck: List[int]) -> List[int]:\n    \"\"\"\n    You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\n    You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\n    You will do the following steps repeatedly until all cards are revealed:\n\n    Take the top card of the deck, reveal it, and take it out of the deck.\n    If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n    If there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\n    Return an ordering of the deck that would reveal the cards in increasing order.\n    Note that the first entry in the answer is considered to be the top of the deck.\n\u00a0\n    Example 1:\n\n    Input: deck = [17,13,11,2,3,5,7]\n    Output: [2,13,3,11,5,17,7]\n    Explanation: \n    We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\n    After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\n    We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\n    We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\n    We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\n    We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\n    We reveal 11, and move 17 to the bottom.  The deck is now [13,17].\n    We reveal 13, and move 17 to the bottom.  The deck is now [17].\n    We reveal 17.\n    Since all the cards revealed are in increasing order, the answer is correct.\n\n    Example 2:\n\n    Input: deck = [1,1000]\n    Output: [1,1000]\n\n\u00a0\n    Constraints:\n\n    1 <= deck.length <= 1000\n    1 <= deck[i] <= 106\n    All the values of deck are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    n = len(deck)\n    index = deque(range(n))\n    ans = [0] * n\n\n    deck.sort()\n    for card in deck:\n        ans[index.popleft()] = card\n        if index:\n            index.append(index.popleft())\n\n    return ans\n\n"}
{"prompt": "from typing import List\n\n\ndef prisonAfterNDays(cells: List[int], n: int) -> List[int]:\n    \"\"\"\n    There are 8 prison cells in a row and each cell is either occupied or vacant.\n    Each day, whether the cell is occupied or vacant changes according to the following rules:\n\n    If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.\n    Otherwise, it becomes vacant.\n\n    Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.\n    You are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n.\n    Return the state of the prison after n days (i.e., n such changes described above).\n\u00a0\n    Example 1:\n\n    Input: cells = [0,1,0,1,1,0,0,1], n = 7\n    Output: [0,0,1,1,0,0,0,0]\n    Explanation: The following table summarizes the state of the prison on each day:\n    Day 0: [0, 1, 0, 1, 1, 0, 0, 1]\n    Day 1: [0, 1, 1, 0, 0, 0, 0, 0]\n    Day 2: [0, 0, 0, 0, 1, 1, 1, 0]\n    Day 3: [0, 1, 1, 0, 0, 1, 0, 0]\n    Day 4: [0, 0, 0, 0, 0, 1, 0, 0]\n    Day 5: [0, 1, 1, 1, 0, 1, 0, 0]\n    Day 6: [0, 0, 1, 0, 1, 1, 0, 0]\n    Day 7: [0, 0, 1, 1, 0, 0, 0, 0]\n\n    Example 2:\n\n    Input: cells = [1,0,0,1,0,0,1,0], n = 1000000000\n    Output: [0,0,1,1,1,1,1,0]\n\n\u00a0\n    Constraints:\n\n    cells.length == 8\n    cells[i]\u00a0is either 0 or 1.\n    1 <= n <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = n % 14 if n % 14 != 0 else 14  # Pattern repeats every 14 days\n\n    for _ in range(n):\n        temp = [0] * 8\n        for i in range(1, 7):\n            temp[i] = int(cells[i - 1] == cells[i + 1])\n        cells = temp\n\n    return cells\n\n"}
{"prompt": "from typing import List\n\n\ndef minAreaFreeRect(points: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n    Return the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0.\n    Answers within 10-5 of the actual answer will be accepted.\n\u00a0\n    Example 1:\n\n\n    Input: points = [[1,2],[2,1],[1,0],[0,1]]\n    Output: 2.00000\n    Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\n    Example 2:\n\n\n    Input: points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\n    Output: 1.00000\n    Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\n    Example 3:\n\n\n    Input: points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\n    Output: 0\n    Explanation: There is no possible rectangle to form from these points.\n\n\u00a0\n    Constraints:\n\n    1 <= points.length <= 50\n    points[i].length == 2\n    0 <= xi, yi <= 4 * 104\n    All the given points are unique.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    from math import sqrt, inf\n    minArea = inf\n    xGroups = defaultdict(set)\n\n    for x, y in points:\n        xGroups[x].add(y)\n\n    for x1, ys1 in xGroups.items():\n        for x2, ys2 in xGroups.items():\n            if x1 == x2:\n                continue\n\n            for y1 in ys1:\n                for y2 in ys2:\n                    if y2 in ys1 and y1 in ys2:\n                        area = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) * sqrt((x1 - x2) ** 2 + (y1 - y1) ** 2)\n                        minArea = min(minArea, area)\n\n    return minArea if minArea != inf else 0\n\n"}
{"prompt": "from typing import List\n\n\ndef pancakeSort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers arr, sort the array by performing a series of pancake flips.\n    In one pancake flip we do the following steps:\n\n    Choose an integer k where 1 <= k <= arr.length.\n    Reverse the sub-array arr[0...k-1] (0-indexed).\n\n    For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\n    Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\n\u00a0\n    Example 1:\n\n    Input: arr = [3,2,4,1]\n    Output: [4,2,4,3]\n    Explanation: \n    We perform 4 pancake flips, with k values 4, 2, 4, and 3.\n    Starting state: arr = [3, 2, 4, 1]\n    After 1st flip (k = 4): arr = [1, 4, 2, 3]\n    After 2nd flip (k = 2): arr = [4, 1, 2, 3]\n    After 3rd flip (k = 4): arr = [3, 2, 1, 4]\n    After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.\n\n    Example 2:\n\n    Input: arr = [1,2,3]\n    Output: []\n    Explanation: The input is already sorted, so there is no need to flip anything.\n    Note that other answers, such as [3, 3], would also be accepted.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 100\n    1 <= arr[i] <= arr.length\n    All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).\n\n    \"\"\"\n", "canonical_solution": "    flips = []\n    for size in range(len(arr), 1, -1):\n        maxIdx = arr.index(max(arr[:size]))\n        flips.extend([maxIdx + 1, size])\n        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])\n        arr[:size] = reversed(arr[:size])\n    return flips\n\n"}
{"prompt": "from typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n    The distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\n    You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n\u00a0\n    Example 1:\n\n\n    Input: points = [[1,3],[-2,2]], k = 1\n    Output: [[-2,2]]\n    Explanation:\n    The distance between (1, 3) and the origin is sqrt(10).\n    The distance between (-2, 2) and the origin is sqrt(8).\n    Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\n    We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n    Example 2:\n\n    Input: points = [[3,3],[5,-1],[-2,4]], k = 2\n    Output: [[3,3],[-2,4]]\n    Explanation: The answer [[-2,4],[3,3]] would also be accepted.\n\n\u00a0\n    Constraints:\n\n    1 <= k <= points.length <= 104\n    -104 <= xi, yi <= 104\n\n    \"\"\"\n", "canonical_solution": "    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    return points[:k]\n\n"}
{"prompt": "from typing import List\n\n\ndef subarraysDivByK(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n    A subarray is a contiguous part of an array.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,5,0,-2,-3,1], k = 5\n    Output: 7\n    Explanation: There are 7 subarrays with a sum divisible by k = 5:\n    [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n    Example 2:\n\n    Input: nums = [5], k = 9\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    -104 <= nums[i] <= 104\n    2 <= k <= 104\n\n    \"\"\"\n", "canonical_solution": "    counts = {0: 1}\n    sum_, result = 0, 0\n\n    for num in nums:\n        sum_ += num\n        mod = (sum_ % k + k) % k\n        result += counts.get(mod, 0)\n        counts[mod] = counts.get(mod, 0) + 1\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maxTurbulenceSize(arr: List[int]) -> int:\n    \"\"\"\n    Given an integer array arr, return the length of a maximum size turbulent subarray of arr.\n    A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\n    More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:\n\n    For i <= k < j:\n\n\n    arr[k] > arr[k + 1] when k is odd, and\n    arr[k] < arr[k + 1] when k is even.\n\n\n    Or, for i <= k < j:\n\n    arr[k] > arr[k + 1] when k is even, and\n    arr[k] < arr[k + 1] when k is odd.\n\n\n\n\u00a0\n    Example 1:\n\n    Input: arr = [9,4,2,10,7,8,8,1,9]\n    Output: 5\n    Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\n    Example 2:\n\n    Input: arr = [4,8,12,16]\n    Output: 2\n\n    Example 3:\n\n    Input: arr = [100]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 4 * 104\n    0 <= arr[i] <= 109\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n\n        result = max(result, j - i + 1)\n        i = j\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef mincostTickets(days: List[int], costs: List[int]) -> int:\n    \"\"\"\n    You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\n    Train tickets are sold in three different ways:\n\n    a 1-day pass is sold for costs[0] dollars,\n    a 7-day pass is sold for costs[1] dollars, and\n    a 30-day pass is sold for costs[2] dollars.\n\n    The passes allow that many days of consecutive travel.\n\n    For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\n    Return the minimum number of dollars you need to travel every day in the given list of days.\n\u00a0\n    Example 1:\n\n    Input: days = [1,4,6,7,8,20], costs = [2,7,15]\n    Output: 11\n    Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\n    On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\n    On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\n    On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\n    In total, you spent $11 and covered all the days of your travel.\n\n    Example 2:\n\n    Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n    Output: 17\n    Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\n    On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\n    On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\n    In total, you spent $17 and covered all the days of your travel.\n\n\u00a0\n    Constraints:\n\n    1 <= days.length <= 365\n    1 <= days[i] <= 365\n    days is in strictly increasing order.\n    costs.length == 3\n    1 <= costs[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    travel_days = set(days)\n    dp = [0] * 366\n\n    for i in range(1, 366):\n        if i not in travel_days:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = min(dp[i - 1] + costs[0],\n                        dp[max(0, i - 7)] + costs[1],\n                        dp[max(0, i - 30)] + costs[2])\n\n    return dp[365]\n\n"}
{"prompt": "from typing import List\n\n\ndef equationsPossible(equations: List[str]) -> bool:\n    \"\"\"\n    You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\n    Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: equations = [\"a==b\",\"b!=a\"]\n    Output: false\n    Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\n    There is no way to assign the variables to satisfy both equations.\n\n    Example 2:\n\n    Input: equations = [\"b==a\",\"a==b\"]\n    Output: true\n    Explanation: We could assign a = 1 and b = 1 to satisfy both equations.\n\n\u00a0\n    Constraints:\n\n    1 <= equations.length <= 500\n    equations[i].length == 4\n    equations[i][0] is a lowercase letter.\n    equations[i][1] is either '=' or '!'.\n    equations[i][2] is '='.\n    equations[i][3] is a lowercase letter.\n\n    \"\"\"\n", "canonical_solution": "    parent = [i for i in range(26)]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    for e in equations:\n        if e[1] == '=':\n            x = ord(e[0]) - ord('a')\n            y = ord(e[3]) - ord('a')\n            parent[find(x)] = find(y)\n\n    for e in equations:\n        if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):\n            return False\n\n    return True\n\n"}
{"prompt": "from typing import List\n\n\ndef orangesRotting(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n grid where each cell can have one of three values:\n\n    0 representing an empty cell,\n    1 representing a fresh orange, or\n    2 representing a rotten orange.\n\n    Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n    Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[2,1,1],[1,1,0],[0,1,1]]\n    Output: 4\n\n    Example 2:\n\n    Input: grid = [[2,1,1],[0,1,1],[1,0,1]]\n    Output: -1\n    Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n    Example 3:\n\n    Input: grid = [[0,2]]\n    Output: 0\n    Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 10\n    grid[i][j] is 0, 1, or 2.\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n\n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1\n\n"}
{"prompt": "from typing import List\n\n\ndef longestOnes(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n    Output: 6\n    Explanation: [1,1,1,0,0,1,1,1,1,1,1]\n    Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n    Example 2:\n\n    Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n    Output: 10\n    Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n    Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    nums[i] is either 0 or 1.\n    0 <= k <= nums.length\n\n    \"\"\"\n", "canonical_solution": "    left, right, max_ones, zero_count = 0, 0, 0, 0\n    while right < len(nums):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n        right += 1\n    return max_ones\n\n"}
{"prompt": "def clumsy(n: int) -> int:\n    \"\"\"\n    The factorial of a positive integer n is the product of all positive integers less than or equal to n.\n\n    For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\n\n    We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.\n\n    For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.\n\n    However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\n    Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.\n    Given an integer n, return the clumsy factorial of n.\n\u00a0\n    Example 1:\n\n    Input: n = 4\n    Output: 7\n    Explanation: 7 = 4 * 3 / 2 + 1\n\n    Example 2:\n\n    Input: n = 10\n    Output: 12\n    Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 104\n\n    \"\"\"\n", "canonical_solution": "    if n <= 2:\n        return n\n    if n == 3:\n        return 6\n    result = n * (n - 1) // (n - 2) + (n - 3)\n    n -= 4\n    while n >= 4:\n        result = result - (n * (n - 1) // (n - 2)) + (n - 3)\n        n -= 4\n    return result - clumsy(n)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSatisfied(customers: List[int], grumpy: List[int], minutes: int) -> int:\n    \"\"\"\n    There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\n    On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\n    When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n    The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\n    Return the maximum number of customers that can be satisfied throughout the day.\n\u00a0\n    Example 1:\n\n    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n    Output: 16\n    Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \n    The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n    Example 2:\n\n    Input: customers = [1], grumpy = [0], minutes = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    n == customers.length == grumpy.length\n    1 <= minutes <= n <= 2 * 104\n    0 <= customers[i] <= 1000\n    grumpy[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers\n\n"}
{"prompt": "from typing import List\n\n\ndef prevPermOpt1(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array.\n    Note that a swap exchanges the positions of two numbers arr[i] and arr[j]\n\u00a0\n    Example 1:\n\n    Input: arr = [3,2,1]\n    Output: [3,1,2]\n    Explanation: Swapping 2 and 1.\n\n    Example 2:\n\n    Input: arr = [1,1,5]\n    Output: [1,1,5]\n    Explanation: This is already the smallest permutation.\n\n    Example 3:\n\n    Input: arr = [1,9,4,6,7]\n    Output: [1,7,4,6,9]\n    Explanation: Swapping 9 and 7.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 104\n    1 <= arr[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr\n\n"}
{"prompt": "from typing import List\n\n\ndef num_pairs_divisible_by60(time: List[int]) -> int:\n    \"\"\"\n    You are given a list of songs where the ith song has a duration of time[i] seconds.\n    Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.\n\u00a0\n    Example 1:\n\n    Input: time = [30,20,150,100,40]\n    Output: 3\n    Explanation: Three pairs have a total duration divisible by 60:\n    (time[0] = 30, time[2] = 150): total duration 180\n    (time[1] = 20, time[3] = 100): total duration 120\n    (time[1] = 20, time[4] = 40): total duration 60\n\n    Example 2:\n\n    Input: time = [60,60,60]\n    Output: 3\n    Explanation: All three pairs have a total duration of 120, which is divisible by 60.\n\n\u00a0\n    Constraints:\n\n    1 <= time.length <= 6 * 104\n    1 <= time[i] <= 500\n\n    \"\"\"\n", "canonical_solution": "    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    return pairs\n\n"}
{"prompt": "from typing import List\n\n\ndef grayCode(n: int) -> List[int]:\n    \"\"\"\n    An n-bit gray code sequence is a sequence of 2n integers where:\n\n    Every integer is in the inclusive range [0, 2n - 1],\n    The first integer is 0,\n    An integer appears no more than once in the sequence,\n    The binary representation of every pair of adjacent integers differs by exactly one bit, and\n    The binary representation of the first and last integers differs by exactly one bit.\n\n    Given an integer n, return any valid n-bit gray code sequence.\n\u00a0\n    Example 1:\n\n    Input: n = 2\n    Output: [0,1,3,2]\n    Explanation:\n    The binary representation of [0,1,3,2] is [00,01,11,10].\n    - 00 and 01 differ by one bit\n    - 01 and 11 differ by one bit\n    - 11 and 10 differ by one bit\n    - 10 and 00 differ by one bit\n    [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n    - 00 and 10 differ by one bit\n    - 10 and 11 differ by one bit\n    - 11 and 01 differ by one bit\n    - 01 and 00 differ by one bit\n\n    Example 2:\n\n    Input: n = 1\n    Output: [0,1]\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 16\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maxScoreSightseeingPair(values: List[int]) -> int:\n    \"\"\"\n    You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.\n    The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.\n    Return the maximum score of a pair of sightseeing spots.\n\u00a0\n    Example 1:\n\n    Input: values = [8,1,5,2,6]\n    Output: 11\n    Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n    Example 2:\n\n    Input: values = [1,2]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    2 <= values.length <= 5 * 104\n    1 <= values[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    max_score = 0\n    max_score_left = values[0] + 0\n    for j in range(1, len(values)):\n        max_score = max(max_score, max_score_left + values[j] - j)\n        max_score_left = max(max_score_left, values[j] + j)\n    return max_score\n\n"}
{"prompt": "from typing import List\n\n\ndef videoStitching(clips: List[List[int]], time: int) -> int:\n    \"\"\"\n    You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\n    Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\n    We can cut these clips into segments freely.\n\n    For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\n\n    Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\n\u00a0\n    Example 1:\n\n    Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\n    Output: 3\n    Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\n    Then, we can reconstruct the sporting event as follows:\n    We cut [1,9] into segments [1,2] + [2,8] + [8,9].\n    Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\n\n    Example 2:\n\n    Input: clips = [[0,1],[1,2]], time = 5\n    Output: -1\n    Explanation: We cannot cover [0,5] with only [0,1] and [1,2].\n\n    Example 3:\n\n    Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\n    Output: 3\n    Explanation: We can take clips [0,4], [4,7], and [6,9].\n\n\u00a0\n    Constraints:\n\n    1 <= clips.length <= 100\n    0 <= starti <= endi <= 100\n    1 <= time <= 100\n\n    \"\"\"\n", "canonical_solution": "    dp = [float('inf')] * (time + 1)\n    dp[0] = 0\n    for i in range(1, time + 1):\n        for clip in clips:\n            if clip[0] < i and i <= clip[1]:\n                dp[i] = min(dp[i], dp[clip[0]] + 1)\n    return -1 if dp[time] == float('inf') else dp[time]\n\n"}
{"prompt": "from typing import List\n\n\ndef longestArithSeqLength(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of integers, return the length of the longest arithmetic subsequence in nums.\n    Note that:\n\n    A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n    A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).\n\n\u00a0\n    Example 1:\n\n    Input: nums = [3,6,9,12]\n    Output: 4\n    Explanation:  The whole array is an arithmetic sequence with steps of length = 3.\n\n    Example 2:\n\n    Input: nums = [9,4,7,2,10]\n    Output: 3\n    Explanation:  The longest arithmetic subsequence is [4,7,10].\n\n    Example 3:\n\n    Input: nums = [20,1,15,3,10,5,8]\n    Output: 4\n    Explanation:  The longest arithmetic subsequence is [20,15,10,5].\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 1000\n    0 <= nums[i] <= 500\n\n    \"\"\"\n", "canonical_solution": "    n = len(nums)\n    longest = 0\n    dp = [{} for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            longest = max(longest, dp[i][diff])\n\n    return longest\n\n"}
{"prompt": "from typing import List\n\n\ndef twoCitySchedCost(costs: List[List[int]]) -> int:\n    \"\"\"\n    A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti],\u00a0the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti.\n    Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.\n\u00a0\n    Example 1:\n\n    Input: costs = [[10,20],[30,200],[400,50],[30,20]]\n    Output: 110\n    Explanation: \n    The first person goes to city A for a cost of 10.\n    The second person goes to city A for a cost of 30.\n    The third person goes to city B for a cost of 50.\n    The fourth person goes to city B for a cost of 20.\n\n    The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\n    Example 2:\n\n    Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\n    Output: 1859\n\n    Example 3:\n\n    Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\n    Output: 3086\n\n\u00a0\n    Constraints:\n\n    2 * n == costs.length\n    2 <= costs.length <= 100\n    costs.length is even.\n    1 <= aCosti, bCosti <= 1000\n\n    \"\"\"\n", "canonical_solution": "    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    return totalCost\n\n"}
{"prompt": "from typing import List\n\n\ndef colorBorder(grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n    \"\"\"\n    You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\n    Two squares are called adjacent if they are next to each other in any of the 4 directions.\n    Two squares belong to the same connected component if they have the same color and they are adjacent.\n    The border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\n    You should color the border of the connected component that contains the square grid[row][col] with color.\n    Return the final grid.\n\u00a0\n    Example 1:\n    Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n    Output: [[3,3],[3,2]]\n    Example 2:\n    Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n    Output: [[1,3,3],[2,3,3]]\n    Example 3:\n    Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n    Output: [[2,2,2],[2,1,2],[2,2,2]]\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 50\n    1 <= grid[i][j], color <= 1000\n    0 <= row < m\n    0 <= col < n\n\n    \"\"\"\n", "canonical_solution": "    def dfs(grid, row, col, current, color):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:\n            return\n\n        grid[row][col] = color\n        dfs(grid, row - 1, col, current, color)\n        dfs(grid, row + 1, col, current, color)\n        dfs(grid, row, col - 1, current, color)\n        dfs(grid, row, col + 1, current, color)\n\n    current = grid[row][col]\n    if current == color:\n        return grid\n\n    dfs(grid, row, col, current, color + 1000)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > 1000:\n                grid[i][j] -= 1000\n\n    return grid\n\n"}
{"prompt": "from typing import List\n\n\ndef max_uncrossed_lines(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.\n    We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:\n\n    nums1[i] == nums2[j], and\n    the line we draw does not intersect any other connecting (non-horizontal) line.\n\n    Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n    Return the maximum number of connecting lines we can draw in this way.\n\u00a0\n    Example 1:\n\n\n    Input: nums1 = [1,4,2], nums2 = [1,2,4]\n    Output: 2\n    Explanation: We can draw 2 uncrossed lines as in the diagram.\n    We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n\n    Example 2:\n\n    Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n    Output: 3\n\n    Example 3:\n\n    Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= nums1.length, nums2.length <= 500\n    1 <= nums1[i], nums2[j] <= 2000\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n"}
{"prompt": "from typing import List\n\n\ndef corpFlightBookings(bookings: List[List[int]], n: int) -> List[int]:\n    \"\"\"\n    There are n flights that are labeled from 1 to n.\n    You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\n    Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\n\u00a0\n    Example 1:\n\n    Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n    Output: [10,55,45,25,25]\n    Explanation:\n    Flight labels:        1   2   3   4   5\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      20  20\n    Booking 3 reserved:      25  25  25  25\n    Total seats:         10  55  45  25  25\n    Hence, answer = [10,55,45,25,25]\n\n    Example 2:\n\n    Input: bookings = [[1,2,10],[2,2,15]], n = 2\n    Output: [10,25]\n    Explanation:\n    Flight labels:        1   2\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      15\n    Total seats:         10  25\n    Hence, answer = [10,25]\n\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 2 * 104\n    1 <= bookings.length <= 2 * 104\n    bookings[i].length == 3\n    1 <= firsti <= lasti <= n\n    1 <= seatsi <= 104\n\n    \"\"\"\n", "canonical_solution": "    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n    return seats\n\n"}
{"prompt": "from typing import List\n\n\ndef minScoreTriangulation(values: List[int]) -> int:\n    \"\"\"\n    You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\n    You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\n    Return the smallest possible total score that you can achieve with some triangulation of the polygon.\n\u00a0\n    Example 1:\n\n\n    Input: values = [1,2,3]\n    Output: 6\n    Explanation: The polygon is already triangulated, and the score of the only triangle is 6.\n\n    Example 2:\n\n\n    Input: values = [3,7,4,5]\n    Output: 144\n    Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\n    The minimum score is 144.\n\n    Example 3:\n\n\n    Input: values = [1,3,1,4,1,5]\n    Output: 13\n    Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.\n\n\u00a0\n    Constraints:\n\n    n == values.length\n    3 <= n <= 50\n    1 <= values[i] <= 100\n\n    \"\"\"\n", "canonical_solution": "    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j])\n\n    return dp[0][n - 1]\n\n"}
{"prompt": "def is_robot_bounded(instructions: str) -> bool:\n    \"\"\"\n    On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:\n\n    The north direction is the positive direction of the y-axis.\n    The south direction is the negative direction of the y-axis.\n    The east direction is the positive direction of the x-axis.\n    The west direction is the negative direction of the x-axis.\n\n    The robot can receive one of three instructions:\n\n    \"G\": go straight 1 unit.\n    \"L\": turn 90 degrees to the left (i.e., anti-clockwise direction).\n    \"R\": turn 90 degrees to the right (i.e., clockwise direction).\n\n    The robot performs the instructions given in order, and repeats them forever.\n    Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n\u00a0\n    Example 1:\n\n    Input: instructions = \"GGLLGG\"\n    Output: true\n    Explanation: The robot is initially at (0, 0) facing the north direction.\n    \"G\": move one step. Position: (0, 1). Direction: North.\n    \"G\": move one step. Position: (0, 2). Direction: North.\n    \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n    \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n    \"G\": move one step. Position: (0, 1). Direction: South.\n    \"G\": move one step. Position: (0, 0). Direction: South.\n    Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).\n    Based on that, we return true.\n\n    Example 2:\n\n    Input: instructions = \"GG\"\n    Output: false\n    Explanation: The robot is initially at (0, 0) facing the north direction.\n    \"G\": move one step. Position: (0, 1). Direction: North.\n    \"G\": move one step. Position: (0, 2). Direction: North.\n    Repeating the instructions, keeps advancing in the north direction and does not go into cycles.\n    Based on that, we return false.\n\n    Example 3:\n\n    Input: instructions = \"GL\"\n    Output: true\n    Explanation: The robot is initially at (0, 0) facing the north direction.\n    \"G\": move one step. Position: (0, 1). Direction: North.\n    \"L\": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n    \"G\": move one step. Position: (-1, 1). Direction: West.\n    \"L\": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n    \"G\": move one step. Position: (-1, 0). Direction: South.\n    \"L\": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n    \"G\": move one step. Position: (0, 0). Direction: East.\n    \"L\": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\n    Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).\n    Based on that, we return true.\n\n\u00a0\n    Constraints:\n\n    1 <= instructions.length <= 100\n    instructions[i] is 'G', 'L' or, 'R'.\n\n    \"\"\"\n", "canonical_solution": "    x, y, dir = 0, 0, 0\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for c in instructions:\n        if c == 'G':\n            x += moves[dir][0]\n            y += moves[dir][1]\n        elif c == 'L':\n            dir = (dir + 3) % 4\n        else:\n            dir = (dir + 1) % 4\n\n    return (x == 0 and y == 0) or dir != 0\n\n"}
{"prompt": "from typing import List\n\n\ndef gardenNoAdj(n: int, paths: List[List[int]]) -> List[int]:\n    \"\"\"\n    You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\n    All gardens have at most 3 paths coming into or leaving it.\n    Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.\n    Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.\n\u00a0\n    Example 1:\n\n    Input: n = 3, paths = [[1,2],[2,3],[3,1]]\n    Output: [1,2,3]\n    Explanation:\n    Gardens 1 and 2 have different types.\n    Gardens 2 and 3 have different types.\n    Gardens 3 and 1 have different types.\n    Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].\n\n    Example 2:\n\n    Input: n = 4, paths = [[1,2],[3,4]]\n    Output: [1,2,1,2]\n\n    Example 3:\n\n    Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\n    Output: [1,2,3,4]\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 104\n    0 <= paths.length <= 2 * 104\n    paths[i].length == 2\n    1 <= xi, yi <= n\n    xi != yi\n    Every garden has at most 3 paths coming into or leaving it.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    graph = defaultdict(set)\n    for x, y in paths:\n        graph[x - 1].add(y - 1)\n        graph[y - 1].add(x - 1)\n\n    result = [0] * n\n    for i in range(n):\n        used_flowers = {result[neighbor] for neighbor in graph[i]}\n        for flower in range(1, 5):\n            if flower not in used_flowers:\n                result[i] = flower\n                break\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSumAfterPartitioning(arr: list, k: int) -> int:\n    \"\"\"\n    Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n    Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,15,7,9,2,5,10], k = 3\n    Output: 84\n    Explanation: arr becomes [15,15,15,9,10,10,10]\n\n    Example 2:\n\n    Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\n    Output: 83\n\n    Example 3:\n\n    Input: arr = [1], k = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 500\n    0 <= arr[i] <= 109\n    1 <= k <= arr.length\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_max = 0\n        for j in range(1, k + 1):\n            if i - j < 0:\n                break\n            current_max = max(current_max, arr[i - j])\n            dp[i] = max(dp[i], dp[i - j] + current_max * j)\n    return dp[n]\n\n"}
{"prompt": "from typing import List\n\n\ndef longestStrChain(words: List[str]) -> int:\n    \"\"\"\n    You are given an array of words where each word consists of lowercase English letters.\n    wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n\n    For example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\n\n    A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\n    Return the length of the longest possible word chain with words chosen from the given list of words.\n\u00a0\n    Example 1:\n\n    Input: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\n    Output: 4\n    Explanation: One of the longest word chains is [\"a\",\"ba\",\"bda\",\"bdca\"].\n\n    Example 2:\n\n    Input: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\n    Output: 5\n    Explanation: All the words can be put in a word chain [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\n\n    Example 3:\n\n    Input: words = [\"abcd\",\"dbqca\"]\n    Output: 1\n    Explanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n    [\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed.\n\n\u00a0\n    Constraints:\n\n    1 <= words.length <= 1000\n    1 <= words[i].length <= 16\n    words[i] only consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len\n\n"}
{"prompt": "from typing import List\n\n\ndef maxAbsValExpr(arr1: List[int], arr2: List[int]) -> int:\n    \"\"\"\n    Given two arrays of integers with equal lengths, return the maximum value of:\n    |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\n    where the maximum is taken over all 0 <= i, j < arr1.length.\n\u00a0\n    Example 1:\n\n    Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\n    Output: 13\n\n    Example 2:\n\n    Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\n    Output: 20\n\n\u00a0\n    Constraints:\n\n    2 <= arr1.length == arr2.length <= 40000\n    -10^6 <= arr1[i], arr2[i] <= 10^6\n\n    \"\"\"\n", "canonical_solution": "    result = 0\n    max_sum = [float('-inf')] * 4\n\n    for i in range(len(arr1)):\n        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)\n        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)\n        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)\n        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)\n\n    for i in range(len(arr1)):\n        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)\n        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)\n\n    return result\n\n"}
{"prompt": "def numTrees(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\u00a0\n    Example 1:\n\n\n    Input: n = 3\n    Output: 5\n\n    Example 2:\n\n    Input: n = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 19\n\n    \"\"\"\n", "canonical_solution": "    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n\n"}
{"prompt": "from typing import List\n\n\ndef maxSatisfied(customers: List[int], grumpy: List[int], minutes: int) -> int:\n    \"\"\"\n    There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\n    On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\n    When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n    The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\n    Return the maximum number of customers that can be satisfied throughout the day.\n\u00a0\n    Example 1:\n\n    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n    Output: 16\n    Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \n    The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n    Example 2:\n\n    Input: customers = [1], grumpy = [0], minutes = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    n == customers.length == grumpy.length\n    1 <= minutes <= n <= 2 * 104\n    0 <= customers[i] <= 1000\n    grumpy[i] is either 0 or 1.\n\n    \"\"\"\n", "canonical_solution": "    total, max_increase, window_increase = 0, 0, 0\n    i, j = 0, 0\n    while i < len(customers):\n        if i - j == minutes:\n            window_increase -= customers[j] * grumpy[j]\n            j += 1\n        window_increase += customers[i] * grumpy[i]\n        total += customers[i] * (1 - grumpy[i])\n        max_increase = max(max_increase, window_increase)\n        i += 1\n    return total + max_increase\n\n"}
{"prompt": "from typing import List\n\n\ndef prev_perm_opt1(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array.\n    Note that a swap exchanges the positions of two numbers arr[i] and arr[j]\n\u00a0\n    Example 1:\n\n    Input: arr = [3,2,1]\n    Output: [3,1,2]\n    Explanation: Swapping 2 and 1.\n\n    Example 2:\n\n    Input: arr = [1,1,5]\n    Output: [1,1,5]\n    Explanation: This is already the smallest permutation.\n\n    Example 3:\n\n    Input: arr = [1,9,4,6,7]\n    Output: [1,7,4,6,9]\n    Explanation: Swapping 9 and 7.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 104\n    1 <= arr[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            return arr\n    return arr\n\n"}
{"prompt": "from typing import List\n\n\ndef rearrange_barcodes(barcodes: List[int]) -> List[int]:\n    \"\"\"\n    In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].\n    Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n\u00a0\n    Example 1:\n    Input: barcodes = [1,1,1,2,2,2]\n    Output: [2,1,2,1,2,1]\n    Example 2:\n    Input: barcodes = [1,1,1,1,2,2,3,3]\n    Output: [1,3,1,3,1,2,1,2]\n\n\u00a0\n    Constraints:\n\n    1 <= barcodes.length <= 10000\n    1 <= barcodes[i] <= 10000\n\n    \"\"\"\n", "canonical_solution": "    from heapq import heappush, heappop\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes\n\n"}
{"prompt": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n    A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n    For example, \"ace\" is a subsequence of \"abcde\".\n\n    A common subsequence of two strings is a subsequence that is common to both strings.\n\u00a0\n    Example 1:\n\n    Input: text1 = \"abcde\", text2 = \"ace\" \n    Output: 3  \n    Explanation: The longest common subsequence is \"ace\" and its length is 3.\n\n    Example 2:\n\n    Input: text1 = \"abc\", text2 = \"abc\"\n    Output: 3\n    Explanation: The longest common subsequence is \"abc\" and its length is 3.\n\n    Example 3:\n\n    Input: text1 = \"abc\", text2 = \"def\"\n    Output: 0\n    Explanation: There is no such common subsequence, so the result is 0.\n\n\u00a0\n    Constraints:\n\n    1 <= text1.length, text2.length <= 1000\n    text1 and text2 consist of only lowercase English characters.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n"}
{"prompt": "from typing import List\n\n\ndef movesToMakeZigzag(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of integers, a move\u00a0consists of choosing any element and decreasing it by 1.\n    An array A is a\u00a0zigzag array\u00a0if either:\n\n    Every even-indexed element is greater than adjacent elements, ie.\u00a0A[0] > A[1] < A[2] > A[3] < A[4] > ...\n    OR, every odd-indexed element is greater than adjacent elements, ie.\u00a0A[0] < A[1] > A[2] < A[3] > A[4] < ...\n\n    Return the minimum number of moves to transform the given array nums into a zigzag array.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3]\n    Output: 2\n    Explanation: We can decrease 2 to 0 or 3 to 1.\n\n    Example 2:\n\n    Input: nums = [9,6,1,6,2]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    1 <= nums[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    even_moves, odd_moves = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else 1001\n        right = nums[i + 1] if i < len(nums) - 1 else 1001\n        min_value = min(left, right)\n        if nums[i] >= min_value:\n            if i % 2 == 0:\n                even_moves += nums[i] - min_value + 1\n            else:\n                odd_moves += nums[i] - min_value + 1\n    return min(even_moves, odd_moves)\n\n"}
{"prompt": "from typing import List\n\n\ndef maxEqualRowsAfterFlips(matrix: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n binary matrix matrix.\n    You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).\n    Return the maximum number of rows that have all values equal after some number of flips.\n\u00a0\n    Example 1:\n\n    Input: matrix = [[0,1],[1,1]]\n    Output: 1\n    Explanation: After flipping no values, 1 row has all values equal.\n\n    Example 2:\n\n    Input: matrix = [[0,1],[1,0]]\n    Output: 2\n    Explanation: After flipping values in the first column, both rows have equal values.\n\n    Example 3:\n\n    Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]\n    Output: 2\n    Explanation: After flipping values in the first two columns, the last two rows have equal values.\n\n\u00a0\n    Constraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 300\n    matrix[i][j] is either\u00a00 or 1.\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())\n\n"}
{"prompt": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    \"\"\"\n    Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\n    An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\n    s = s1 + s2 + ... + sn\n    t = t1 + t2 + ... + tm\n    |n - m| <= 1\n    The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\n    Note: a + b is the concatenation of strings a and b.\n\u00a0\n    Example 1:\n\n\n    Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n    Output: true\n    Explanation: One way to obtain s3 is:\n    Split s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\n    Interleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\n    Since s3 can be obtained by interleaving s1 and s2, we return true.\n\n    Example 2:\n\n    Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n    Output: false\n    Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n    Example 3:\n\n    Input: s1 = \"\", s2 = \"\", s3 = \"\"\n    Output: true\n\n\u00a0\n    Constraints:\n\n    0 <= s1.length, s2.length <= 100\n    0 <= s3.length <= 200\n    s1, s2, and s3 consist of lowercase English letters.\n\n\u00a0\n    Follow up: Could you solve it using only O(s2.length) additional memory space?\n    \"\"\"\n", "canonical_solution": "    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n\n"}
{"prompt": "def numRollsToTarget(n: int, k: int, target: int) -> int:\n    \"\"\"\n    You have n dice, and each die has k faces numbered from 1 to k.\n    Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: n = 1, k = 6, target = 3\n    Output: 1\n    Explanation: You throw one die with 6 faces.\n    There is only one way to get a sum of 3.\n\n    Example 2:\n\n    Input: n = 2, k = 6, target = 7\n    Output: 6\n    Explanation: You throw two dice, each with 6 faces.\n    There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n\n    Example 3:\n\n    Input: n = 30, k = 30, target = 500\n    Output: 222616187\n    Explanation: The answer must be returned modulo 109 + 7.\n\n\u00a0\n    Constraints:\n\n    1 <= n, k <= 30\n    1 <= target <= 1000\n\n    \"\"\"\n", "canonical_solution": "    MOD = 1000000007\n    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, target + 1):\n            for d in range(1, k + 1):\n                if j - d >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD\n    return dp[n][target]\n\n"}
{"prompt": "from typing import List\n\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\n    A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n\n    All the visited cells of the path are 0.\n    All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n\n    The length of a clear path is the number of visited cells of this path.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,1],[1,0]]\n    Output: 2\n\n    Example 2:\n\n\n    Input: grid = [[0,0,0],[1,1,0],[1,1,0]]\n    Output: 4\n\n    Example 3:\n\n    Input: grid = [[1,0,0],[1,1,0],[1,1,0]]\n    Output: -1\n\n\u00a0\n    Constraints:\n\n    n == grid.length\n    n == grid[i].length\n    1 <= n <= 100\n    grid[i][j] is 0 or 1\n\n    \"\"\"\n", "canonical_solution": "    from collections import deque\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    q = deque([(0, 0)])\n    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    grid[0][0] = 1\n    steps = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1:\n                return steps\n\n            for dx, dy in dirs:\n                newX, newY = x + dx, y + dy\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n\n        steps += 1\n\n    return -1\n\n"}
{"prompt": "from typing import List\n\n\ndef canMakePaliQueries(s: str, queries: List[List[int]]) -> List[bool]:\n    \"\"\"\n    You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.\n    If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.\n    Return a boolean array answer where answer[i] is the result of the ith query queries[i].\n    Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.\n\u00a0\n    Example :\n\n    Input: s = \"abcda\", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n    Output: [true,false,false,true,true]\n    Explanation:\n    queries[0]: substring = \"d\", is palidrome.\n    queries[1]: substring = \"bc\", is not palidrome.\n    queries[2]: substring = \"abcd\", is not palidrome after replacing only 1 character.\n    queries[3]: substring = \"abcd\", could be changed to \"abba\" which is palidrome. Also this can be changed to \"baab\" first rearrange it \"bacd\" then replace \"cd\" with \"ab\".\n    queries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palidrome.\n\n    Example 2:\n\n    Input: s = \"lyb\", queries = [[0,1,0],[2,2,1]]\n    Output: [false,true]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length, queries.length <= 105\n    0 <= lefti <= righti < s.length\n    0 <= ki <= s.length\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    answer = []\n    prefixSum = [0] * (len(s) + 1)\n\n    for i in range(len(s)):\n        prefixSum[i + 1] = prefixSum[i] ^ (1 << (ord(s[i]) - ord('a')))\n\n    for query in queries:\n        left, right, k = query\n        diffCount = bin(prefixSum[right + 1] ^ prefixSum[left]).count('1')\n        answer.append((diffCount // 2) <= k)\n\n    return answer\n\n"}
{"prompt": "from typing import List\n\n\ndef carPooling(trips: List[List[int]], capacity: int) -> bool:\n    \"\"\"\n    There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\n    You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.\n    Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: trips = [[2,1,5],[3,3,7]], capacity = 4\n    Output: false\n\n    Example 2:\n\n    Input: trips = [[2,1,5],[3,3,7]], capacity = 5\n    Output: true\n\n\u00a0\n    Constraints:\n\n    1 <= trips.length <= 1000\n    trips[i].length == 3\n    1 <= numPassengersi <= 100\n    0 <= fromi < toi <= 1000\n    1 <= capacity <= 105\n\n    \"\"\"\n", "canonical_solution": "    stops = [0] * 1001\n    for num, start, end in trips:\n        stops[start] += num\n        stops[end] -= num\n    for i in stops:\n        capacity -= i\n        if capacity < 0:\n            return False\n    return True\n\n"}
{"prompt": "def reverseParentheses(s: str) -> str:\n    \"\"\"\n    You are given a string s that consists of lower case English letters and brackets.\n    Reverse the strings in each pair of matching parentheses, starting from the innermost one.\n    Your result should not contain any brackets.\n\u00a0\n    Example 1:\n\n    Input: s = \"(abcd)\"\n    Output: \"dcba\"\n\n    Example 2:\n\n    Input: s = \"(u(love)i)\"\n    Output: \"iloveu\"\n    Explanation: The substring \"love\" is reversed first, then the whole string is reversed.\n\n    Example 3:\n\n    Input: s = \"(ed(et(oc))el)\"\n    Output: \"leetcode\"\n    Explanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 2000\n    s only contains lower case English characters and parentheses.\n    It is guaranteed that all parentheses are balanced.\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            start, end = stack.pop(), i\n            # reversal of the substring\n            s = s[:start] + s[start+1:end][::-1] + s[end+1:]\n    return ''.join(c for c in s if c.isalpha())\n\n"}
{"prompt": "from typing import List\n\n\ndef kConcatenationMaxSum(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an integer array arr and an integer k, modify the array by repeating it k times.\n    For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\n    Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.\n    As the answer can be very large, return the answer modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2], k = 3\n    Output: 9\n\n    Example 2:\n\n    Input: arr = [1,-2,1], k = 5\n    Output: 2\n\n    Example 3:\n\n    Input: arr = [-1,-2], k = 7\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    1 <= k <= 105\n    -104 <= arr[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    mod = 10**9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = 0, 0, 0\n    total_sum = sum(arr)\n    temp_sum = 0\n\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod\n\n"}
{"prompt": "from typing import List\n\n\ndef minHeightShelves(books: List[List[int]], shelfWidth: int) -> int:\n    \"\"\"\n    You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.\n    We want to place these books in order onto bookcase shelves that have a total width shelfWidth.\n    We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n    Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n    For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\n    Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n\u00a0\n    Example 1:\n\n\n    Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\n    Output: 6\n    Explanation:\n    The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\n    Notice that book number 2 does not have to be on the first shelf.\n\n    Example 2:\n\n    Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= books.length <= 1000\n    1 <= thicknessi <= shelfWidth <= 1000\n    1 <= heighti <= 1000\n\n    \"\"\"\n", "canonical_solution": "    n = len(books)\n    dp = [1000000] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        j = i\n        while j >= 1:\n            width += books[j - 1][0]\n            height = max(height, books[j - 1][1])\n\n            if width <= shelfWidth:\n                dp[i] = min(dp[i], dp[j - 1] + height)\n            j -= 1\n\n    return dp[n]\n\n"}
{"prompt": "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    \"\"\"\n    An ugly number is a positive integer that is divisible by a, b, or c.\n    Given four integers n, a, b, and c, return the nth ugly number.\n\u00a0\n    Example 1:\n\n    Input: n = 3, a = 2, b = 3, c = 5\n    Output: 4\n    Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\n\n    Example 2:\n\n    Input: n = 4, a = 2, b = 3, c = 4\n    Output: 6\n    Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\n\n    Example 3:\n\n    Input: n = 5, a = 2, b = 11, c = 13\n    Output: 10\n    Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.\n\n\u00a0\n    Constraints:\n\n    1 <= n, a, b, c <= 109\n    1 <= a * b * c <= 1018\n    It is guaranteed that the result will be in range [1, 2 * 109].\n\n    \"\"\"\n", "canonical_solution": "    import math\n    left, right = 1, int(2e9)\n    lcm_ab, lcm_ac, lcm_bc = a * b // math.gcd(a, b), a * c // math.gcd(a, c), b * c // math.gcd(b, c)\n    lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\n\n    while left < right:\n        mid = left + (right - left) // 2\n        count = mid // a + mid // b + mid // c - mid // lcm_ab - mid // lcm_ac - mid // lcm_bc + mid // lcm_abc\n        if count < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n"}
{"prompt": "from typing import List\n\n\ndef corp_flight_bookings(bookings: List[List[int]], n: int) -> List[int]:\n    \"\"\"\n    There are n flights that are labeled from 1 to n.\n    You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\n    Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\n\u00a0\n    Example 1:\n\n    Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n    Output: [10,55,45,25,25]\n    Explanation:\n    Flight labels:        1   2   3   4   5\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      20  20\n    Booking 3 reserved:      25  25  25  25\n    Total seats:         10  55  45  25  25\n    Hence, answer = [10,55,45,25,25]\n\n    Example 2:\n\n    Input: bookings = [[1,2,10],[2,2,15]], n = 2\n    Output: [10,25]\n    Explanation:\n    Flight labels:        1   2\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      15\n    Total seats:         10  25\n    Hence, answer = [10,25]\n\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 2 * 104\n    1 <= bookings.length <= 2 * 104\n    bookings[i].length == 3\n    1 <= firsti <= lasti <= n\n    1 <= seatsi <= 104\n\n    \"\"\"\n", "canonical_solution": "    answer = [0] * n\n    for start, end, seats in bookings:\n        answer[start - 1] += seats\n        if end < n:\n            answer[end] -= seats\n    for i in range(1, n):\n        answer[i] += answer[i - 1]\n    return answer\n\n"}
{"prompt": "def removeDuplicates(s: str, k: int) -> str:\n    \"\"\"\n    You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\n    We repeatedly make k duplicate removals on s until we no longer can.\n    Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcd\", k = 2\n    Output: \"abcd\"\n    Explanation: There's nothing to delete.\n    Example 2:\n\n    Input: s = \"deeedbbcccbdaa\", k = 3\n    Output: \"aa\"\n    Explanation: \n    First delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\n    Then delete \"bbb\", get \"dddaa\"\n    Finally delete \"ddd\", get \"aa\"\n    Example 3:\n\n    Input: s = \"pbbcggttciiippooaais\", k = 2\n    Output: \"ps\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    2 <= k <= 104\n    s only contains lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    for c in s:\n        if not stack or stack[-1][0] != c:\n            stack.append((c, 1))\n        elif stack[-1][1] + 1 != k:\n            stack[-1] = (c, stack[-1][1] + 1)\n        else:\n            stack.pop()\n    return ''.join(c * count for c, count in stack)\n\n"}
{"prompt": "from typing import List\n\n\ndef remove_covered_intervals(intervals: List[List[int]]) -> int:\n    \"\"\"\n    Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.\n    The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\n    Return the number of remaining intervals.\n\u00a0\n    Example 1:\n\n    Input: intervals = [[1,4],[3,6],[2,8]]\n    Output: 2\n    Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n\n    Example 2:\n\n    Input: intervals = [[1,4],[2,3]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= intervals.length <= 1000\n    intervals[i].length == 2\n    0 <= li < ri <= 105\n    All the given intervals are unique.\n\n    \"\"\"\n", "canonical_solution": "    intervals.sort(key=lambda x: (x[0], -x[1]))\n\n    count = 0\n    end = 0\n    for i in intervals:\n        if i[1] > end:\n            count += 1\n            end = i[1]\n    return count\n\n"}
{"prompt": "from typing import List\n\n\ndef shortestAlternatingPaths(n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n    You are given two arrays redEdges and blueEdges where:\n\n    redEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\n    blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\n    Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\u00a0\n    Example 1:\n\n    Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\n    Output: [0,1,-1]\n\n    Example 2:\n\n    Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\n    Output: [0,1,-1]\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 100\n    0 <= redEdges.length,\u00a0blueEdges.length <= 400\n    redEdges[i].length == blueEdges[j].length == 2\n    0 <= ai, bi, uj, vj < n\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict, deque\n    adj_list = defaultdict(lambda: defaultdict(set))\n\n    for u, v in redEdges:\n        adj_list[u][0].add(v)\n\n    for u, v in blueEdges:\n        adj_list[u][1].add(v)\n\n    dist = [[-1] * 2 for _ in range(n)]\n    dist[0] = [0, 0]\n\n    q = deque([(0, 0), (0, 1)])\n\n    while q:\n        node, color = q.popleft()\n        next_color = color ^ 1\n\n        for neighbor in adj_list[node][next_color]:\n            if dist[neighbor][next_color] == -1:\n                dist[neighbor][next_color] = dist[node][color] + 1\n                q.append((neighbor, next_color))\n\n    result = []\n    for a, b in dist:\n        result.append(min(a, b) if a != -1 and b != -1 else max(a, b))\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef findBestValue(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\n    In case of a tie, return the minimum such integer.\n    Notice that the answer is not neccesarilly a number from arr.\n\u00a0\n    Example 1:\n\n    Input: arr = [4,9,3], target = 10\n    Output: 3\n    Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.\n\n    Example 2:\n\n    Input: arr = [2,3,5], target = 10\n    Output: 5\n\n    Example 3:\n\n    Input: arr = [60864,25176,27249,21296,20204], target = 56803\n    Output: 11361\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 104\n    1 <= arr[i], target <= 105\n\n    \"\"\"\n", "canonical_solution": "    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef largest1BorderedSquare(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.\n\u00a0\n    Example 1:\n\n    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\n    Output: 9\n\n    Example 2:\n\n    Input: grid = [[1,1,0,0]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= grid.length <= 100\n    1 <= grid[0].length <= 100\n    grid[i][j] is 0 or 1\n    \"\"\"\n", "canonical_solution": "    m, n = len(grid), len(grid[0])\n    horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\n\n    max_square_size = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1\n                vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1\n\n                min_size = min(horizontal[i][j], vertical[i][j])\n                while min_size > max_square_size:\n                    if (horizontal[i - min_size + 1][j] >= min_size and\n                            vertical[i][j - min_size + 1] >= min_size):\n                        max_square_size = min_size\n                    min_size -= 1\n\n    return max_square_size * max_square_size\n\n"}
{"prompt": "from typing import List\n\n\ndef moves_to_make_zigzag(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of integers, a move\u00a0consists of choosing any element and decreasing it by 1.\n    An array A is a\u00a0zigzag array\u00a0if either:\n\n    Every even-indexed element is greater than adjacent elements, ie.\u00a0A[0] > A[1] < A[2] > A[3] < A[4] > ...\n    OR, every odd-indexed element is greater than adjacent elements, ie.\u00a0A[0] < A[1] > A[2] < A[3] > A[4] < ...\n\n    Return the minimum number of moves to transform the given array nums into a zigzag array.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,3]\n    Output: 2\n    Explanation: We can decrease 2 to 0 or 3 to 1.\n\n    Example 2:\n\n    Input: nums = [9,6,1,6,2]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    1 <= nums[i] <= 1000\n\n    \"\"\"\n", "canonical_solution": "    moves1, moves2 = 0, 0\n    for i in range(len(nums)):\n        left = nums[i - 1] if i > 0 else float('inf')\n        right = nums[i + 1] if i + 1 < len(nums) else float('inf')\n        diff1 = nums[i] - min(left, right) + 1\n        diff2 = nums[i] - min(left, right) + 1\n        if i % 2 == 0:\n            moves1 += max(0, diff1)\n        else:\n            moves2 += max(0, diff2)\n    return min(moves1, moves2)\n\n"}
{"prompt": "def break_palindrome(palindrome: str) -> str:\n    \"\"\"\n    Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\n    Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.\n    A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, \"abcc\" is lexicographically smaller than \"abcd\" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.\n\u00a0\n    Example 1:\n\n    Input: palindrome = \"abccba\"\n    Output: \"aaccba\"\n    Explanation: There are many ways to make \"abccba\" not a palindrome, such as \"zbccba\", \"aaccba\", and \"abacba\".\n    Of all the ways, \"aaccba\" is the lexicographically smallest.\n\n    Example 2:\n\n    Input: palindrome = \"a\"\n    Output: \"\"\n    Explanation: There is no way to replace a single character to make \"a\" not a palindrome, so return an empty string.\n\n\u00a0\n    Constraints:\n\n    1 <= palindrome.length <= 1000\n    palindrome consists of only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    n = len(palindrome)\n    if n < 2:\n        return \"\"\n\n    palindrome = list(palindrome)\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            palindrome[i] = 'a'\n            return \"\".join(palindrome)\n\n    palindrome[-1] = 'b'\n    return \"\".join(palindrome)\n\n"}
{"prompt": "from typing import List\n\n\ndef diagonalSort(mat: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].\n    Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.\n\u00a0\n    Example 1:\n\n\n    Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n    Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n\n    Example 2:\n\n    Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n    Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n\n\u00a0\n    Constraints:\n\n    m == mat.length\n    n == mat[i].length\n    1 <= m, n <= 100\n    1 <= mat[i][j] <= 100\n\n    \"\"\"\n", "canonical_solution": "    from heapq import heappush, heappop\n    m, n = len(mat), len(mat[0])\n    for i in range(m):\n        pq = []\n        row, col = i, 0\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = i, 0\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n\n    for i in range(1, n):\n        pq = []\n        row, col = 0, i\n        while row < m and col < n:\n            heappush(pq, mat[row][col])\n            row += 1\n            col += 1\n        row, col = 0, i\n        while row < m and col < n:\n            mat[row][col] = heappop(pq)\n            row += 1\n            col += 1\n    return mat\n\n"}
{"prompt": "from typing import List\n\n\ndef closedIsland(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D\u00a0grid consists of 0s (land)\u00a0and 1s (water).\u00a0 An island is a maximal 4-directionally connected group of 0s and a closed island\u00a0is an island totally\u00a0(all left, top, right, bottom) surrounded by 1s.\n    Return the number of closed islands.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n    Output: 2\n    Explanation: \n    Islands in gray are closed because they are completely surrounded by water (group of 1s).\n    Example 2:\n\n\n    Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\n    Output: 1\n\n    Example 3:\n\n    Input: grid = [[1,1,1,1,1,1,1],\n    \u00a0              \u00a0              [1,0,0,0,0,0,1],\n    \u00a0              \u00a0              [1,0,1,1,1,0,1],\n    \u00a0              \u00a0              [1,0,1,0,1,0,1],\n    \u00a0              \u00a0              [1,0,1,1,1,0,1],\n    \u00a0              \u00a0              [1,0,0,0,0,0,1],\n                   [1,1,1,1,1,1,1]]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= grid.length, grid[0].length <= 100\n    0 <= grid[i][j] <=1\n\n    \"\"\"\n", "canonical_solution": "    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return False\n\n        if grid[i][j] == 1:\n            return True\n\n        grid[i][j] = 1\n\n        up = dfs(grid, i - 1, j)\n        down = dfs(grid, i + 1, j)\n        left = dfs(grid, i, j - 1)\n        right = dfs(grid, i, j + 1)\n\n        return up and down and left and right\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0 and dfs(grid, i, j):\n                count += 1\n\n    return count\n\n"}
{"prompt": "def numRollsToTarget(n: int, k: int, target: int) -> int:\n    \"\"\"\n    You have n dice, and each die has k faces numbered from 1 to k.\n    Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: n = 1, k = 6, target = 3\n    Output: 1\n    Explanation: You throw one die with 6 faces.\n    There is only one way to get a sum of 3.\n\n    Example 2:\n\n    Input: n = 2, k = 6, target = 7\n    Output: 6\n    Explanation: You throw two dice, each with 6 faces.\n    There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n\n    Example 3:\n\n    Input: n = 30, k = 30, target = 500\n    Output: 222616187\n    Explanation: The answer must be returned modulo 109 + 7.\n\n\u00a0\n    Constraints:\n\n    1 <= n, k <= 30\n    1 <= target <= 1000\n\n    \"\"\"\n", "canonical_solution": "    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            for l in range(1, k + 1):\n                if j >= l:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n    return dp[n][target]\n\n"}
{"prompt": "from typing import List\n\n\ndef suggestedProducts(products: List[str], searchWord: str) -> List[List[str]]:\n    \"\"\"\n    You are given an array of strings products and a string searchWord.\n    Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n    Return a list of lists of the suggested products after each character of searchWord is typed.\n\u00a0\n    Example 1:\n\n    Input: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n    Output: [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n    Explanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\n    After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\n    After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n\n    Example 2:\n\n    Input: products = [\"havana\"], searchWord = \"havana\"\n    Output: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n    Explanation: The only word \"havana\" will be always suggested while typing the search word.\n\n\u00a0\n    Constraints:\n\n    1 <= products.length <= 1000\n    1 <= products[i].length <= 3000\n    1 <= sum(products[i].length) <= 2 * 104\n    All the strings of products are unique.\n    products[i] consists of lowercase English letters.\n    1 <= searchWord.length <= 1000\n    searchWord consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    products.sort()\n\n    for i in range(len(searchWord)):\n        suggestions = []\n        for product in products:\n            if len(product) > i and product[i] == searchWord[i]:\n                suggestions.append(product)\n                if len(suggestions) == 3:\n                    break\n        result.append(suggestions)\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef validateBinaryTreeNodes(n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n    \"\"\"\n    You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\n    If node i has no left child then leftChild[i] will equal -1, similarly for the right child.\n    Note that the nodes have no values and that we only use the node numbers in this problem.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n    Output: true\n\n    Example 2:\n\n\n    Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n    Output: false\n\n    Example 3:\n\n\n    Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]\n    Output: false\n\n\u00a0\n    Constraints:\n\n    n == leftChild.length == rightChild.length\n    1 <= n <= 104\n    -1 <= leftChild[i], rightChild[i] <= n - 1\n\n    \"\"\"\n", "canonical_solution": "    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n\n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1\n\n"}
{"prompt": "from typing import List\n\n\ndef can_make_pali_queries(s: str, queries: List[List[int]]) -> List[bool]:\n    \"\"\"\n    You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.\n    If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.\n    Return a boolean array answer where answer[i] is the result of the ith query queries[i].\n    Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.\n\u00a0\n    Example :\n\n    Input: s = \"abcda\", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n    Output: [true,false,false,true,true]\n    Explanation:\n    queries[0]: substring = \"d\", is palidrome.\n    queries[1]: substring = \"bc\", is not palidrome.\n    queries[2]: substring = \"abcd\", is not palidrome after replacing only 1 character.\n    queries[3]: substring = \"abcd\", could be changed to \"abba\" which is palidrome. Also this can be changed to \"baab\" first rearrange it \"bacd\" then replace \"cd\" with \"ab\".\n    queries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palidrome.\n\n    Example 2:\n\n    Input: s = \"lyb\", queries = [[0,1,0],[2,2,1]]\n    Output: [false,true]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length, queries.length <= 105\n    0 <= lefti <= righti < s.length\n    0 <= ki <= s.length\n    s consists of lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    for left, right, k in queries:\n        count = [0] * 26\n        for i in range(left, right + 1):\n            count[ord(s[i]) - ord('a')] += 1\n        odd_count = sum(c % 2 for c in count)\n        result.append(odd_count // 2 <= k)\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef groupThePeople(groupSizes: List[int]) -> List[List[int]]:\n    \"\"\"\n    There are n people\u00a0that are split into some unknown number of groups. Each person is labeled with a\u00a0unique ID\u00a0from\u00a00\u00a0to\u00a0n - 1.\n    You are given an integer array\u00a0groupSizes, where groupSizes[i]\u00a0is the size of the group that person\u00a0i\u00a0is in. For example, if\u00a0groupSizes[1] = 3, then\u00a0person\u00a01\u00a0must be in a\u00a0group of size\u00a03.\n    Return\u00a0a list of groups\u00a0such that\u00a0each person\u00a0i\u00a0is in a group of size\u00a0groupSizes[i].\n    Each person should\u00a0appear in\u00a0exactly one group,\u00a0and every person must be in a group. If there are\u00a0multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.\n\u00a0\n    Example 1:\n\n    Input: groupSizes = [3,3,3,3,3,1,3]\n    Output: [[5],[0,1,2],[3,4,6]]\n    Explanation: \n    The first group is [5]. The size is 1, and groupSizes[5] = 1.\n    The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\n    The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\n    Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].\n\n    Example 2:\n\n    Input: groupSizes = [2,1,3,3,3,2]\n    Output: [[1],[0,5],[2,3,4]]\n\n\u00a0\n    Constraints:\n\n    groupSizes.length == n\n    1 <= n\u00a0<= 500\n    1 <=\u00a0groupSizes[i] <= n\n\n    \"\"\"\n", "canonical_solution": "    from collections import defaultdict\n    groups = defaultdict(list)\n    result = []\n\n    for i, size in enumerate(groupSizes):\n        groups[size].append(i)\n        if len(groups[size]) == size:\n            result.append(groups[size])\n            groups[size] = []\n\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef maximum_sum(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, return the maximum sum for a non-empty\u00a0subarray (contiguous elements) with at most one element deletion.\u00a0In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the\u00a0sum of the remaining elements is maximum possible.\n    Note that the subarray needs to be non-empty after deleting one element.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,-2,0,3]\n    Output: 4\n    Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.\n    Example 2:\n\n    Input: arr = [1,-2,-2,3]\n    Output: 3\n    Explanation: We just choose [3] and it's the maximum sum.\n\n    Example 3:\n\n    Input: arr = [-1,-1,-1,-1]\n    Output: -1\n    Explanation:\u00a0The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    -104 <= arr[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    n = len(arr)\n    sum_without_deletion = [0] * n\n    sum_with_deletion = [0] * n\n    sum_without_deletion[0] = arr[0]\n    sum_with_deletion[0] = 0\n    max_sum = arr[0]\n\n    for i in range(1, n):\n        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i])\n        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1])\n        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]))\n    return max_sum\n\n"}
{"prompt": "from typing import List\n\n\ndef sequential_digits(low: int, high: int) -> List[int]:\n    \"\"\"\n    An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\n    Return a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.\n\u00a0\n    Example 1:\n    Input: low = 100, high = 300\n    Output: [123,234]\n    Example 2:\n    Input: low = 1000, high = 13000\n    Output: [1234,2345,3456,4567,5678,6789,12345]\n\n\u00a0\n    Constraints:\n\n    10 <= low <= high <= 10^9\n\n    \"\"\"\n", "canonical_solution": "    result = []\n    for i in range(1, 10):\n        number = i\n        for j in range(i + 1, 10):\n            number = number * 10 + j\n            if low <= number <= high:\n                result.append(number)\n    return sorted(result)\n\n"}
{"prompt": "from typing import List\n\n\ndef minimumTotal(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Given a triangle array, return the minimum path sum from top to bottom.\n    For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\u00a0\n    Example 1:\n\n    Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n    Output: 11\n    Explanation: The triangle looks like:\n       2\n      3 4\n     6 5 7\n    4 1 8 3\n    The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n    Example 2:\n\n    Input: triangle = [[-10]]\n    Output: -10\n\n\u00a0\n    Constraints:\n\n    1 <= triangle.length <= 200\n    triangle[0].length == 1\n    triangle[i].length == triangle[i - 1].length + 1\n    -104 <= triangle[i][j] <= 104\n\n\u00a0\n    Follow up: Could you\u00a0do this using only O(n) extra space, where n is the total number of rows in the triangle?\"\"\"\n", "canonical_solution": "    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n\n"}
{"prompt": "def reverseParentheses(s: str) -> str:\n    \"\"\"\n    You are given a string s that consists of lower case English letters and brackets.\n    Reverse the strings in each pair of matching parentheses, starting from the innermost one.\n    Your result should not contain any brackets.\n\u00a0\n    Example 1:\n\n    Input: s = \"(abcd)\"\n    Output: \"dcba\"\n\n    Example 2:\n\n    Input: s = \"(u(love)i)\"\n    Output: \"iloveu\"\n    Explanation: The substring \"love\" is reversed first, then the whole string is reversed.\n\n    Example 3:\n\n    Input: s = \"(ed(et(oc))el)\"\n    Output: \"leetcode\"\n    Explanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 2000\n    s only contains lower case English characters and parentheses.\n    It is guaranteed that all parentheses are balanced.\n\n    \"\"\"\n", "canonical_solution": "    st = []\n    result = []\n\n    for c in s:\n        if c != ')':\n            st.append(c)\n        else:\n            temp = []\n            while st and st[-1] != '(':\n                temp.append(st.pop())\n            if st:\n                st.pop()  # Remove '('\n            st.extend(temp)\n\n    result = \"\".join(st)\n    return result\n\n"}
{"prompt": "from typing import List\n\n\ndef kConcatenationMaxSum(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an integer array arr and an integer k, modify the array by repeating it k times.\n    For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\n    Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.\n    As the answer can be very large, return the answer modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2], k = 3\n    Output: 9\n\n    Example 2:\n\n    Input: arr = [1,-2,1], k = 5\n    Output: 2\n\n    Example 3:\n\n    Input: arr = [-1,-2], k = 7\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    1 <= k <= 105\n    -104 <= arr[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    M = 10**9 + 7\n    s = sum(arr)\n    max_sum = max_ending_here = 0\n    for i in range(len(arr) * min(2, k)):\n        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])\n        max_sum = max(max_sum, max_ending_here)\n    return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M\n\n"}
{"prompt": "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    \"\"\"\n    An ugly number is a positive integer that is divisible by a, b, or c.\n    Given four integers n, a, b, and c, return the nth ugly number.\n\u00a0\n    Example 1:\n\n    Input: n = 3, a = 2, b = 3, c = 5\n    Output: 4\n    Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\n\n    Example 2:\n\n    Input: n = 4, a = 2, b = 3, c = 4\n    Output: 6\n    Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\n\n    Example 3:\n\n    Input: n = 5, a = 2, b = 11, c = 13\n    Output: 10\n    Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.\n\n\u00a0\n    Constraints:\n\n    1 <= n, a, b, c <= 109\n    1 <= a * b * c <= 1018\n    It is guaranteed that the result will be in range [1, 2 * 109].\n\n    \"\"\"\n", "canonical_solution": "    from math import gcd\n\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * bc // gcd(a, bc)\n\n    left, right = 0, 2 * 10**9\n    while left < right:\n        mid = left + (right - left) // 2\n        cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc\n        if cnt < n:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\n"}
{"prompt": "from typing import List\n\n\ndef largestMagicSquare(grid: List[List[int]]) -> int:\n    \"\"\"\n    A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.\n    Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n    Output: 3\n    Explanation: The largest magic square has a size of 3.\n    Every row sum, column sum, and diagonal sum of this magic square is equal to 12.\n    - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n    - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n    - Diagonal sums: 5+4+3 = 6+4+2 = 12\n\n    Example 2:\n\n\n    Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 50\n    1 <= grid[i][j] <= 106\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(grid), len(grid[0])\n    row = [[0] * (n + 1) for _ in range(m)]\n    col = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            row[i][j + 1] = row[i][j] + grid[i][j]\n            col[i + 1][j] = col[i][j] + grid[i][j]\n\n    for k in reversed(range(2, min(m, n) + 1)):\n        for i in range(m - k + 1):\n            for j in range(n - k + 1):\n                _sum = row[i][j + k] - row[i][j]\n                ok = all(row[i + t][j + k] - row[i + t][j] == _sum for t in range(1, k)) and all(\n                    col[i + k][j + t] - col[i][j + t] == _sum for t in range(1, k))\n\n                if not ok:\n                    continue\n\n                diag1 = sum(grid[i + t][j + t] for t in range(k))\n                diag2 = sum(grid[i + t][j + k - 1 - t] for t in range(k))\n\n                if diag1 == _sum and diag2 == _sum:\n                    return k\n\n    return 1\n\n"}
{"prompt": "from typing import List\n\n\ndef matrix_block_sum(mat: List[List[int]], k: int) -> List[List[int]]:\n    \"\"\"\n    Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:\n\n    i - k <= r <= i + k,\n    j - k <= c <= j + k, and\n    (r, c) is a valid position in the matrix.\n\n\u00a0\n    Example 1:\n\n    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n    Output: [[12,21,16],[27,45,33],[24,39,28]]\n\n    Example 2:\n\n    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n    Output: [[45,45,45],[45,45,45],[45,45,45]]\n\n\u00a0\n    Constraints:\n\n    m ==\u00a0mat.length\n    n ==\u00a0mat[i].length\n    1 <= m, n, k <= 100\n    1 <= mat[i][j] <= 100\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(mat), len(mat[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for r in range(max(0, i - k), min(m, i + k + 1)):\n                for c in range(max(0, j - k), min(n, j + k + 1)):\n                    answer[i][j] += mat[r][c]\n\n    return answer\n\n"}
{"prompt": "def minFlips(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\n    Flip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.\n\u00a0\n    Example 1:\n\n\n    Input: a = 2, b = 6, c = 5\n    Output: 3\n    Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)\n    Example 2:\n\n    Input: a = 4, b = 2, c = 7\n    Output: 1\n\n    Example 3:\n\n    Input: a = 1, b = 2, c = 3\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= a <= 10^9\n    1 <= b\u00a0<= 10^9\n    1 <= c\u00a0<= 10^9\n    \"\"\"\n", "canonical_solution": "    count = 0\n    for i in range(32):\n        bitA = (a >> i) & 1\n        bitB = (b >> i) & 1\n        bitC = (c >> i) & 1\n        if bitC == 0:\n            count += bitA + bitB\n        else:\n            count += 1 - (bitA | bitB)\n    return count\n\n"}
{"prompt": "def removeDuplicates(s: str, k: int) -> str:\n    \"\"\"\n    You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\n    We repeatedly make k duplicate removals on s until we no longer can.\n    Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcd\", k = 2\n    Output: \"abcd\"\n    Explanation: There's nothing to delete.\n    Example 2:\n\n    Input: s = \"deeedbbcccbdaa\", k = 3\n    Output: \"aa\"\n    Explanation: \n    First delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\n    Then delete \"bbb\", get \"dddaa\"\n    Finally delete \"ddd\", get \"aa\"\n    Example 3:\n\n    Input: s = \"pbbcggttciiippooaais\", k = 2\n    Output: \"ps\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    2 <= k <= 104\n    s only contains lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * n for c, n in stack)\n\n"}
{"prompt": "from typing import List\n\n\ndef findBall(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.\n    Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n\n    A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.\n    A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.\n\n    We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n    Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n    Output: [1,-1,-1,-1,-1]\n    Explanation: This example is shown in the photo.\n    Ball b0 is dropped at column 0 and falls out of the box at column 1.\n    Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\n    Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\n    Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\n    Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n\n    Example 2:\n\n    Input: grid = [[-1]]\n    Output: [-1]\n    Explanation: The ball gets stuck against the left wall.\n\n    Example 3:\n\n    Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n    Output: [0,1,2,3,4,-1]\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 100\n    grid[i][j] is 1 or -1.\n\n    \"\"\"\n", "canonical_solution": "    m, n = len(grid), len(grid[0])\n    result = [-1] * n\n\n    for i in range(n):\n        x, y = 0, i\n\n        while x < m:\n            nx, ny = x + 1, y + grid[x][y]\n            if ny < 0 or ny >= n or grid[x][ny] != grid[x][y]:\n                break\n            x, y = nx, ny\n\n        if x == m:\n            result[i] = y\n\n    return result\n\n"}
{"prompt": "def breakPalindrome(palindrome: str) -> str:\n    \"\"\"\n    Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\n    Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.\n    A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, \"abcc\" is lexicographically smaller than \"abcd\" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.\n\u00a0\n    Example 1:\n\n    Input: palindrome = \"abccba\"\n    Output: \"aaccba\"\n    Explanation: There are many ways to make \"abccba\" not a palindrome, such as \"zbccba\", \"aaccba\", and \"abacba\".\n    Of all the ways, \"aaccba\" is the lexicographically smallest.\n\n    Example 2:\n\n    Input: palindrome = \"a\"\n    Output: \"\"\n    Explanation: There is no way to replace a single character to make \"a\" not a palindrome, so return an empty string.\n\n\u00a0\n    Constraints:\n\n    1 <= palindrome.length <= 1000\n    palindrome consists of only lowercase English letters.\n\n    \"\"\"\n", "canonical_solution": "    length = len(palindrome)\n    if length == 1:\n        return \"\"\n\n    chars = list(palindrome)\n    for i in range(length // 2):\n        if chars[i] != 'a':\n            chars[i] = 'a'\n            return \"\".join(chars)\n\n    chars[length - 1] = 'b'\n    return \"\".join(chars)\n\n"}
{"prompt": "from typing import List\n\n\ndef longestSubsequence(arr: List[int], difference: int) -> int:\n    \"\"\"\n    Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\n    A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\n    Example 1:\n\n    Input: arr = [1,2,3,4], difference = 1\n    Output: 4\n    Explanation: The longest arithmetic subsequence is [1,2,3,4].\n    Example 2:\n\n    Input: arr = [1,3,5,7], difference = 1\n    Output: 1\n    Explanation: The longest arithmetic subsequence is any single element.\n\n    Example 3:\n\n    Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2\n    Output: 4\n    Explanation: The longest arithmetic subsequence is [7,5,3,1].\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 105\n    -104 <= arr[i], difference <= 104\n\n    \"\"\"\n", "canonical_solution": "    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength\n\n"}
{"prompt": "from typing import List\n\n\ndef getMaximumGold(grid: List[List[int]]) -> int:\n    \"\"\"\n    In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\n    Return the maximum amount of gold you can collect under the conditions:\n\n    Every time you are located in a cell you will collect all the gold in that cell.\n    From your position, you can walk one step to the left, right, up, or down.\n    You can't visit the same cell more than once.\n    Never visit a cell with 0 gold.\n    You can start and stop collecting gold from any position in the grid that has some gold.\n\n\u00a0\n    Example 1:\n\n    Input: grid = [[0,6,0],[5,8,7],[0,9,0]]\n    Output: 24\n    Explanation:\n    [[0,6,0],\n     [5,8,7],\n     [0,9,0]]\n    Path to get the maximum gold, 9 -> 8 -> 7.\n\n    Example 2:\n\n    Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n    Output: 28\n    Explanation:\n    [[1,0,7],\n     [2,0,6],\n     [3,4,5],\n     [0,3,0],\n     [9,0,20]]\n    Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 15\n    0 <= grid[i][j] <= 100\n    There are at most 25 cells containing gold.\n\n    \"\"\"\n", "canonical_solution": "    m, n, max_gold = len(grid), len(grid[0]), 0\n\n    def getMaximumGoldHelper(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:\n            return 0\n\n        original_gold = grid[x][y]\n        grid[x][y] = 0\n\n        max_gold = 0\n        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))\n\n        grid[x][y] = original_gold\n        return max_gold + original_gold\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                max_gold = max(max_gold, getMaximumGoldHelper(i, j))\n\n    return max_gold\n\n"}
{"prompt": "from typing import List\n\n\ndef findTheCity(n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    \"\"\"\n    There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\n    Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\n    Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n    Output: 3\n    Explanation: The figure above describes the graph.\u00a0\n    The neighboring cities at a distanceThreshold = 4 for each city are:\n    City 0 -> [City 1, City 2]\u00a0\n    City 1 -> [City 0, City 2, City 3]\u00a0\n    City 2 -> [City 0, City 1, City 3]\u00a0\n    City 3 -> [City 1, City 2]\u00a0\n    Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n    Example 2:\n\n\n    Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n    Output: 0\n    Explanation: The figure above describes the graph.\u00a0\n    The neighboring cities at a distanceThreshold = 2 for each city are:\n    City 0 -> [City 1]\u00a0\n    City 1 -> [City 0, City 4]\u00a0\n    City 2 -> [City 3, City 4]\u00a0\n    City 3 -> [City 2, City 4]\n    City 4 -> [City 1, City 2, City 3]\u00a0\n    The city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 100\n    1 <= edges.length <= n * (n - 1) / 2\n    edges[i].length == 3\n    0 <= fromi < toi < n\n    1 <= weighti,\u00a0distanceThreshold <= 10^4\n    All pairs (fromi, toi) are distinct.\n\n    \"\"\"\n", "canonical_solution": "    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res\n\n"}
{"prompt": "from typing import List\n\n\ndef minSetSize(arr: List[int]) -> int:\n    \"\"\"\n    You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\n    Return the minimum size of the set so that at least half of the integers of the array are removed.\n\u00a0\n    Example 1:\n\n    Input: arr = [3,3,3,3,5,5,5,2,2,7]\n    Output: 2\n    Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\n    Possible sets of size 2 are {3,5},{3,2},{5,2}.\n    Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.\n\n    Example 2:\n\n    Input: arr = [7,7,7,7,7,7]\n    Output: 1\n    Explanation: The only possible set you can choose is {7}. This will make the new array empty.\n\n\u00a0\n    Constraints:\n\n    2 <= arr.length <= 105\n    arr.length is even.\n    1 <= arr[i] <= 105\n\n    \"\"\"\n", "canonical_solution": "    import heapq\n    from collections import Counter\n    freq_map = Counter(arr)\n    max_heap = [-cnt for cnt in freq_map.values()]\n    heapq.heapify(max_heap)\n    half = len(arr) // 2\n    cnt = 0\n    size = 0\n    while size < half:\n        size -= heapq.heappop(max_heap)\n        cnt += 1\n    return cnt\n\n"}
{"prompt": "from typing import List\n\n\ndef max_area(height: List[int]) -> int:\n    \"\"\"\n    You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n    Find two lines that together with the x-axis form a container, such that the container contains the most water.\n    Return the maximum amount of water a container can store.\n    Notice that you may not slant the container.\n\u00a0\n    Example 1:\n\n\n    Input: height = [1,8,6,2,5,4,8,3,7]\n    Output: 49\n    Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n    Example 2:\n\n    Input: height = [1,1]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    n == height.length\n    2 <= n <= 105\n    0 <= height[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n\n"}
{"prompt": "from typing import List\n\n\ndef max_area(height: List[int]) -> int:\n    \"\"\"\n    You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n    Find two lines that together with the x-axis form a container, such that the container contains the most water.\n    Return the maximum amount of water a container can store.\n    Notice that you may not slant the container.\n\u00a0\n    Example 1:\n\n\n    Input: height = [1,8,6,2,5,4,8,3,7]\n    Output: 49\n    Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n    Example 2:\n\n    Input: height = [1,1]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    n == height.length\n    2 <= n <= 105\n    0 <= height[i] <= 104\n\n    \"\"\"\n", "canonical_solution": "    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n\n"}
